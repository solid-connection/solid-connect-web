"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\nvar undici_1 = __webpack_require__(/*! ./undici */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\");\nObject.defineProperty(exports, \"UndiciInstrumentation\", ({ enumerable: true, get: function () { return undici_1.UndiciInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyw2TEFBVTtBQUNqQyx5REFBd0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDMUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvaW5kZXguanM/Y2VjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbnZhciB1bmRpY2lfMSA9IHJlcXVpcmUoXCIuL3VuZGljaVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZGljaUluc3RydW1lbnRhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kaWNpXzEuVW5kaWNpSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst diagch = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.39.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\");\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass UndiciInstrumentation extends instrumentation_1.InstrumentationBase {\n    _recordFromReq = new WeakMap();\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    // No need to instrument files/modules\n    init() {\n        return undefined;\n    }\n    disable() {\n        super.disable();\n        this._channelSubs.forEach(sub => sub.unsubscribe());\n        this._channelSubs.length = 0;\n    }\n    enable() {\n        // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n        // If constructed with `{enabled: false}`, this `.enable()` is still called,\n        // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n        //\n        // For now, this class will setup for instrumenting if `.enable()` is\n        // called, but use `this.getConfig().enabled` to determine if\n        // instrumentation should be generated. This covers the more likely common\n        // case of config being given a construction time, rather than later via\n        // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n        super.enable();\n        // This method is called by the super-class constructor before ours is\n        // called. So we need to ensure the property is initalized.\n        this._channelSubs = this._channelSubs || [];\n        // Avoid to duplicate subscriptions\n        if (this._channelSubs.length > 0) {\n            return;\n        }\n        this.subscribeToChannel('undici:request:create', this.onRequestCreated.bind(this));\n        this.subscribeToChannel('undici:client:sendHeaders', this.onRequestHeaders.bind(this));\n        this.subscribeToChannel('undici:request:headers', this.onResponseHeaders.bind(this));\n        this.subscribeToChannel('undici:request:trailers', this.onDone.bind(this));\n        this.subscribeToChannel('undici:request:error', this.onError.bind(this));\n    }\n    _updateMetricInstruments() {\n        this._httpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        // `diagnostics_channel` had a ref counting bug until v18.19.0.\n        // https://github.com/nodejs/node/pull/47520\n        const [major, minor] = process.version\n            .replace('v', '')\n            .split('.')\n            .map(n => Number(n));\n        const useNewSubscribe = major > 18 || (major === 18 && minor >= 19);\n        let unsubscribe;\n        if (useNewSubscribe) {\n            diagch.subscribe?.(diagnosticChannel, onMessage);\n            unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n        }\n        else {\n            const channel = diagch.channel(diagnosticChannel);\n            channel.subscribe(onMessage);\n            unsubscribe = () => channel.unsubscribe(onMessage);\n        }\n        this._channelSubs.push({\n            name: diagnosticChannel,\n            unsubscribe,\n        });\n    }\n    parseRequestHeaders(request) {\n        const result = new Map();\n        if (Array.isArray(request.headers)) {\n            // headers are an array [k1, v2, k2, v2] (undici v6+)\n            // values could be string or a string[] for multiple values\n            for (let i = 0; i < request.headers.length; i += 2) {\n                const key = request.headers[i];\n                const value = request.headers[i + 1];\n                // Key should always be a string, but the types don't know that, and let's be safe\n                if (typeof key === 'string') {\n                    result.set(key.toLowerCase(), value);\n                }\n            }\n        }\n        else if (typeof request.headers === 'string') {\n            // headers are a raw string (undici v5)\n            // headers could be repeated in several lines for multiple values\n            const headers = request.headers.split('\\r\\n');\n            for (const line of headers) {\n                if (!line) {\n                    continue;\n                }\n                const colonIndex = line.indexOf(':');\n                if (colonIndex === -1) {\n                    // Invalid header? Probably this can't happen, but again let's be safe.\n                    continue;\n                }\n                const key = line.substring(0, colonIndex).toLowerCase();\n                const value = line.substring(colonIndex + 1).trim();\n                const allValues = result.get(key);\n                if (allValues && Array.isArray(allValues)) {\n                    allValues.push(value);\n                }\n                else if (allValues) {\n                    result.set(key, [allValues, value]);\n                }\n                else {\n                    result.set(key, value);\n                }\n            }\n        }\n        return result;\n    }\n    // This is the 1st message we receive for each request (fired after request creation). Here we will\n    // create the span and populate some atttributes, then link the span to the request for further\n    // span processing\n    onRequestCreated({ request }) {\n        // Ignore if:\n        // - instrumentation is disabled\n        // - ignored by config\n        // - method is 'CONNECT'\n        const config = this.getConfig();\n        const enabled = config.enabled !== false;\n        const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => !enabled ||\n            request.method === 'CONNECT' ||\n            config.ignoreRequestHook?.(request), e => e && this._diag.error('caught ignoreRequestHook error: ', e), true);\n        if (shouldIgnoreReq) {\n            return;\n        }\n        const startTime = (0, core_1.hrTime)();\n        let requestUrl;\n        try {\n            requestUrl = new url_1.URL(request.path, request.origin);\n        }\n        catch (err) {\n            this._diag.warn('could not determine url.full:', err);\n            // Skip instrumenting this request.\n            return;\n        }\n        const urlScheme = requestUrl.protocol.replace(':', '');\n        const requestMethod = this.getRequestMethod(request.method);\n        const attributes = {\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: requestMethod,\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL]: request.method,\n            [semantic_conventions_1.ATTR_URL_FULL]: requestUrl.toString(),\n            [semantic_conventions_1.ATTR_URL_PATH]: requestUrl.pathname,\n            [semantic_conventions_1.ATTR_URL_QUERY]: requestUrl.search,\n            [semantic_conventions_1.ATTR_URL_SCHEME]: urlScheme,\n        };\n        const schemePorts = { https: '443', http: '80' };\n        const serverAddress = requestUrl.hostname;\n        const serverPort = requestUrl.port || schemePorts[urlScheme];\n        attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS] = serverAddress;\n        if (serverPort && !isNaN(Number(serverPort))) {\n            attributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverPort);\n        }\n        // Get user agent from headers\n        const headersMap = this.parseRequestHeaders(request);\n        const userAgentValues = headersMap.get('user-agent');\n        if (userAgentValues) {\n            // NOTE: having multiple user agents is not expected so\n            // we're going to take last one like `curl` does\n            // ref: https://curl.se/docs/manpage.html#-A\n            const userAgent = Array.isArray(userAgentValues)\n                ? userAgentValues[userAgentValues.length - 1]\n                : userAgentValues;\n            attributes[semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL] = userAgent;\n        }\n        // Get attributes from the hook if present\n        const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.startSpanHook?.(request), e => e && this._diag.error('caught startSpanHook error: ', e), true);\n        if (hookAttributes) {\n            Object.entries(hookAttributes).forEach(([key, val]) => {\n                attributes[key] = val;\n            });\n        }\n        // Check if parent span is required via config and:\n        // - if a parent is required but not present, we use a `NoopSpan` to still\n        //   propagate context without recording it.\n        // - create a span otherwise\n        const activeCtx = api_1.context.active();\n        const currentSpan = api_1.trace.getSpan(activeCtx);\n        let span;\n        if (config.requireParentforSpans &&\n            (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else {\n            span = this.tracer.startSpan(requestMethod === '_OTHER' ? 'HTTP' : requestMethod, {\n                kind: api_1.SpanKind.CLIENT,\n                attributes: attributes,\n            }, activeCtx);\n        }\n        // Execute the request hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.requestHook?.(span, request), e => e && this._diag.error('caught requestHook error: ', e), true);\n        // Context propagation goes last so no hook can tamper\n        // the propagation headers\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        const headerEntries = Object.entries(addedHeaders);\n        for (let i = 0; i < headerEntries.length; i++) {\n            const [k, v] = headerEntries[i];\n            if (typeof request.addHeader === 'function') {\n                request.addHeader(k, v);\n            }\n            else if (typeof request.headers === 'string') {\n                request.headers += `${k}: ${v}\\r\\n`;\n            }\n            else if (Array.isArray(request.headers)) {\n                // undici@6.11.0 accidentally, briefly removed `request.addHeader()`.\n                request.headers.push(k, v);\n            }\n        }\n        this._recordFromReq.set(request, { span, attributes, startTime });\n    }\n    // This is the 2nd message we receive for each request. It is fired when connection with\n    // the remote is established and about to send the first byte. Here we do have info about the\n    // remote address and port so we can populate some `network.*` attributes into the span\n    onRequestHeaders({ request, socket }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const config = this.getConfig();\n        const { span } = record;\n        const { remoteAddress, remotePort } = socket;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: remoteAddress,\n            [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: remotePort,\n        };\n        // After hooks have been processed (which may modify request headers)\n        // we can collect the headers based on the configuration\n        if (config.headersToSpanAttributes?.requestHeaders) {\n            const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map(n => n.toLowerCase()));\n            const headersMap = this.parseRequestHeaders(request);\n            for (const [name, value] of headersMap.entries()) {\n                if (headersToAttribs.has(name)) {\n                    const attrValue = Array.isArray(value) ? value.join(', ') : value;\n                    spanAttributes[`http.request.header.${name}`] = attrValue;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n    }\n    // This is the 3rd message we get for each request and it's fired when the server\n    // headers are received, body may not be accessible yet.\n    // From the response headers we can set the status and content length\n    onResponseHeaders({ request, response, }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes } = record;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: response.statusCode,\n        };\n        const config = this.getConfig();\n        // Execute the response hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.responseHook?.(span, { request, response }), e => e && this._diag.error('caught responseHook error: ', e), true);\n        const headersToAttribs = new Set();\n        if (config.headersToSpanAttributes?.responseHeaders) {\n            config.headersToSpanAttributes?.responseHeaders.forEach(name => headersToAttribs.add(name.toLowerCase()));\n        }\n        for (let idx = 0; idx < response.headers.length; idx = idx + 2) {\n            const name = response.headers[idx].toString().toLowerCase();\n            const value = response.headers[idx + 1];\n            if (headersToAttribs.has(name)) {\n                spanAttributes[`http.response.header.${name}`] = value.toString();\n            }\n            if (name === 'content-length') {\n                const contentLength = Number(value.toString());\n                if (!isNaN(contentLength)) {\n                    spanAttributes['http.response.header.content-length'] = contentLength;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n        span.setStatus({\n            code: response.statusCode >= 400\n                ? api_1.SpanStatusCode.ERROR\n                : api_1.SpanStatusCode.UNSET,\n        });\n        record.attributes = Object.assign(attributes, spanAttributes);\n    }\n    // This is the last event we receive if the request went without any errors\n    onDone({ request }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // End the span\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics\n        this.recordRequestDuration(attributes, startTime);\n    }\n    // This is the event we get when something is wrong in the request like\n    // - invalid options when calling `fetch` global API or any undici method for request\n    // - connectivity errors such as unreachable host\n    // - requests aborted through an `AbortController.signal`\n    // NOTE: server errors are considered valid responses and it's the lib consumer\n    // who should deal with that.\n    onError({ request, error }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // NOTE: in `undici@6.3.0` when request aborted the error type changes from\n        // a custom error (`RequestAbortedError`) to a built-in `DOMException` carrying\n        // some differences:\n        // - `code` is from DOMEXception (ABORT_ERR: 20)\n        // - `message` changes\n        // - stacktrace is smaller and contains node internal frames\n        span.recordException(error);\n        span.setStatus({\n            code: api_1.SpanStatusCode.ERROR,\n            message: error.message,\n        });\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics (with the error)\n        attributes[semantic_conventions_1.ATTR_ERROR_TYPE] = error.message;\n        this.recordRequestDuration(attributes, startTime);\n    }\n    recordRequestDuration(attributes, startTime) {\n        // Time to record metrics\n        const metricsAttributes = {};\n        // Get the attribs already in span attributes\n        const keysToCopy = [\n            semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE,\n            semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD,\n            semantic_conventions_1.ATTR_SERVER_ADDRESS,\n            semantic_conventions_1.ATTR_SERVER_PORT,\n            semantic_conventions_1.ATTR_URL_SCHEME,\n            semantic_conventions_1.ATTR_ERROR_TYPE,\n        ];\n        keysToCopy.forEach(key => {\n            if (key in attributes) {\n                metricsAttributes[key] = attributes[key];\n            }\n        });\n        // Take the duration and record it\n        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;\n        this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);\n    }\n    getRequestMethod(original) {\n        const knownMethods = {\n            CONNECT: true,\n            OPTIONS: true,\n            HEAD: true,\n            GET: true,\n            POST: true,\n            PUT: true,\n            PATCH: true,\n            DELETE: true,\n            TRACE: true,\n        };\n        if (original.toUpperCase() in knownMethods) {\n            return original.toUpperCase();\n        }\n        return '_OTHER';\n    }\n}\nexports.UndiciInstrumentation = UndiciInstrumentation;\n//# sourceMappingURL=undici.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdW5kaWNpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0RBQXFCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyxxTUFBZ0M7QUFDbEUsY0FBYyxtQkFBTyxDQUFDLHNJQUFvQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsa0tBQXFCO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLDBMQUFxQztBQUM1RTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLCtMQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsSUFBSSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2QkFBNkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG1CQUFtQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdW5kaWNpLmpzPzNmNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBkaWFnY2ggPSByZXF1aXJlKFwiZGlhZ25vc3RpY3NfY2hhbm5lbFwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbi8qKiBAa25pcGlnbm9yZSAqL1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbi8vIEEgY29tYmluYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvYXBtLWFnZW50LW5vZGVqcyBhbmRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWRnZXQtaW5jL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9ucy9ibG9iL21haW4vcGFja2FnZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24tdW5kaWNpL3NyYy9pbmRleC50c1xuY2xhc3MgVW5kaWNpSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgX3JlY29yZEZyb21SZXEgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIGNvbmZpZyk7XG4gICAgfVxuICAgIC8vIE5vIG5lZWQgdG8gaW5zdHJ1bWVudCBmaWxlcy9tb2R1bGVzXG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLl9jaGFubmVsU3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMuX2NoYW5uZWxTdWJzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgLy8gXCJlbmFibGVkXCIgaGFuZGxpbmcgaXMgY3VycmVudGx5IGEgYml0IG1lc3N5IHdpdGggSW5zdHJ1bWVudGF0aW9uQmFzZS5cbiAgICAgICAgLy8gSWYgY29uc3RydWN0ZWQgd2l0aCBge2VuYWJsZWQ6IGZhbHNlfWAsIHRoaXMgYC5lbmFibGUoKWAgaXMgc3RpbGwgY2FsbGVkLFxuICAgICAgICAvLyBhbmQgYHRoaXMuZ2V0Q29uZmlnKCkuZW5hYmxlZCAhPT0gdGhpcy5pc0VuYWJsZWQoKWAsIGNyZWF0aW5nIGNvbmZ1c2lvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBjbGFzcyB3aWxsIHNldHVwIGZvciBpbnN0cnVtZW50aW5nIGlmIGAuZW5hYmxlKClgIGlzXG4gICAgICAgIC8vIGNhbGxlZCwgYnV0IHVzZSBgdGhpcy5nZXRDb25maWcoKS5lbmFibGVkYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgICAgLy8gaW5zdHJ1bWVudGF0aW9uIHNob3VsZCBiZSBnZW5lcmF0ZWQuIFRoaXMgY292ZXJzIHRoZSBtb3JlIGxpa2VseSBjb21tb25cbiAgICAgICAgLy8gY2FzZSBvZiBjb25maWcgYmVpbmcgZ2l2ZW4gYSBjb25zdHJ1Y3Rpb24gdGltZSwgcmF0aGVyIHRoYW4gbGF0ZXIgdmlhXG4gICAgICAgIC8vIGBpbnN0YW5jZS5lbmFibGUoKWAsIGAuZGlzYWJsZSgpYCwgb3IgYC5zZXRDb25maWcoKWAgY2FsbHMuXG4gICAgICAgIHN1cGVyLmVuYWJsZSgpO1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHN1cGVyLWNsYXNzIGNvbnN0cnVjdG9yIGJlZm9yZSBvdXJzIGlzXG4gICAgICAgIC8vIGNhbGxlZC4gU28gd2UgbmVlZCB0byBlbnN1cmUgdGhlIHByb3BlcnR5IGlzIGluaXRhbGl6ZWQuXG4gICAgICAgIHRoaXMuX2NoYW5uZWxTdWJzID0gdGhpcy5fY2hhbm5lbFN1YnMgfHwgW107XG4gICAgICAgIC8vIEF2b2lkIHRvIGR1cGxpY2F0ZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIGlmICh0aGlzLl9jaGFubmVsU3Vicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmNyZWF0ZScsIHRoaXMub25SZXF1ZXN0Q3JlYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnLCB0aGlzLm9uUmVxdWVzdEhlYWRlcnMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJywgdGhpcy5vblJlc3BvbnNlSGVhZGVycy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJywgdGhpcy5vbkRvbmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9odHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbShzZW1hbnRpY19jb252ZW50aW9uc18xLk1FVFJJQ19IVFRQX0NMSUVOVF9SRVFVRVNUX0RVUkFUSU9OLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01lYXN1cmVzIHRoZSBkdXJhdGlvbiBvZiBvdXRib3VuZCBIVFRQIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAncycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgICAgICBhZHZpY2U6IHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdEJ1Y2tldEJvdW5kYXJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSxcbiAgICAgICAgICAgICAgICAgICAgNy41LCAxMCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvQ2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCwgb25NZXNzYWdlKSB7XG4gICAgICAgIC8vIGBkaWFnbm9zdGljc19jaGFubmVsYCBoYWQgYSByZWYgY291bnRpbmcgYnVnIHVudGlsIHYxOC4xOS4wLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NzUyMFxuICAgICAgICBjb25zdCBbbWFqb3IsIG1pbm9yXSA9IHByb2Nlc3MudmVyc2lvblxuICAgICAgICAgICAgLnJlcGxhY2UoJ3YnLCAnJylcbiAgICAgICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgICAgICAubWFwKG4gPT4gTnVtYmVyKG4pKTtcbiAgICAgICAgY29uc3QgdXNlTmV3U3Vic2NyaWJlID0gbWFqb3IgPiAxOCB8fCAobWFqb3IgPT09IDE4ICYmIG1pbm9yID49IDE5KTtcbiAgICAgICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAodXNlTmV3U3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBkaWFnY2guc3Vic2NyaWJlPy4oZGlhZ25vc3RpY0NoYW5uZWwsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9ICgpID0+IGRpYWdjaC51bnN1YnNjcmliZT8uKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGRpYWdjaC5jaGFubmVsKGRpYWdub3N0aWNDaGFubmVsKTtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9ICgpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUob25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsU3Vicy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRpYWdub3N0aWNDaGFubmVsLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbiBhcnJheSBbazEsIHYyLCBrMiwgdjJdICh1bmRpY2kgdjYrKVxuICAgICAgICAgICAgLy8gdmFsdWVzIGNvdWxkIGJlIHN0cmluZyBvciBhIHN0cmluZ1tdIGZvciBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdC5oZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVxdWVzdC5oZWFkZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVxdWVzdC5oZWFkZXJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAvLyBLZXkgc2hvdWxkIGFsd2F5cyBiZSBhIHN0cmluZywgYnV0IHRoZSB0eXBlcyBkb24ndCBrbm93IHRoYXQsIGFuZCBsZXQncyBiZSBzYWZlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgYXJlIGEgcmF3IHN0cmluZyAodW5kaWNpIHY1KVxuICAgICAgICAgICAgLy8gaGVhZGVycyBjb3VsZCBiZSByZXBlYXRlZCBpbiBzZXZlcmFsIGxpbmVzIGZvciBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBoZWFkZXI/IFByb2JhYmx5IHRoaXMgY2FuJ3QgaGFwcGVuLCBidXQgYWdhaW4gbGV0J3MgYmUgc2FmZS5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IHJlc3VsdC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsVmFsdWVzICYmIEFycmF5LmlzQXJyYXkoYWxsVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgW2FsbFZhbHVlcywgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDFzdCBtZXNzYWdlIHdlIHJlY2VpdmUgZm9yIGVhY2ggcmVxdWVzdCAoZmlyZWQgYWZ0ZXIgcmVxdWVzdCBjcmVhdGlvbikuIEhlcmUgd2Ugd2lsbFxuICAgIC8vIGNyZWF0ZSB0aGUgc3BhbiBhbmQgcG9wdWxhdGUgc29tZSBhdHR0cmlidXRlcywgdGhlbiBsaW5rIHRoZSBzcGFuIHRvIHRoZSByZXF1ZXN0IGZvciBmdXJ0aGVyXG4gICAgLy8gc3BhbiBwcm9jZXNzaW5nXG4gICAgb25SZXF1ZXN0Q3JlYXRlZCh7IHJlcXVlc3QgfSkge1xuICAgICAgICAvLyBJZ25vcmUgaWY6XG4gICAgICAgIC8vIC0gaW5zdHJ1bWVudGF0aW9uIGlzIGRpc2FibGVkXG4gICAgICAgIC8vIC0gaWdub3JlZCBieSBjb25maWdcbiAgICAgICAgLy8gLSBtZXRob2QgaXMgJ0NPTk5FQ1QnXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSBjb25maWcuZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHNob3VsZElnbm9yZVJlcSA9ICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiAhZW5hYmxlZCB8fFxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJyB8fFxuICAgICAgICAgICAgY29uZmlnLmlnbm9yZVJlcXVlc3RIb29rPy4ocmVxdWVzdCksIGUgPT4gZSAmJiB0aGlzLl9kaWFnLmVycm9yKCdjYXVnaHQgaWdub3JlUmVxdWVzdEhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVJlcSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9ICgwLCBjb3JlXzEuaHJUaW1lKSgpO1xuICAgICAgICBsZXQgcmVxdWVzdFVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgPSBuZXcgdXJsXzEuVVJMKHJlcXVlc3QucGF0aCwgcmVxdWVzdC5vcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWcud2FybignY291bGQgbm90IGRldGVybWluZSB1cmwuZnVsbDonLCBlcnIpO1xuICAgICAgICAgICAgLy8gU2tpcCBpbnN0cnVtZW50aW5nIHRoaXMgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxTY2hlbWUgPSByZXF1ZXN0VXJsLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSB0aGlzLmdldFJlcXVlc3RNZXRob2QocmVxdWVzdC5tZXRob2QpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF9PUklHSU5BTF06IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfRlVMTF06IHJlcXVlc3RVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1BBVEhdOiByZXF1ZXN0VXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfUVVFUlldOiByZXF1ZXN0VXJsLnNlYXJjaCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV06IHVybFNjaGVtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2NoZW1lUG9ydHMgPSB7IGh0dHBzOiAnNDQzJywgaHR0cDogJzgwJyB9O1xuICAgICAgICBjb25zdCBzZXJ2ZXJBZGRyZXNzID0gcmVxdWVzdFVybC5ob3N0bmFtZTtcbiAgICAgICAgY29uc3Qgc2VydmVyUG9ydCA9IHJlcXVlc3RVcmwucG9ydCB8fCBzY2hlbWVQb3J0c1t1cmxTY2hlbWVdO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU10gPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICBpZiAoc2VydmVyUG9ydCAmJiAhaXNOYU4oTnVtYmVyKHNlcnZlclBvcnQpKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdID0gTnVtYmVyKHNlcnZlclBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB1c2VyIGFnZW50IGZyb20gaGVhZGVyc1xuICAgICAgICBjb25zdCBoZWFkZXJzTWFwID0gdGhpcy5wYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1c2VyQWdlbnRWYWx1ZXMgPSBoZWFkZXJzTWFwLmdldCgndXNlci1hZ2VudCcpO1xuICAgICAgICBpZiAodXNlckFnZW50VmFsdWVzKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBoYXZpbmcgbXVsdGlwbGUgdXNlciBhZ2VudHMgaXMgbm90IGV4cGVjdGVkIHNvXG4gICAgICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byB0YWtlIGxhc3Qgb25lIGxpa2UgYGN1cmxgIGRvZXNcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9jdXJsLnNlL2RvY3MvbWFucGFnZS5odG1sIy1BXG4gICAgICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSBBcnJheS5pc0FycmF5KHVzZXJBZ2VudFZhbHVlcylcbiAgICAgICAgICAgICAgICA/IHVzZXJBZ2VudFZhbHVlc1t1c2VyQWdlbnRWYWx1ZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICA6IHVzZXJBZ2VudFZhbHVlcztcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VTRVJfQUdFTlRfT1JJR0lOQUxdID0gdXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhdHRyaWJ1dGVzIGZyb20gdGhlIGhvb2sgaWYgcHJlc2VudFxuICAgICAgICBjb25zdCBob29rQXR0cmlidXRlcyA9ICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcuc3RhcnRTcGFuSG9vaz8uKHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHN0YXJ0U3Bhbkhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgaWYgKGhvb2tBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhob29rQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHBhcmVudCBzcGFuIGlzIHJlcXVpcmVkIHZpYSBjb25maWcgYW5kOlxuICAgICAgICAvLyAtIGlmIGEgcGFyZW50IGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJlc2VudCwgd2UgdXNlIGEgYE5vb3BTcGFuYCB0byBzdGlsbFxuICAgICAgICAvLyAgIHByb3BhZ2F0ZSBjb250ZXh0IHdpdGhvdXQgcmVjb3JkaW5nIGl0LlxuICAgICAgICAvLyAtIGNyZWF0ZSBhIHNwYW4gb3RoZXJ3aXNlXG4gICAgICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGFwaV8xLmNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gYXBpXzEudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgICAgICBsZXQgc3BhbjtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXF1aXJlUGFyZW50Zm9yU3BhbnMgJiZcbiAgICAgICAgICAgICghY3VycmVudFNwYW4gfHwgIWFwaV8xLnRyYWNlLmlzU3BhbkNvbnRleHRWYWxpZChjdXJyZW50U3Bhbi5zcGFuQ29udGV4dCgpKSkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBhcGlfMS50cmFjZS53cmFwU3BhbkNvbnRleHQoYXBpXzEuSU5WQUxJRF9TUEFOX0NPTlRFWFQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihyZXF1ZXN0TWV0aG9kID09PSAnX09USEVSJyA/ICdIVFRQJyA6IHJlcXVlc3RNZXRob2QsIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sIGFjdGl2ZUN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcmVxdWVzdCBob29rIGlmIGRlZmluZWRcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbmZpZy5yZXF1ZXN0SG9vaz8uKHNwYW4sIHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHJlcXVlc3RIb29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIC8vIENvbnRleHQgcHJvcGFnYXRpb24gZ29lcyBsYXN0IHNvIG5vIGhvb2sgY2FuIHRhbXBlclxuICAgICAgICAvLyB0aGUgcHJvcGFnYXRpb24gaGVhZGVyc1xuICAgICAgICBjb25zdCByZXF1ZXN0Q29udGV4dCA9IGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgc3Bhbik7XG4gICAgICAgIGNvbnN0IGFkZGVkSGVhZGVycyA9IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QocmVxdWVzdENvbnRleHQsIGFkZGVkSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGhlYWRlckVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhZGRlZEhlYWRlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlckVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtrLCB2XSA9IGhlYWRlckVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QuYWRkSGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRIZWFkZXIoaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBgJHtrfTogJHt2fVxcclxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmRpY2lANi4xMS4wIGFjY2lkZW50YWxseSwgYnJpZWZseSByZW1vdmVkIGByZXF1ZXN0LmFkZEhlYWRlcigpYC5cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWNvcmRGcm9tUmVxLnNldChyZXF1ZXN0LCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgMm5kIG1lc3NhZ2Ugd2UgcmVjZWl2ZSBmb3IgZWFjaCByZXF1ZXN0LiBJdCBpcyBmaXJlZCB3aGVuIGNvbm5lY3Rpb24gd2l0aFxuICAgIC8vIHRoZSByZW1vdGUgaXMgZXN0YWJsaXNoZWQgYW5kIGFib3V0IHRvIHNlbmQgdGhlIGZpcnN0IGJ5dGUuIEhlcmUgd2UgZG8gaGF2ZSBpbmZvIGFib3V0IHRoZVxuICAgIC8vIHJlbW90ZSBhZGRyZXNzIGFuZCBwb3J0IHNvIHdlIGNhbiBwb3B1bGF0ZSBzb21lIGBuZXR3b3JrLipgIGF0dHJpYnV0ZXMgaW50byB0aGUgc3BhblxuICAgIG9uUmVxdWVzdEhlYWRlcnMoeyByZXF1ZXN0LCBzb2NrZXQgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBjb25zdCB7IHNwYW4gfSA9IHJlY29yZDtcbiAgICAgICAgY29uc3QgeyByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSBzb2NrZXQ7XG4gICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfQUREUkVTU106IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXTogcmVtb3RlUG9ydCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWZ0ZXIgaG9va3MgaGF2ZSBiZWVuIHByb2Nlc3NlZCAod2hpY2ggbWF5IG1vZGlmeSByZXF1ZXN0IGhlYWRlcnMpXG4gICAgICAgIC8vIHdlIGNhbiBjb2xsZWN0IHRoZSBoZWFkZXJzIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICAgIGlmIChjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LnJlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzVG9BdHRyaWJzID0gbmV3IFNldChjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMucmVxdWVzdEhlYWRlcnMubWFwKG4gPT4gbi50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzTWFwID0gdGhpcy5wYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGhlYWRlcnNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNUb0F0dHJpYnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tgaHR0cC5yZXF1ZXN0LmhlYWRlci4ke25hbWV9YF0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhzcGFuQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDNyZCBtZXNzYWdlIHdlIGdldCBmb3IgZWFjaCByZXF1ZXN0IGFuZCBpdCdzIGZpcmVkIHdoZW4gdGhlIHNlcnZlclxuICAgIC8vIGhlYWRlcnMgYXJlIHJlY2VpdmVkLCBib2R5IG1heSBub3QgYmUgYWNjZXNzaWJsZSB5ZXQuXG4gICAgLy8gRnJvbSB0aGUgcmVzcG9uc2UgaGVhZGVycyB3ZSBjYW4gc2V0IHRoZSBzdGF0dXMgYW5kIGNvbnRlbnQgbGVuZ3RoXG4gICAgb25SZXNwb25zZUhlYWRlcnMoeyByZXF1ZXN0LCByZXNwb25zZSwgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMgfSA9IHJlY29yZDtcbiAgICAgICAgY29uc3Qgc3BhbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSByZXNwb25zZSBob29rIGlmIGRlZmluZWRcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbmZpZy5yZXNwb25zZUhvb2s/LihzcGFuLCB7IHJlcXVlc3QsIHJlc3BvbnNlIH0pLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHJlc3BvbnNlSG9vayBlcnJvcjogJywgZSksIHRydWUpO1xuICAgICAgICBjb25zdCBoZWFkZXJzVG9BdHRyaWJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcz8ucmVzcG9uc2VIZWFkZXJzLmZvckVhY2gobmFtZSA9PiBoZWFkZXJzVG9BdHRyaWJzLmFkZChuYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCByZXNwb25zZS5oZWFkZXJzLmxlbmd0aDsgaWR4ID0gaWR4ICsgMikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHJlc3BvbnNlLmhlYWRlcnNbaWR4XS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNbaWR4ICsgMV07XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1RvQXR0cmlicy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tgaHR0cC5yZXNwb25zZS5oZWFkZXIuJHtuYW1lfWBdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IE51bWJlcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5BdHRyaWJ1dGVzWydodHRwLnJlc3BvbnNlLmhlYWRlci5jb250ZW50LWxlbmd0aCddID0gY29udGVudExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHNwYW5BdHRyaWJ1dGVzKTtcbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDBcbiAgICAgICAgICAgICAgICA/IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5VTlNFVCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBzcGFuQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgZXZlbnQgd2UgcmVjZWl2ZSBpZiB0aGUgcmVxdWVzdCB3ZW50IHdpdGhvdXQgYW55IGVycm9yc1xuICAgIG9uRG9uZSh7IHJlcXVlc3QgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9ID0gcmVjb3JkO1xuICAgICAgICAvLyBFbmQgdGhlIHNwYW5cbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzXG4gICAgICAgIHRoaXMucmVjb3JkUmVxdWVzdER1cmF0aW9uKGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGV2ZW50IHdlIGdldCB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZyBpbiB0aGUgcmVxdWVzdCBsaWtlXG4gICAgLy8gLSBpbnZhbGlkIG9wdGlvbnMgd2hlbiBjYWxsaW5nIGBmZXRjaGAgZ2xvYmFsIEFQSSBvciBhbnkgdW5kaWNpIG1ldGhvZCBmb3IgcmVxdWVzdFxuICAgIC8vIC0gY29ubmVjdGl2aXR5IGVycm9ycyBzdWNoIGFzIHVucmVhY2hhYmxlIGhvc3RcbiAgICAvLyAtIHJlcXVlc3RzIGFib3J0ZWQgdGhyb3VnaCBhbiBgQWJvcnRDb250cm9sbGVyLnNpZ25hbGBcbiAgICAvLyBOT1RFOiBzZXJ2ZXIgZXJyb3JzIGFyZSBjb25zaWRlcmVkIHZhbGlkIHJlc3BvbnNlcyBhbmQgaXQncyB0aGUgbGliIGNvbnN1bWVyXG4gICAgLy8gd2hvIHNob3VsZCBkZWFsIHdpdGggdGhhdC5cbiAgICBvbkVycm9yKHsgcmVxdWVzdCwgZXJyb3IgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9ID0gcmVjb3JkO1xuICAgICAgICAvLyBOT1RFOiBpbiBgdW5kaWNpQDYuMy4wYCB3aGVuIHJlcXVlc3QgYWJvcnRlZCB0aGUgZXJyb3IgdHlwZSBjaGFuZ2VzIGZyb21cbiAgICAgICAgLy8gYSBjdXN0b20gZXJyb3IgKGBSZXF1ZXN0QWJvcnRlZEVycm9yYCkgdG8gYSBidWlsdC1pbiBgRE9NRXhjZXB0aW9uYCBjYXJyeWluZ1xuICAgICAgICAvLyBzb21lIGRpZmZlcmVuY2VzOlxuICAgICAgICAvLyAtIGBjb2RlYCBpcyBmcm9tIERPTUVYY2VwdGlvbiAoQUJPUlRfRVJSOiAyMClcbiAgICAgICAgLy8gLSBgbWVzc2FnZWAgY2hhbmdlc1xuICAgICAgICAvLyAtIHN0YWNrdHJhY2UgaXMgc21hbGxlciBhbmQgY29udGFpbnMgbm9kZSBpbnRlcm5hbCBmcmFtZXNcbiAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB0aGlzLl9yZWNvcmRGcm9tUmVxLmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgLy8gUmVjb3JkIG1ldHJpY3MgKHdpdGggdGhlIGVycm9yKVxuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVjb3JkUmVxdWVzdER1cmF0aW9uKGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgfVxuICAgIHJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gVGltZSB0byByZWNvcmQgbWV0cmljc1xuICAgICAgICBjb25zdCBtZXRyaWNzQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAvLyBHZXQgdGhlIGF0dHJpYnMgYWxyZWFkeSBpbiBzcGFuIGF0dHJpYnV0ZXNcbiAgICAgICAgY29uc3Qga2V5c1RvQ29weSA9IFtcbiAgICAgICAgICAgIHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFLFxuICAgICAgICAgICAgc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0QsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1MsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlQsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRSxcbiAgICAgICAgICAgIHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLFxuICAgICAgICBdO1xuICAgICAgICBrZXlzVG9Db3B5LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3NBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUYWtlIHRoZSBkdXJhdGlvbiBhbmQgcmVjb3JkIGl0XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uU2Vjb25kcyA9ICgwLCBjb3JlXzEuaHJUaW1lVG9NaWxsaXNlY29uZHMpKCgwLCBjb3JlXzEuaHJUaW1lRHVyYXRpb24pKHN0YXJ0VGltZSwgKDAsIGNvcmVfMS5oclRpbWUpKCkpKSAvIDEwMDA7XG4gICAgICAgIHRoaXMuX2h0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25TZWNvbmRzLCBtZXRyaWNzQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RNZXRob2Qob3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qga25vd25NZXRob2RzID0ge1xuICAgICAgICAgICAgQ09OTkVDVDogdHJ1ZSxcbiAgICAgICAgICAgIE9QVElPTlM6IHRydWUsXG4gICAgICAgICAgICBIRUFEOiB0cnVlLFxuICAgICAgICAgICAgR0VUOiB0cnVlLFxuICAgICAgICAgICAgUE9TVDogdHJ1ZSxcbiAgICAgICAgICAgIFBVVDogdHJ1ZSxcbiAgICAgICAgICAgIFBBVENIOiB0cnVlLFxuICAgICAgICAgICAgREVMRVRFOiB0cnVlLFxuICAgICAgICAgICAgVFJBQ0U6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcmlnaW5hbC50b1VwcGVyQ2FzZSgpIGluIGtub3duTWV0aG9kcykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdfT1RIRVInO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5kaWNpSW5zdHJ1bWVudGF0aW9uID0gVW5kaWNpSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5kaWNpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.19.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-undici';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTkuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3ZlcnNpb24uanM/YWQ3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IGV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9ICcwLjE5LjAnO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSAnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\nvar undici_1 = __webpack_require__(/*! ./undici */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\");\nObject.defineProperty(exports, \"UndiciInstrumentation\", ({ enumerable: true, get: function () { return undici_1.UndiciInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyw2TEFBVTtBQUNqQyx5REFBd0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDMUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvaW5kZXguanM/ZTdkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbnZhciB1bmRpY2lfMSA9IHJlcXVpcmUoXCIuL3VuZGljaVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZGljaUluc3RydW1lbnRhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kaWNpXzEuVW5kaWNpSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst diagch = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.39.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\");\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass UndiciInstrumentation extends instrumentation_1.InstrumentationBase {\n    _recordFromReq = new WeakMap();\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    // No need to instrument files/modules\n    init() {\n        return undefined;\n    }\n    disable() {\n        super.disable();\n        this._channelSubs.forEach(sub => sub.unsubscribe());\n        this._channelSubs.length = 0;\n    }\n    enable() {\n        // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n        // If constructed with `{enabled: false}`, this `.enable()` is still called,\n        // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n        //\n        // For now, this class will setup for instrumenting if `.enable()` is\n        // called, but use `this.getConfig().enabled` to determine if\n        // instrumentation should be generated. This covers the more likely common\n        // case of config being given a construction time, rather than later via\n        // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n        super.enable();\n        // This method is called by the super-class constructor before ours is\n        // called. So we need to ensure the property is initalized.\n        this._channelSubs = this._channelSubs || [];\n        // Avoid to duplicate subscriptions\n        if (this._channelSubs.length > 0) {\n            return;\n        }\n        this.subscribeToChannel('undici:request:create', this.onRequestCreated.bind(this));\n        this.subscribeToChannel('undici:client:sendHeaders', this.onRequestHeaders.bind(this));\n        this.subscribeToChannel('undici:request:headers', this.onResponseHeaders.bind(this));\n        this.subscribeToChannel('undici:request:trailers', this.onDone.bind(this));\n        this.subscribeToChannel('undici:request:error', this.onError.bind(this));\n    }\n    _updateMetricInstruments() {\n        this._httpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        // `diagnostics_channel` had a ref counting bug until v18.19.0.\n        // https://github.com/nodejs/node/pull/47520\n        const [major, minor] = process.version\n            .replace('v', '')\n            .split('.')\n            .map(n => Number(n));\n        const useNewSubscribe = major > 18 || (major === 18 && minor >= 19);\n        let unsubscribe;\n        if (useNewSubscribe) {\n            diagch.subscribe?.(diagnosticChannel, onMessage);\n            unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n        }\n        else {\n            const channel = diagch.channel(diagnosticChannel);\n            channel.subscribe(onMessage);\n            unsubscribe = () => channel.unsubscribe(onMessage);\n        }\n        this._channelSubs.push({\n            name: diagnosticChannel,\n            unsubscribe,\n        });\n    }\n    parseRequestHeaders(request) {\n        const result = new Map();\n        if (Array.isArray(request.headers)) {\n            // headers are an array [k1, v2, k2, v2] (undici v6+)\n            // values could be string or a string[] for multiple values\n            for (let i = 0; i < request.headers.length; i += 2) {\n                const key = request.headers[i];\n                const value = request.headers[i + 1];\n                // Key should always be a string, but the types don't know that, and let's be safe\n                if (typeof key === 'string') {\n                    result.set(key.toLowerCase(), value);\n                }\n            }\n        }\n        else if (typeof request.headers === 'string') {\n            // headers are a raw string (undici v5)\n            // headers could be repeated in several lines for multiple values\n            const headers = request.headers.split('\\r\\n');\n            for (const line of headers) {\n                if (!line) {\n                    continue;\n                }\n                const colonIndex = line.indexOf(':');\n                if (colonIndex === -1) {\n                    // Invalid header? Probably this can't happen, but again let's be safe.\n                    continue;\n                }\n                const key = line.substring(0, colonIndex).toLowerCase();\n                const value = line.substring(colonIndex + 1).trim();\n                const allValues = result.get(key);\n                if (allValues && Array.isArray(allValues)) {\n                    allValues.push(value);\n                }\n                else if (allValues) {\n                    result.set(key, [allValues, value]);\n                }\n                else {\n                    result.set(key, value);\n                }\n            }\n        }\n        return result;\n    }\n    // This is the 1st message we receive for each request (fired after request creation). Here we will\n    // create the span and populate some atttributes, then link the span to the request for further\n    // span processing\n    onRequestCreated({ request }) {\n        // Ignore if:\n        // - instrumentation is disabled\n        // - ignored by config\n        // - method is 'CONNECT'\n        const config = this.getConfig();\n        const enabled = config.enabled !== false;\n        const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => !enabled ||\n            request.method === 'CONNECT' ||\n            config.ignoreRequestHook?.(request), e => e && this._diag.error('caught ignoreRequestHook error: ', e), true);\n        if (shouldIgnoreReq) {\n            return;\n        }\n        const startTime = (0, core_1.hrTime)();\n        let requestUrl;\n        try {\n            requestUrl = new url_1.URL(request.path, request.origin);\n        }\n        catch (err) {\n            this._diag.warn('could not determine url.full:', err);\n            // Skip instrumenting this request.\n            return;\n        }\n        const urlScheme = requestUrl.protocol.replace(':', '');\n        const requestMethod = this.getRequestMethod(request.method);\n        const attributes = {\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: requestMethod,\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL]: request.method,\n            [semantic_conventions_1.ATTR_URL_FULL]: requestUrl.toString(),\n            [semantic_conventions_1.ATTR_URL_PATH]: requestUrl.pathname,\n            [semantic_conventions_1.ATTR_URL_QUERY]: requestUrl.search,\n            [semantic_conventions_1.ATTR_URL_SCHEME]: urlScheme,\n        };\n        const schemePorts = { https: '443', http: '80' };\n        const serverAddress = requestUrl.hostname;\n        const serverPort = requestUrl.port || schemePorts[urlScheme];\n        attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS] = serverAddress;\n        if (serverPort && !isNaN(Number(serverPort))) {\n            attributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverPort);\n        }\n        // Get user agent from headers\n        const headersMap = this.parseRequestHeaders(request);\n        const userAgentValues = headersMap.get('user-agent');\n        if (userAgentValues) {\n            // NOTE: having multiple user agents is not expected so\n            // we're going to take last one like `curl` does\n            // ref: https://curl.se/docs/manpage.html#-A\n            const userAgent = Array.isArray(userAgentValues)\n                ? userAgentValues[userAgentValues.length - 1]\n                : userAgentValues;\n            attributes[semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL] = userAgent;\n        }\n        // Get attributes from the hook if present\n        const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.startSpanHook?.(request), e => e && this._diag.error('caught startSpanHook error: ', e), true);\n        if (hookAttributes) {\n            Object.entries(hookAttributes).forEach(([key, val]) => {\n                attributes[key] = val;\n            });\n        }\n        // Check if parent span is required via config and:\n        // - if a parent is required but not present, we use a `NoopSpan` to still\n        //   propagate context without recording it.\n        // - create a span otherwise\n        const activeCtx = api_1.context.active();\n        const currentSpan = api_1.trace.getSpan(activeCtx);\n        let span;\n        if (config.requireParentforSpans &&\n            (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else {\n            span = this.tracer.startSpan(requestMethod === '_OTHER' ? 'HTTP' : requestMethod, {\n                kind: api_1.SpanKind.CLIENT,\n                attributes: attributes,\n            }, activeCtx);\n        }\n        // Execute the request hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.requestHook?.(span, request), e => e && this._diag.error('caught requestHook error: ', e), true);\n        // Context propagation goes last so no hook can tamper\n        // the propagation headers\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        const headerEntries = Object.entries(addedHeaders);\n        for (let i = 0; i < headerEntries.length; i++) {\n            const [k, v] = headerEntries[i];\n            if (typeof request.addHeader === 'function') {\n                request.addHeader(k, v);\n            }\n            else if (typeof request.headers === 'string') {\n                request.headers += `${k}: ${v}\\r\\n`;\n            }\n            else if (Array.isArray(request.headers)) {\n                // undici@6.11.0 accidentally, briefly removed `request.addHeader()`.\n                request.headers.push(k, v);\n            }\n        }\n        this._recordFromReq.set(request, { span, attributes, startTime });\n    }\n    // This is the 2nd message we receive for each request. It is fired when connection with\n    // the remote is established and about to send the first byte. Here we do have info about the\n    // remote address and port so we can populate some `network.*` attributes into the span\n    onRequestHeaders({ request, socket }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const config = this.getConfig();\n        const { span } = record;\n        const { remoteAddress, remotePort } = socket;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: remoteAddress,\n            [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: remotePort,\n        };\n        // After hooks have been processed (which may modify request headers)\n        // we can collect the headers based on the configuration\n        if (config.headersToSpanAttributes?.requestHeaders) {\n            const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map(n => n.toLowerCase()));\n            const headersMap = this.parseRequestHeaders(request);\n            for (const [name, value] of headersMap.entries()) {\n                if (headersToAttribs.has(name)) {\n                    const attrValue = Array.isArray(value) ? value.join(', ') : value;\n                    spanAttributes[`http.request.header.${name}`] = attrValue;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n    }\n    // This is the 3rd message we get for each request and it's fired when the server\n    // headers are received, body may not be accessible yet.\n    // From the response headers we can set the status and content length\n    onResponseHeaders({ request, response, }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes } = record;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: response.statusCode,\n        };\n        const config = this.getConfig();\n        // Execute the response hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.responseHook?.(span, { request, response }), e => e && this._diag.error('caught responseHook error: ', e), true);\n        const headersToAttribs = new Set();\n        if (config.headersToSpanAttributes?.responseHeaders) {\n            config.headersToSpanAttributes?.responseHeaders.forEach(name => headersToAttribs.add(name.toLowerCase()));\n        }\n        for (let idx = 0; idx < response.headers.length; idx = idx + 2) {\n            const name = response.headers[idx].toString().toLowerCase();\n            const value = response.headers[idx + 1];\n            if (headersToAttribs.has(name)) {\n                spanAttributes[`http.response.header.${name}`] = value.toString();\n            }\n            if (name === 'content-length') {\n                const contentLength = Number(value.toString());\n                if (!isNaN(contentLength)) {\n                    spanAttributes['http.response.header.content-length'] = contentLength;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n        span.setStatus({\n            code: response.statusCode >= 400\n                ? api_1.SpanStatusCode.ERROR\n                : api_1.SpanStatusCode.UNSET,\n        });\n        record.attributes = Object.assign(attributes, spanAttributes);\n    }\n    // This is the last event we receive if the request went without any errors\n    onDone({ request }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // End the span\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics\n        this.recordRequestDuration(attributes, startTime);\n    }\n    // This is the event we get when something is wrong in the request like\n    // - invalid options when calling `fetch` global API or any undici method for request\n    // - connectivity errors such as unreachable host\n    // - requests aborted through an `AbortController.signal`\n    // NOTE: server errors are considered valid responses and it's the lib consumer\n    // who should deal with that.\n    onError({ request, error }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // NOTE: in `undici@6.3.0` when request aborted the error type changes from\n        // a custom error (`RequestAbortedError`) to a built-in `DOMException` carrying\n        // some differences:\n        // - `code` is from DOMEXception (ABORT_ERR: 20)\n        // - `message` changes\n        // - stacktrace is smaller and contains node internal frames\n        span.recordException(error);\n        span.setStatus({\n            code: api_1.SpanStatusCode.ERROR,\n            message: error.message,\n        });\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics (with the error)\n        attributes[semantic_conventions_1.ATTR_ERROR_TYPE] = error.message;\n        this.recordRequestDuration(attributes, startTime);\n    }\n    recordRequestDuration(attributes, startTime) {\n        // Time to record metrics\n        const metricsAttributes = {};\n        // Get the attribs already in span attributes\n        const keysToCopy = [\n            semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE,\n            semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD,\n            semantic_conventions_1.ATTR_SERVER_ADDRESS,\n            semantic_conventions_1.ATTR_SERVER_PORT,\n            semantic_conventions_1.ATTR_URL_SCHEME,\n            semantic_conventions_1.ATTR_ERROR_TYPE,\n        ];\n        keysToCopy.forEach(key => {\n            if (key in attributes) {\n                metricsAttributes[key] = attributes[key];\n            }\n        });\n        // Take the duration and record it\n        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;\n        this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);\n    }\n    getRequestMethod(original) {\n        const knownMethods = {\n            CONNECT: true,\n            OPTIONS: true,\n            HEAD: true,\n            GET: true,\n            POST: true,\n            PUT: true,\n            PATCH: true,\n            DELETE: true,\n            TRACE: true,\n        };\n        if (original.toUpperCase() in knownMethods) {\n            return original.toUpperCase();\n        }\n        return '_OTHER';\n    }\n}\nexports.UndiciInstrumentation = UndiciInstrumentation;\n//# sourceMappingURL=undici.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdW5kaWNpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0RBQXFCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyxxTUFBZ0M7QUFDbEUsY0FBYyxtQkFBTyxDQUFDLHNJQUFvQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsa0tBQXFCO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLDBMQUFxQztBQUM1RTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLCtMQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsSUFBSSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2QkFBNkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG1CQUFtQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdW5kaWNpLmpzPzQxYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBkaWFnY2ggPSByZXF1aXJlKFwiZGlhZ25vc3RpY3NfY2hhbm5lbFwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbi8qKiBAa25pcGlnbm9yZSAqL1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbi8vIEEgY29tYmluYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvYXBtLWFnZW50LW5vZGVqcyBhbmRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWRnZXQtaW5jL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9ucy9ibG9iL21haW4vcGFja2FnZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24tdW5kaWNpL3NyYy9pbmRleC50c1xuY2xhc3MgVW5kaWNpSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgX3JlY29yZEZyb21SZXEgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIGNvbmZpZyk7XG4gICAgfVxuICAgIC8vIE5vIG5lZWQgdG8gaW5zdHJ1bWVudCBmaWxlcy9tb2R1bGVzXG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLl9jaGFubmVsU3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMuX2NoYW5uZWxTdWJzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgLy8gXCJlbmFibGVkXCIgaGFuZGxpbmcgaXMgY3VycmVudGx5IGEgYml0IG1lc3N5IHdpdGggSW5zdHJ1bWVudGF0aW9uQmFzZS5cbiAgICAgICAgLy8gSWYgY29uc3RydWN0ZWQgd2l0aCBge2VuYWJsZWQ6IGZhbHNlfWAsIHRoaXMgYC5lbmFibGUoKWAgaXMgc3RpbGwgY2FsbGVkLFxuICAgICAgICAvLyBhbmQgYHRoaXMuZ2V0Q29uZmlnKCkuZW5hYmxlZCAhPT0gdGhpcy5pc0VuYWJsZWQoKWAsIGNyZWF0aW5nIGNvbmZ1c2lvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBjbGFzcyB3aWxsIHNldHVwIGZvciBpbnN0cnVtZW50aW5nIGlmIGAuZW5hYmxlKClgIGlzXG4gICAgICAgIC8vIGNhbGxlZCwgYnV0IHVzZSBgdGhpcy5nZXRDb25maWcoKS5lbmFibGVkYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgICAgLy8gaW5zdHJ1bWVudGF0aW9uIHNob3VsZCBiZSBnZW5lcmF0ZWQuIFRoaXMgY292ZXJzIHRoZSBtb3JlIGxpa2VseSBjb21tb25cbiAgICAgICAgLy8gY2FzZSBvZiBjb25maWcgYmVpbmcgZ2l2ZW4gYSBjb25zdHJ1Y3Rpb24gdGltZSwgcmF0aGVyIHRoYW4gbGF0ZXIgdmlhXG4gICAgICAgIC8vIGBpbnN0YW5jZS5lbmFibGUoKWAsIGAuZGlzYWJsZSgpYCwgb3IgYC5zZXRDb25maWcoKWAgY2FsbHMuXG4gICAgICAgIHN1cGVyLmVuYWJsZSgpO1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHN1cGVyLWNsYXNzIGNvbnN0cnVjdG9yIGJlZm9yZSBvdXJzIGlzXG4gICAgICAgIC8vIGNhbGxlZC4gU28gd2UgbmVlZCB0byBlbnN1cmUgdGhlIHByb3BlcnR5IGlzIGluaXRhbGl6ZWQuXG4gICAgICAgIHRoaXMuX2NoYW5uZWxTdWJzID0gdGhpcy5fY2hhbm5lbFN1YnMgfHwgW107XG4gICAgICAgIC8vIEF2b2lkIHRvIGR1cGxpY2F0ZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIGlmICh0aGlzLl9jaGFubmVsU3Vicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmNyZWF0ZScsIHRoaXMub25SZXF1ZXN0Q3JlYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnLCB0aGlzLm9uUmVxdWVzdEhlYWRlcnMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJywgdGhpcy5vblJlc3BvbnNlSGVhZGVycy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJywgdGhpcy5vbkRvbmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9odHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbShzZW1hbnRpY19jb252ZW50aW9uc18xLk1FVFJJQ19IVFRQX0NMSUVOVF9SRVFVRVNUX0RVUkFUSU9OLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01lYXN1cmVzIHRoZSBkdXJhdGlvbiBvZiBvdXRib3VuZCBIVFRQIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAncycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgICAgICBhZHZpY2U6IHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdEJ1Y2tldEJvdW5kYXJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSxcbiAgICAgICAgICAgICAgICAgICAgNy41LCAxMCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvQ2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCwgb25NZXNzYWdlKSB7XG4gICAgICAgIC8vIGBkaWFnbm9zdGljc19jaGFubmVsYCBoYWQgYSByZWYgY291bnRpbmcgYnVnIHVudGlsIHYxOC4xOS4wLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NzUyMFxuICAgICAgICBjb25zdCBbbWFqb3IsIG1pbm9yXSA9IHByb2Nlc3MudmVyc2lvblxuICAgICAgICAgICAgLnJlcGxhY2UoJ3YnLCAnJylcbiAgICAgICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgICAgICAubWFwKG4gPT4gTnVtYmVyKG4pKTtcbiAgICAgICAgY29uc3QgdXNlTmV3U3Vic2NyaWJlID0gbWFqb3IgPiAxOCB8fCAobWFqb3IgPT09IDE4ICYmIG1pbm9yID49IDE5KTtcbiAgICAgICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAodXNlTmV3U3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBkaWFnY2guc3Vic2NyaWJlPy4oZGlhZ25vc3RpY0NoYW5uZWwsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9ICgpID0+IGRpYWdjaC51bnN1YnNjcmliZT8uKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGRpYWdjaC5jaGFubmVsKGRpYWdub3N0aWNDaGFubmVsKTtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9ICgpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUob25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsU3Vicy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRpYWdub3N0aWNDaGFubmVsLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbiBhcnJheSBbazEsIHYyLCBrMiwgdjJdICh1bmRpY2kgdjYrKVxuICAgICAgICAgICAgLy8gdmFsdWVzIGNvdWxkIGJlIHN0cmluZyBvciBhIHN0cmluZ1tdIGZvciBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdC5oZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVxdWVzdC5oZWFkZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVxdWVzdC5oZWFkZXJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAvLyBLZXkgc2hvdWxkIGFsd2F5cyBiZSBhIHN0cmluZywgYnV0IHRoZSB0eXBlcyBkb24ndCBrbm93IHRoYXQsIGFuZCBsZXQncyBiZSBzYWZlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgYXJlIGEgcmF3IHN0cmluZyAodW5kaWNpIHY1KVxuICAgICAgICAgICAgLy8gaGVhZGVycyBjb3VsZCBiZSByZXBlYXRlZCBpbiBzZXZlcmFsIGxpbmVzIGZvciBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBoZWFkZXI/IFByb2JhYmx5IHRoaXMgY2FuJ3QgaGFwcGVuLCBidXQgYWdhaW4gbGV0J3MgYmUgc2FmZS5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IHJlc3VsdC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsVmFsdWVzICYmIEFycmF5LmlzQXJyYXkoYWxsVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgW2FsbFZhbHVlcywgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDFzdCBtZXNzYWdlIHdlIHJlY2VpdmUgZm9yIGVhY2ggcmVxdWVzdCAoZmlyZWQgYWZ0ZXIgcmVxdWVzdCBjcmVhdGlvbikuIEhlcmUgd2Ugd2lsbFxuICAgIC8vIGNyZWF0ZSB0aGUgc3BhbiBhbmQgcG9wdWxhdGUgc29tZSBhdHR0cmlidXRlcywgdGhlbiBsaW5rIHRoZSBzcGFuIHRvIHRoZSByZXF1ZXN0IGZvciBmdXJ0aGVyXG4gICAgLy8gc3BhbiBwcm9jZXNzaW5nXG4gICAgb25SZXF1ZXN0Q3JlYXRlZCh7IHJlcXVlc3QgfSkge1xuICAgICAgICAvLyBJZ25vcmUgaWY6XG4gICAgICAgIC8vIC0gaW5zdHJ1bWVudGF0aW9uIGlzIGRpc2FibGVkXG4gICAgICAgIC8vIC0gaWdub3JlZCBieSBjb25maWdcbiAgICAgICAgLy8gLSBtZXRob2QgaXMgJ0NPTk5FQ1QnXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSBjb25maWcuZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHNob3VsZElnbm9yZVJlcSA9ICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiAhZW5hYmxlZCB8fFxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJyB8fFxuICAgICAgICAgICAgY29uZmlnLmlnbm9yZVJlcXVlc3RIb29rPy4ocmVxdWVzdCksIGUgPT4gZSAmJiB0aGlzLl9kaWFnLmVycm9yKCdjYXVnaHQgaWdub3JlUmVxdWVzdEhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVJlcSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9ICgwLCBjb3JlXzEuaHJUaW1lKSgpO1xuICAgICAgICBsZXQgcmVxdWVzdFVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgPSBuZXcgdXJsXzEuVVJMKHJlcXVlc3QucGF0aCwgcmVxdWVzdC5vcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWcud2FybignY291bGQgbm90IGRldGVybWluZSB1cmwuZnVsbDonLCBlcnIpO1xuICAgICAgICAgICAgLy8gU2tpcCBpbnN0cnVtZW50aW5nIHRoaXMgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxTY2hlbWUgPSByZXF1ZXN0VXJsLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSB0aGlzLmdldFJlcXVlc3RNZXRob2QocmVxdWVzdC5tZXRob2QpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF9PUklHSU5BTF06IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfRlVMTF06IHJlcXVlc3RVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1BBVEhdOiByZXF1ZXN0VXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfUVVFUlldOiByZXF1ZXN0VXJsLnNlYXJjaCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV06IHVybFNjaGVtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2NoZW1lUG9ydHMgPSB7IGh0dHBzOiAnNDQzJywgaHR0cDogJzgwJyB9O1xuICAgICAgICBjb25zdCBzZXJ2ZXJBZGRyZXNzID0gcmVxdWVzdFVybC5ob3N0bmFtZTtcbiAgICAgICAgY29uc3Qgc2VydmVyUG9ydCA9IHJlcXVlc3RVcmwucG9ydCB8fCBzY2hlbWVQb3J0c1t1cmxTY2hlbWVdO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU10gPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICBpZiAoc2VydmVyUG9ydCAmJiAhaXNOYU4oTnVtYmVyKHNlcnZlclBvcnQpKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdID0gTnVtYmVyKHNlcnZlclBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB1c2VyIGFnZW50IGZyb20gaGVhZGVyc1xuICAgICAgICBjb25zdCBoZWFkZXJzTWFwID0gdGhpcy5wYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1c2VyQWdlbnRWYWx1ZXMgPSBoZWFkZXJzTWFwLmdldCgndXNlci1hZ2VudCcpO1xuICAgICAgICBpZiAodXNlckFnZW50VmFsdWVzKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBoYXZpbmcgbXVsdGlwbGUgdXNlciBhZ2VudHMgaXMgbm90IGV4cGVjdGVkIHNvXG4gICAgICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byB0YWtlIGxhc3Qgb25lIGxpa2UgYGN1cmxgIGRvZXNcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9jdXJsLnNlL2RvY3MvbWFucGFnZS5odG1sIy1BXG4gICAgICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSBBcnJheS5pc0FycmF5KHVzZXJBZ2VudFZhbHVlcylcbiAgICAgICAgICAgICAgICA/IHVzZXJBZ2VudFZhbHVlc1t1c2VyQWdlbnRWYWx1ZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICA6IHVzZXJBZ2VudFZhbHVlcztcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VTRVJfQUdFTlRfT1JJR0lOQUxdID0gdXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhdHRyaWJ1dGVzIGZyb20gdGhlIGhvb2sgaWYgcHJlc2VudFxuICAgICAgICBjb25zdCBob29rQXR0cmlidXRlcyA9ICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcuc3RhcnRTcGFuSG9vaz8uKHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHN0YXJ0U3Bhbkhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgaWYgKGhvb2tBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhob29rQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHBhcmVudCBzcGFuIGlzIHJlcXVpcmVkIHZpYSBjb25maWcgYW5kOlxuICAgICAgICAvLyAtIGlmIGEgcGFyZW50IGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJlc2VudCwgd2UgdXNlIGEgYE5vb3BTcGFuYCB0byBzdGlsbFxuICAgICAgICAvLyAgIHByb3BhZ2F0ZSBjb250ZXh0IHdpdGhvdXQgcmVjb3JkaW5nIGl0LlxuICAgICAgICAvLyAtIGNyZWF0ZSBhIHNwYW4gb3RoZXJ3aXNlXG4gICAgICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGFwaV8xLmNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gYXBpXzEudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgICAgICBsZXQgc3BhbjtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXF1aXJlUGFyZW50Zm9yU3BhbnMgJiZcbiAgICAgICAgICAgICghY3VycmVudFNwYW4gfHwgIWFwaV8xLnRyYWNlLmlzU3BhbkNvbnRleHRWYWxpZChjdXJyZW50U3Bhbi5zcGFuQ29udGV4dCgpKSkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBhcGlfMS50cmFjZS53cmFwU3BhbkNvbnRleHQoYXBpXzEuSU5WQUxJRF9TUEFOX0NPTlRFWFQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihyZXF1ZXN0TWV0aG9kID09PSAnX09USEVSJyA/ICdIVFRQJyA6IHJlcXVlc3RNZXRob2QsIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sIGFjdGl2ZUN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcmVxdWVzdCBob29rIGlmIGRlZmluZWRcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbmZpZy5yZXF1ZXN0SG9vaz8uKHNwYW4sIHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHJlcXVlc3RIb29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIC8vIENvbnRleHQgcHJvcGFnYXRpb24gZ29lcyBsYXN0IHNvIG5vIGhvb2sgY2FuIHRhbXBlclxuICAgICAgICAvLyB0aGUgcHJvcGFnYXRpb24gaGVhZGVyc1xuICAgICAgICBjb25zdCByZXF1ZXN0Q29udGV4dCA9IGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgc3Bhbik7XG4gICAgICAgIGNvbnN0IGFkZGVkSGVhZGVycyA9IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QocmVxdWVzdENvbnRleHQsIGFkZGVkSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGhlYWRlckVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhZGRlZEhlYWRlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlckVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtrLCB2XSA9IGhlYWRlckVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QuYWRkSGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRIZWFkZXIoaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBgJHtrfTogJHt2fVxcclxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmRpY2lANi4xMS4wIGFjY2lkZW50YWxseSwgYnJpZWZseSByZW1vdmVkIGByZXF1ZXN0LmFkZEhlYWRlcigpYC5cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWNvcmRGcm9tUmVxLnNldChyZXF1ZXN0LCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgMm5kIG1lc3NhZ2Ugd2UgcmVjZWl2ZSBmb3IgZWFjaCByZXF1ZXN0LiBJdCBpcyBmaXJlZCB3aGVuIGNvbm5lY3Rpb24gd2l0aFxuICAgIC8vIHRoZSByZW1vdGUgaXMgZXN0YWJsaXNoZWQgYW5kIGFib3V0IHRvIHNlbmQgdGhlIGZpcnN0IGJ5dGUuIEhlcmUgd2UgZG8gaGF2ZSBpbmZvIGFib3V0IHRoZVxuICAgIC8vIHJlbW90ZSBhZGRyZXNzIGFuZCBwb3J0IHNvIHdlIGNhbiBwb3B1bGF0ZSBzb21lIGBuZXR3b3JrLipgIGF0dHJpYnV0ZXMgaW50byB0aGUgc3BhblxuICAgIG9uUmVxdWVzdEhlYWRlcnMoeyByZXF1ZXN0LCBzb2NrZXQgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBjb25zdCB7IHNwYW4gfSA9IHJlY29yZDtcbiAgICAgICAgY29uc3QgeyByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSBzb2NrZXQ7XG4gICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfQUREUkVTU106IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXTogcmVtb3RlUG9ydCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWZ0ZXIgaG9va3MgaGF2ZSBiZWVuIHByb2Nlc3NlZCAod2hpY2ggbWF5IG1vZGlmeSByZXF1ZXN0IGhlYWRlcnMpXG4gICAgICAgIC8vIHdlIGNhbiBjb2xsZWN0IHRoZSBoZWFkZXJzIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICAgIGlmIChjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LnJlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzVG9BdHRyaWJzID0gbmV3IFNldChjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMucmVxdWVzdEhlYWRlcnMubWFwKG4gPT4gbi50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzTWFwID0gdGhpcy5wYXJzZVJlcXVlc3RIZWFkZXJzKHJlcXVlc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGhlYWRlcnNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNUb0F0dHJpYnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tgaHR0cC5yZXF1ZXN0LmhlYWRlci4ke25hbWV9YF0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhzcGFuQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDNyZCBtZXNzYWdlIHdlIGdldCBmb3IgZWFjaCByZXF1ZXN0IGFuZCBpdCdzIGZpcmVkIHdoZW4gdGhlIHNlcnZlclxuICAgIC8vIGhlYWRlcnMgYXJlIHJlY2VpdmVkLCBib2R5IG1heSBub3QgYmUgYWNjZXNzaWJsZSB5ZXQuXG4gICAgLy8gRnJvbSB0aGUgcmVzcG9uc2UgaGVhZGVycyB3ZSBjYW4gc2V0IHRoZSBzdGF0dXMgYW5kIGNvbnRlbnQgbGVuZ3RoXG4gICAgb25SZXNwb25zZUhlYWRlcnMoeyByZXF1ZXN0LCByZXNwb25zZSwgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMgfSA9IHJlY29yZDtcbiAgICAgICAgY29uc3Qgc3BhbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSByZXNwb25zZSBob29rIGlmIGRlZmluZWRcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbmZpZy5yZXNwb25zZUhvb2s/LihzcGFuLCB7IHJlcXVlc3QsIHJlc3BvbnNlIH0pLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IHJlc3BvbnNlSG9vayBlcnJvcjogJywgZSksIHRydWUpO1xuICAgICAgICBjb25zdCBoZWFkZXJzVG9BdHRyaWJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcz8ucmVzcG9uc2VIZWFkZXJzLmZvckVhY2gobmFtZSA9PiBoZWFkZXJzVG9BdHRyaWJzLmFkZChuYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCByZXNwb25zZS5oZWFkZXJzLmxlbmd0aDsgaWR4ID0gaWR4ICsgMikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHJlc3BvbnNlLmhlYWRlcnNbaWR4XS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNbaWR4ICsgMV07XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1RvQXR0cmlicy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tgaHR0cC5yZXNwb25zZS5oZWFkZXIuJHtuYW1lfWBdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IE51bWJlcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5BdHRyaWJ1dGVzWydodHRwLnJlc3BvbnNlLmhlYWRlci5jb250ZW50LWxlbmd0aCddID0gY29udGVudExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHNwYW5BdHRyaWJ1dGVzKTtcbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDBcbiAgICAgICAgICAgICAgICA/IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5VTlNFVCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBzcGFuQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgZXZlbnQgd2UgcmVjZWl2ZSBpZiB0aGUgcmVxdWVzdCB3ZW50IHdpdGhvdXQgYW55IGVycm9yc1xuICAgIG9uRG9uZSh7IHJlcXVlc3QgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9ID0gcmVjb3JkO1xuICAgICAgICAvLyBFbmQgdGhlIHNwYW5cbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzXG4gICAgICAgIHRoaXMucmVjb3JkUmVxdWVzdER1cmF0aW9uKGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGV2ZW50IHdlIGdldCB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZyBpbiB0aGUgcmVxdWVzdCBsaWtlXG4gICAgLy8gLSBpbnZhbGlkIG9wdGlvbnMgd2hlbiBjYWxsaW5nIGBmZXRjaGAgZ2xvYmFsIEFQSSBvciBhbnkgdW5kaWNpIG1ldGhvZCBmb3IgcmVxdWVzdFxuICAgIC8vIC0gY29ubmVjdGl2aXR5IGVycm9ycyBzdWNoIGFzIHVucmVhY2hhYmxlIGhvc3RcbiAgICAvLyAtIHJlcXVlc3RzIGFib3J0ZWQgdGhyb3VnaCBhbiBgQWJvcnRDb250cm9sbGVyLnNpZ25hbGBcbiAgICAvLyBOT1RFOiBzZXJ2ZXIgZXJyb3JzIGFyZSBjb25zaWRlcmVkIHZhbGlkIHJlc3BvbnNlcyBhbmQgaXQncyB0aGUgbGliIGNvbnN1bWVyXG4gICAgLy8gd2hvIHNob3VsZCBkZWFsIHdpdGggdGhhdC5cbiAgICBvbkVycm9yKHsgcmVxdWVzdCwgZXJyb3IgfSkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9yZWNvcmRGcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNwYW4sIGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSB9ID0gcmVjb3JkO1xuICAgICAgICAvLyBOT1RFOiBpbiBgdW5kaWNpQDYuMy4wYCB3aGVuIHJlcXVlc3QgYWJvcnRlZCB0aGUgZXJyb3IgdHlwZSBjaGFuZ2VzIGZyb21cbiAgICAgICAgLy8gYSBjdXN0b20gZXJyb3IgKGBSZXF1ZXN0QWJvcnRlZEVycm9yYCkgdG8gYSBidWlsdC1pbiBgRE9NRXhjZXB0aW9uYCBjYXJyeWluZ1xuICAgICAgICAvLyBzb21lIGRpZmZlcmVuY2VzOlxuICAgICAgICAvLyAtIGBjb2RlYCBpcyBmcm9tIERPTUVYY2VwdGlvbiAoQUJPUlRfRVJSOiAyMClcbiAgICAgICAgLy8gLSBgbWVzc2FnZWAgY2hhbmdlc1xuICAgICAgICAvLyAtIHN0YWNrdHJhY2UgaXMgc21hbGxlciBhbmQgY29udGFpbnMgbm9kZSBpbnRlcm5hbCBmcmFtZXNcbiAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB0aGlzLl9yZWNvcmRGcm9tUmVxLmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgLy8gUmVjb3JkIG1ldHJpY3MgKHdpdGggdGhlIGVycm9yKVxuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVjb3JkUmVxdWVzdER1cmF0aW9uKGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgfVxuICAgIHJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gVGltZSB0byByZWNvcmQgbWV0cmljc1xuICAgICAgICBjb25zdCBtZXRyaWNzQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAvLyBHZXQgdGhlIGF0dHJpYnMgYWxyZWFkeSBpbiBzcGFuIGF0dHJpYnV0ZXNcbiAgICAgICAgY29uc3Qga2V5c1RvQ29weSA9IFtcbiAgICAgICAgICAgIHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFLFxuICAgICAgICAgICAgc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0QsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1MsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlQsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRSxcbiAgICAgICAgICAgIHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLFxuICAgICAgICBdO1xuICAgICAgICBrZXlzVG9Db3B5LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3NBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUYWtlIHRoZSBkdXJhdGlvbiBhbmQgcmVjb3JkIGl0XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uU2Vjb25kcyA9ICgwLCBjb3JlXzEuaHJUaW1lVG9NaWxsaXNlY29uZHMpKCgwLCBjb3JlXzEuaHJUaW1lRHVyYXRpb24pKHN0YXJ0VGltZSwgKDAsIGNvcmVfMS5oclRpbWUpKCkpKSAvIDEwMDA7XG4gICAgICAgIHRoaXMuX2h0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25TZWNvbmRzLCBtZXRyaWNzQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RNZXRob2Qob3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qga25vd25NZXRob2RzID0ge1xuICAgICAgICAgICAgQ09OTkVDVDogdHJ1ZSxcbiAgICAgICAgICAgIE9QVElPTlM6IHRydWUsXG4gICAgICAgICAgICBIRUFEOiB0cnVlLFxuICAgICAgICAgICAgR0VUOiB0cnVlLFxuICAgICAgICAgICAgUE9TVDogdHJ1ZSxcbiAgICAgICAgICAgIFBVVDogdHJ1ZSxcbiAgICAgICAgICAgIFBBVENIOiB0cnVlLFxuICAgICAgICAgICAgREVMRVRFOiB0cnVlLFxuICAgICAgICAgICAgVFJBQ0U6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcmlnaW5hbC50b1VwcGVyQ2FzZSgpIGluIGtub3duTWV0aG9kcykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdfT1RIRVInO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5kaWNpSW5zdHJ1bWVudGF0aW9uID0gVW5kaWNpSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5kaWNpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.19.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-undici';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xOS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTkuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3ZlcnNpb24uanM/ZGYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IGV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9ICcwLjE5LjAnO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSAnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.19.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\n");

/***/ })

};
;