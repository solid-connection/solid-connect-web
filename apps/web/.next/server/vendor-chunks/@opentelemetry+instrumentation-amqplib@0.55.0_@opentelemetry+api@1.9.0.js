"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\");\nconst semconv_obsolete_1 = __webpack_require__(/*! ../src/semconv-obsolete */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['>=0.5.5 <1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    setConfig(config = {}) {\n        super.setConfig({ ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = {\n                        ...urlAttributes,\n                        ...serverAttributes,\n                    };\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails => msgDetails.msg === message);\n            if (msgIndex < 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {\n                for (let i = 0; i <= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() => {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = msg.properties.headers ?? {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = msg.fields?.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? api_1.trace.getSpan(parentContext)?.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: {\n                        ...channel?.connection?.[utils_1.CONNECTION_ATTRIBUTES],\n                        [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION]: exchange,\n                        [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION_KIND]: semconv_obsolete_1.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,\n                        [semconv_obsolete_1.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: msg.fields?.routingKey,\n                        [semconv_1.ATTR_MESSAGING_OPERATION]: semconv_obsolete_1.MESSAGING_OPERATION_VALUE_PROCESS,\n                        [semconv_obsolete_1.OLD_ATTR_MESSAGING_MESSAGE_ID]: msg?.properties.messageId,\n                        [semconv_obsolete_1.ATTR_MESSAGING_CONVERSATION_ID]: msg?.properties.correlationId,\n                    },\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!options?.noAck) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () => {\n                    onMessage.call(this, msg);\n                });\n                if (options?.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e => {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback?.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e => {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                ...channel.connection[utils_1.CONNECTION_ATTRIBUTES],\n                [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION]: exchange,\n                [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION_KIND]: semconv_obsolete_1.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,\n                [semconv_obsolete_1.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey,\n                [semconv_obsolete_1.OLD_ATTR_MESSAGING_MESSAGE_ID]: options?.messageId,\n                [semconv_obsolete_1.ATTR_MESSAGING_CONVERSATION_ID]: options?.correlationId,\n            },\n        });\n        const modifiedOptions = options ?? {};\n        modifiedOptions.headers = modifiedOptions.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &&\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        spansNotEnded.forEach(msgDetails => {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), e => {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i < spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxrS0FBcUI7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMscU1BQWdDO0FBQ2xFLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDLDJCQUEyQixtQkFBTyxDQUFDLHdOQUF5QjtBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyw2TEFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2TEFBUztBQUNqQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0EsNEZBQTRGLG9CQUFvQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRCx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsbUZBQW1GLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2FtcXBsaWIuanM/NmE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG5jb25zdCBzZW1jb252X29ic29sZXRlXzEgPSByZXF1aXJlKFwiLi4vc3JjL3NlbWNvbnYtb2Jzb2xldGVcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5jb25zdCBzdXBwb3J0ZWRWZXJzaW9ucyA9IFsnPj0wLjUuNSA8MSddO1xuY2xhc3MgQW1xcGxpYkluc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIHsgLi4udHlwZXNfMS5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0pO1xuICAgIH1cbiAgICBzZXRDb25maWcoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIuc2V0Q29uZmlnKHsgLi4udHlwZXNfMS5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0pO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBjaGFubmVsTW9kZWxNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jaGFubmVsX21vZGVsLmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRmlsZSgnYW1xcGxpYi9saWIvY2FsbGJhY2tfbW9kZWwuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jb25uZWN0LmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDb25uZWN0LmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignYW1xcGxpYicsIHN1cHBvcnRlZFZlcnNpb25zLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgW2NoYW5uZWxNb2RlbE1vZHVsZUZpbGUsIGNvbm5lY3RNb2R1bGVGaWxlLCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZV0pO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBwYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBtb2R1bGVFeHBvcnRzID0gdGhpcy51bnBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKTtcbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLmNvbm5lY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdjb25uZWN0JywgdGhpcy5nZXRDb25uZWN0UGF0Y2guYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHVucGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuY29ubmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICBwYXRjaENoYW5uZWxNb2RlbChtb2R1bGVFeHBvcnRzLCBtb2R1bGVWZXJzaW9uKSB7XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0UHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5jb25zdW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnY29uc3VtZScsIHRoaXMuZ2V0Q29uc3VtZVBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2snLCB0aGlzLmdldEFja1BhdGNoLmJpbmQodGhpcywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFjaycsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5OYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnJlamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJywgdGhpcy5nZXRBY2tBbGxQYXRjaC5iaW5kKHRoaXMsIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BY2tBbGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2tBbGwnLCB0aGlzLmdldEFja0FsbFBhdGNoLmJpbmQodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uTmFja0FsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5lbWl0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnZW1pdCcsIHRoaXMuZ2V0Q2hhbm5lbEVtaXRQYXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0Q29uZmlybWVkUHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICB1bnBhdGNoQ2hhbm5lbE1vZGVsKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmNvbnN1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2NvbnN1bWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2FjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5yZWplY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFja0FsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmVtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2VtaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgZ2V0Q29ubmVjdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaGVkQ29ubmVjdCh1cmwsIHNvY2tldE9wdGlvbnMsIG9wZW5DYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgdXJsLCBzb2NrZXRPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBjb25uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybEF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwpKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIpKGNvbm4pO1xuICAgICAgICAgICAgICAgICAgICBjb25uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVybEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zZXJ2ZXJBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGFubmVsRW1pdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW1pdChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVGltZXIgPSB0aGlzW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFjdGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja0FsbFBhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2tBbGwocmVxdWV1ZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlT3JFbXB0eSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0QWNrUGF0Y2goaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFjayhtZXNzYWdlLCBhbGxVcFRvT3JSZXF1ZXVlLCByZXF1ZXVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGlzIHBhdGNoIGluIHJlamVjdCBmdW5jdGlvbiBhcyB3ZWxsLCBidXQgaXQgaGFzIGRpZmZlcmVudCBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVldWVSZXNvbHZlZCA9IGVuZE9wZXJhdGlvbiA9PT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0ID8gYWxsVXBUb09yUmVxdWV1ZSA6IHJlcXVldWU7XG4gICAgICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA/PyBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1zZ0luZGV4ID0gc3BhbnNOb3RFbmRlZC5maW5kSW5kZXgobXNnRGV0YWlscyA9PiBtc2dEZXRhaWxzLm1zZyA9PT0gbWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAobXNnSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW4gaW4gaGFwcHkgZmxvd1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBwb3NzaWJsZSBpZiB1c2VyIGlzIGNhbGxpbmcgdGhlIGFwaSBmdW5jdGlvbiBhY2sgdHdpY2Ugd2l0aCBzYW1lIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBzZWxmLmVuZENvbnN1bWVyU3BhbihtZXNzYWdlLCBpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIHJlcXVldWVSZXNvbHZlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRPcGVyYXRpb24gIT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCAmJiBhbGxVcFRvT3JSZXF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbXNnSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZENvbnN1bWVyU3BhbihzcGFuc05vdEVuZGVkW2ldLm1zZywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZSgwLCBtc2dJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIHNwYW5zTm90RW5kZWQuc3BsaWNlKG1zZ0luZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb25zdW1lUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb25zdW1lKHF1ZXVlLCBvbk1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hhbm5lbCwgdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnN1bWVUaW1lb3V0TXMgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrQ29uc3VtZVRpbWVvdXRPbkNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbnN1bWVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdID0gdGltZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRPbk1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgLy8gbXNnIGlzIGV4cGVjdGVkIHRvIGJlIG51bGwgZm9yIHNpZ25hbGluZyBjb25zdW1lciBjYW5jZWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2NvbnN1bWVyLWNhbmNlbC5odG1sXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkbyBub3Qgc3RhcnQgYSBzcGFuLCBhcyB0aGlzIGlzIG5vdCBhIHJlYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25NZXNzYWdlLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IG1zZy5wcm9wZXJ0aWVzLmhlYWRlcnMgPz8ge307XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENvbnRleHQgPSBhcGlfMS5wcm9wYWdhdGlvbi5leHRyYWN0KGFwaV8xLlJPT1RfQ09OVEVYVCwgaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjaGFuZ2UgPSBtc2cuZmllbGRzPy5leGNoYW5nZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlua3M7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2NvbmZpZy51c2VMaW5rc0ZvckNvbnN1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U3BhbkNvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFwaV8xLnRyYWNlLmdldFNwYW4ocGFyZW50Q29udGV4dCk/LnNwYW5Db250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogcGFyZW50U3BhbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNlbGYudHJhY2VyLnN0YXJ0U3BhbihgJHtxdWV1ZX0gcHJvY2Vzc2AsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ09OU1VNRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoYW5uZWw/LmNvbm5lY3Rpb24/Llt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OXTogZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRdOiBzZW1jb252X29ic29sZXRlXzEuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogbXNnLmZpZWxkcz8ucm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OXTogc2VtY29udl9vYnNvbGV0ZV8xLk1FU1NBR0lOR19PUEVSQVRJT05fVkFMVUVfUFJPQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuT0xEX0FUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBtc2c/LnByb3BlcnRpZXMubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBtc2c/LnByb3BlcnRpZXMuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGlua3MsXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVIb29rKHNwYW4sIHsgbW9kdWxlVmVyc2lvbiwgbXNnIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvbnN1bWVySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zPy5ub0Fjaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbWVzc2FnZSBvbiB0aGUgY2hhbm5lbCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHNwYW4gb24gYWNrQWxsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9mQ29uc3VtZTogKDAsIGNvcmVfMS5oclRpbWUpKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc3BhbiBvbiB0aGUgbWVzc2FnZSwgc28gd2UgY2FuIGVuZCBpdCB3aGVuIHVzZXIgY2FsbCAnYWNrJyBvbiBpdFxuICAgICAgICAgICAgICAgICAgICBtc2dbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHNwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNldENvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICA6IGFwaV8xLlJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LndpdGgoYXBpXzEudHJhY2Uuc2V0U3BhbihzZXRDb250ZXh0LCBzcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5ub0Fjaykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGxDb25zdW1lRW5kSG9vayhzcGFuLCBtc2csIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BdXRvQWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJndW1lbnRzWzFdID0gcGF0Y2hlZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb25maXJtZWRQdWJsaXNoUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb25maXJtZWRQdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9ID0gc2VsZi5jcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hIb29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgaWYgKHB1Ymxpc2hIb29rKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hIb29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG1vZGlmaWVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0Y2hlZE9uQ29uZmlybSA9IGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s/LmNhbGwodGhpcywgZXJyLCBvayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hDb25maXJtSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hDb25maXJtSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hDb25maXJtSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1FcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoQ29uZmlybUhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlIGNvbmZpcm1hdGlvbiBoYXMgYmVlbiBuYWNrJ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjYWxsaW5nIGNvbmZpcm0gY2hhbm5lbCBwdWJsaXNoIGZ1bmN0aW9uIGlzIHN0b3JpbmcgdGhlIG1lc3NhZ2UgaW4gcXVldWUgYW5kIHJlZ2lzdGVyaW5nIHRoZSBjYWxsYmFjayBmb3IgYnJva2VyIGNvbmZpcm0uXG4gICAgICAgICAgICAvLyBzcGFuIGVuZHMgaW4gdGhlIHBhdGNoZWQgY2FsbGJhY2suXG4gICAgICAgICAgICBjb25zdCBtYXJrZWRDb250ZXh0ID0gKDAsIHV0aWxzXzEubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEuY29udGV4dC5hY3RpdmUoKSk7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNDb3B5ID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAgICAgICBhcmd1bWVudHNDb3B5WzNdID0gbW9kaWZpZWRPcHRpb25zO1xuICAgICAgICAgICAgYXJndW1lbnRzQ29weVs0XSA9IGFwaV8xLmNvbnRleHQuYmluZCgoMCwgdXRpbHNfMS51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLnRyYWNlLnNldFNwYW4obWFya2VkQ29udGV4dCwgc3BhbikpLCBwYXRjaGVkT25Db25maXJtKTtcbiAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgobWFya2VkQ29udGV4dCwgb3JpZ2luYWwuYmluZCh0aGlzLCAuLi5hcmd1bWVudHNDb3B5KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFB1Ymxpc2hQYXRjaChtb2R1bGVWZXJzaW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEuY29udGV4dC5hY3RpdmUoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3b3JrIGFscmVhZHkgZG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzcGFuLCBtb2RpZmllZE9wdGlvbnMgfSA9IHNlbGYuY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaEhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG1vZGlmaWVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2FsbGluZyBub3JtYWwgY2hhbm5lbCBwdWJsaXNoIGZ1bmN0aW9uIGlzIG9ubHkgc3RvcmluZyB0aGUgbWVzc2FnZSBpbiBxdWV1ZS5cbiAgICAgICAgICAgICAgICAvLyBpdCBkb2VzIG5vdCBzZW5kIGl0IGFuZCB3YWl0cyBmb3IgYW4gYWNrLCBzbyB0aGUgc3BhbiBkdXJhdGlvbiBpcyBleHBlY3RlZCB0byBiZSB2ZXJ5IHNob3J0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c0NvcHkgPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNDb3B5WzNdID0gbW9kaWZpZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzQ29weSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFeGNoYW5nZSA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZUV4Y2hhbmdlKShleGNoYW5nZSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYHB1Ymxpc2ggJHtub3JtYWxpemVkRXhjaGFuZ2V9YCwge1xuICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuUFJPRFVDRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uY2hhbm5lbC5jb25uZWN0aW9uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSxcbiAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OXTogZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EXTogc2VtY29udl9vYnNvbGV0ZV8xLk1FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EX1ZBTFVFX1RPUElDLFxuICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuT0xEX0FUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBvcHRpb25zPy5tZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBvcHRpb25zPy5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzID0gbW9kaWZpZWRPcHRpb25zLmhlYWRlcnMgPz8ge307XG4gICAgICAgIGFwaV8xLnByb3BhZ2F0aW9uLmluamVjdChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pLCBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHJldHVybiB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9O1xuICAgIH1cbiAgICBlbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZFNwYW4gPSBtZXNzYWdlW3V0aWxzXzEuTUVTU0FHRV9TVE9SRURfU1BBTl07XG4gICAgICAgIGlmICghc3RvcmVkU3BhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlzUmVqZWN0ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9yZWRTcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsQ2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiAhPT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gYCR7b3BlcmF0aW9ufSBjYWxsZWQgb24gbWVzc2FnZSR7cmVxdWV1ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnIHdpdGggcmVxdWV1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWV1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcgd2l0aG91dCByZXF1ZXVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9YFxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvbnN1bWVFbmRIb29rKHN0b3JlZFNwYW4sIG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbik7XG4gICAgICAgIHN0b3JlZFNwYW4uZW5kKCk7XG4gICAgICAgIG1lc3NhZ2VbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5kQWxsU3BhbnNPbkNoYW5uZWwoY2hhbm5lbCwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHNwYW5zTm90RW5kZWQgPSBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID8/IFtdO1xuICAgICAgICBzcGFuc05vdEVuZGVkLmZvckVhY2gobXNnRGV0YWlscyA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZENvbnN1bWVyU3Bhbihtc2dEZXRhaWxzLm1zZywgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPSBbXTtcbiAgICB9XG4gICAgY2FsbENvbnN1bWVFbmRIb29rKHNwYW4sIG1zZywgcmVqZWN0ZWQsIGVuZE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVFbmRIb29rIH0gPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBpZiAoIWNvbnN1bWVFbmRIb29rKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZUVuZEhvb2soc3BhbiwgeyBtc2csIHJlamVjdGVkLCBlbmRPcGVyYXRpb24gfSksIGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogY29uc3VtZXJFbmRIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBjaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgY29uc3Qgc3BhbnNOb3RFbmRlZCA9IGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPz8gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVUaW1lb3V0TXMgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFuc05vdEVuZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyTWVzc2FnZSA9IHNwYW5zTm90RW5kZWRbaV07XG4gICAgICAgICAgICBjb25zdCB0aW1lRnJvbUNvbnN1bWUgPSAoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShjdXJyTWVzc2FnZS50aW1lT2ZDb25zdW1lLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBpZiAoKDAsIGNvcmVfMS5oclRpbWVUb01pbGxpc2Vjb25kcykodGltZUZyb21Db25zdW1lKSA8IGNvbnN1bWVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5kQ29uc3VtZXJTcGFuKGN1cnJNZXNzYWdlLm1zZywgbnVsbCwgdHlwZXNfMS5FbmRPcGVyYXRpb24uSW5zdHJ1bWVudGF0aW9uVGltZW91dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgaSk7XG4gICAgfVxufVxuZXhwb3J0cy5BbXFwbGliSW5zdHJ1bWVudGF0aW9uID0gQW1xcGxpYkluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcXBsaWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndOperation = exports.DEFAULT_CONFIG = exports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar amqplib_1 = __webpack_require__(/*! ./amqplib */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\");\nObject.defineProperty(exports, \"AmqplibInstrumentation\", ({ enumerable: true, get: function () { return amqplib_1.AmqplibInstrumentation; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nObject.defineProperty(exports, \"DEFAULT_CONFIG\", ({ enumerable: true, get: function () { return types_1.DEFAULT_CONFIG; } }));\nObject.defineProperty(exports, \"EndOperation\", ({ enumerable: true, get: function () { return types_1.EndOperation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsaU1BQVc7QUFDbkMsMERBQXlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzdJLGNBQWMsbUJBQU8sQ0FBQyw2TEFBUztBQUMvQixrREFBaUQsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDM0gsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvaW5kZXguanM/YzQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5kT3BlcmF0aW9uID0gZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IGV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgYW1xcGxpYl8xID0gcmVxdWlyZShcIi4vYW1xcGxpYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFtcXBsaWJJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFtcXBsaWJfMS5BbXFwbGliSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfQ09ORklHXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkRFRkFVTFRfQ09ORklHOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kT3BlcmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkVuZE9wZXJhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js ***!
  \*****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ATTR_MESSAGING_CONVERSATION_ID = exports.OLD_ATTR_MESSAGING_MESSAGE_ID = exports.MESSAGING_DESTINATION_KIND_VALUE_TOPIC = exports.ATTR_MESSAGING_URL = exports.ATTR_MESSAGING_PROTOCOL_VERSION = exports.ATTR_MESSAGING_PROTOCOL = exports.MESSAGING_OPERATION_VALUE_PROCESS = exports.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY = exports.ATTR_MESSAGING_DESTINATION_KIND = exports.ATTR_MESSAGING_DESTINATION = void 0;\n/*\n * This file contains constants for values that where replaced/removed from\n * Semantic Conventions long enough ago that they do not have `ATTR_*`\n * constants in the `@opentelemetry/semantic-conventions` package. Eventually\n * it is expected that this instrumention will be updated to emit telemetry\n * using modern Semantic Conventions, dropping the need for the constants in\n * this file.\n */\n/**\n * The message destination name. This might be equal to the span name but is required nevertheless.\n *\n * @deprecated Use ATTR_MESSAGING_DESTINATION_NAME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_DESTINATION = 'messaging.destination';\n/**\n * The kind of message destination.\n *\n * @deprecated Removed in semconv v1.20.0.\n */\nexports.ATTR_MESSAGING_DESTINATION_KIND = 'messaging.destination_kind';\n/**\n * RabbitMQ message routing key.\n *\n * @deprecated Use ATTR_MESSAGING_RABBITMQ_DESTINATION_ROUTING_KEY in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY = 'messaging.rabbitmq.routing_key';\n/**\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n *\n * @deprecated Use MESSAGING_OPERATION_TYPE_VALUE_PROCESS in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.MESSAGING_OPERATION_VALUE_PROCESS = 'process';\n/**\n * The name of the transport protocol.\n *\n * @deprecated Use ATTR_NETWORK_PROTOCOL_NAME.\n */\nexports.ATTR_MESSAGING_PROTOCOL = 'messaging.protocol';\n/**\n * The version of the transport protocol.\n *\n * @deprecated Use ATTR_NETWORK_PROTOCOL_VERSION.\n */\nexports.ATTR_MESSAGING_PROTOCOL_VERSION = 'messaging.protocol_version';\n/**\n * Connection string.\n *\n * @deprecated Removed in semconv v1.17.0.\n */\nexports.ATTR_MESSAGING_URL = 'messaging.url';\n/**\n * The kind of message destination.\n *\n * @deprecated Removed in semconv v1.20.0.\n */\nexports.MESSAGING_DESTINATION_KIND_VALUE_TOPIC = 'topic';\n/**\n * A value used by the messaging system as an identifier for the message, represented as a string.\n *\n * @deprecated Use ATTR_MESSAGING_MESSAGE_ID in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n *\n * Note: changing to `ATTR_MESSAGING_MESSAGE_ID` means a change in value from `messaging.message_id` to `messaging.message.id`.\n */\nexports.OLD_ATTR_MESSAGING_MESSAGE_ID = 'messaging.message_id';\n/**\n * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.\n *\n * @deprecated Use ATTR_MESSAGING_MESSAGE_CONVERSATION_ID in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_CONVERSATION_ID = 'messaging.conversation_id';\n//# sourceMappingURL=semconv-obsolete.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9zZW1jb252LW9ic29sZXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxHQUFHLHFDQUFxQyxHQUFHLDhDQUE4QyxHQUFHLDBCQUEwQixHQUFHLHVDQUF1QyxHQUFHLCtCQUErQixHQUFHLHlDQUF5QyxHQUFHLDJDQUEyQyxHQUFHLHVDQUF1QyxHQUFHLGtDQUFrQztBQUNqWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1IQUFtSDtBQUNuTTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxtSEFBbUg7QUFDbk47QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxzSkFBc0osU0FBUztBQUMvSjtBQUNBLHVGQUF1RixtSEFBbUg7QUFDMU07QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsbUhBQW1IO0FBQzdMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLG1KQUFtSixtQkFBbUI7QUFDdEs7QUFDQSx1RkFBdUYsbUhBQW1IO0FBQzFNO0FBQ0Esc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvc2VtY29udi1vYnNvbGV0ZS5qcz8wNjhkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEID0gZXhwb3J0cy5PTERfQVRUUl9NRVNTQUdJTkdfTUVTU0FHRV9JRCA9IGV4cG9ydHMuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX1VSTCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0xfVkVSU0lPTiA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0wgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVkFMVUVfUFJPQ0VTUyA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVkgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkQgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OID0gdm9pZCAwO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBjb25zdGFudHMgZm9yIHZhbHVlcyB0aGF0IHdoZXJlIHJlcGxhY2VkL3JlbW92ZWQgZnJvbVxuICogU2VtYW50aWMgQ29udmVudGlvbnMgbG9uZyBlbm91Z2ggYWdvIHRoYXQgdGhleSBkbyBub3QgaGF2ZSBgQVRUUl8qYFxuICogY29uc3RhbnRzIGluIHRoZSBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgIHBhY2thZ2UuIEV2ZW50dWFsbHlcbiAqIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhpcyBpbnN0cnVtZW50aW9uIHdpbGwgYmUgdXBkYXRlZCB0byBlbWl0IHRlbGVtZXRyeVxuICogdXNpbmcgbW9kZXJuIFNlbWFudGljIENvbnZlbnRpb25zLCBkcm9wcGluZyB0aGUgbmVlZCBmb3IgdGhlIGNvbnN0YW50cyBpblxuICogdGhpcyBmaWxlLlxuICovXG4vKipcbiAqIFRoZSBtZXNzYWdlIGRlc3RpbmF0aW9uIG5hbWUuIFRoaXMgbWlnaHQgYmUgZXF1YWwgdG8gdGhlIHNwYW4gbmFtZSBidXQgaXMgcmVxdWlyZWQgbmV2ZXJ0aGVsZXNzLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBBVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FIGluIFtpbmN1YmF0aW5nIGVudHJ5LXBvaW50XSh7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvYmxvYi9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zL1JFQURNRS5tZCN1bnN0YWJsZS1zZW1jb252fSkuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT04gPSAnbWVzc2FnaW5nLmRlc3RpbmF0aW9uJztcbi8qKlxuICogVGhlIGtpbmQgb2YgbWVzc2FnZSBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHNlbWNvbnYgdjEuMjAuMC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbl9raW5kJztcbi8qKlxuICogUmFiYml0TVEgbWVzc2FnZSByb3V0aW5nIGtleS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfREVTVElOQVRJT05fUk9VVElOR19LRVkgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWSA9ICdtZXNzYWdpbmcucmFiYml0bXEucm91dGluZ19rZXknO1xuLyoqXG4gKiBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUga2luZCBvZiBtZXNzYWdlIGNvbnN1bXB0aW9uIGFzIGRlZmluZWQgaW4gdGhlIFtPcGVyYXRpb24gbmFtZXNdKCNvcGVyYXRpb24tbmFtZXMpIHNlY3Rpb24gYWJvdmUuIElmIHRoZSBvcGVyYXRpb24gaXMgJiMzNDtzZW5kJiMzNDssIHRoaXMgYXR0cmlidXRlIE1VU1QgTk9UIGJlIHNldCwgc2luY2UgdGhlIG9wZXJhdGlvbiBjYW4gYmUgaW5mZXJyZWQgZnJvbSB0aGUgc3BhbiBraW5kIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1BST0NFU1MgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1ZBTFVFX1BST0NFU1MgPSAncHJvY2Vzcyc7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSB0cmFuc3BvcnQgcHJvdG9jb2wuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIEFUVFJfTkVUV09SS19QUk9UT0NPTF9OQU1FLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MID0gJ21lc3NhZ2luZy5wcm90b2NvbCc7XG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSB0cmFuc3BvcnQgcHJvdG9jb2wuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIEFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04gPSAnbWVzc2FnaW5nLnByb3RvY29sX3ZlcnNpb24nO1xuLyoqXG4gKiBDb25uZWN0aW9uIHN0cmluZy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHNlbWNvbnYgdjEuMTcuMC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19VUkwgPSAnbWVzc2FnaW5nLnVybCc7XG4vKipcbiAqIFRoZSBraW5kIG9mIG1lc3NhZ2UgZGVzdGluYXRpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgUmVtb3ZlZCBpbiBzZW1jb252IHYxLjIwLjAuXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMgPSAndG9waWMnO1xuLyoqXG4gKiBBIHZhbHVlIHVzZWQgYnkgdGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgYW4gaWRlbnRpZmllciBmb3IgdGhlIG1lc3NhZ2UsIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBBVFRSX01FU1NBR0lOR19NRVNTQUdFX0lEIGluIFtpbmN1YmF0aW5nIGVudHJ5LXBvaW50XSh7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvYmxvYi9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zL1JFQURNRS5tZCN1bnN0YWJsZS1zZW1jb252fSkuXG4gKlxuICogTm90ZTogY2hhbmdpbmcgdG8gYEFUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURgIG1lYW5zIGEgY2hhbmdlIGluIHZhbHVlIGZyb20gYG1lc3NhZ2luZy5tZXNzYWdlX2lkYCB0byBgbWVzc2FnaW5nLm1lc3NhZ2UuaWRgLlxuICovXG5leHBvcnRzLk9MRF9BVFRSX01FU1NBR0lOR19NRVNTQUdFX0lEID0gJ21lc3NhZ2luZy5tZXNzYWdlX2lkJztcbi8qKlxuICogVGhlIFtjb252ZXJzYXRpb24gSURdKCNjb252ZXJzYXRpb25zKSBpZGVudGlmeWluZyB0aGUgY29udmVyc2F0aW9uIHRvIHdoaWNoIHRoZSBtZXNzYWdlIGJlbG9uZ3MsIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiBTb21ldGltZXMgY2FsbGVkICYjMzQ7Q29ycmVsYXRpb24gSUQmIzM0Oy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQVRUUl9NRVNTQUdJTkdfTUVTU0FHRV9DT05WRVJTQVRJT05fSUQgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSUQgPSAnbWVzc2FnaW5nLmNvbnZlcnNhdGlvbl9pZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LW9ic29sZXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ATTR_NET_PEER_PORT = exports.ATTR_NET_PEER_NAME = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * Deprecated, use `messaging.operation.type` instead.\n *\n * @example publish\n * @example create\n * @example process\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `messaging.operation.type`.\n */\nexports.ATTR_MESSAGING_OPERATION = 'messaging.operation';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Deprecated, use `server.address` on client spans and `client.address` on server spans.\n *\n * @example example.com\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `server.address` on client spans and `client.address` on server spans.\n */\nexports.ATTR_NET_PEER_NAME = 'net.peer.name';\n/**\n * Deprecated, use `server.port` on client spans and `client.port` on server spans.\n *\n * @example 8080\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `server.port` on client spans and `client.port` on server spans.\n */\nexports.ATTR_NET_PEER_PORT = 'net.peer.port';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDZCQUE2QixHQUFHLGdDQUFnQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvc2VtY29udi5qcz8yZTVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVRUUl9ORVRfUEVFUl9QT1JUID0gZXhwb3J0cy5BVFRSX05FVF9QRUVSX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX1NZU1RFTSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OID0gdm9pZCAwO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGNvcHkgb2YgdW5zdGFibGUgc2VtYW50aWMgY29udmVudGlvbiBkZWZpbml0aW9uc1xuICogdXNlZCBieSB0aGlzIHBhY2thZ2UuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWpzL3RyZWUvbWFpbi9zZW1hbnRpYy1jb252ZW50aW9ucyN1bnN0YWJsZS1zZW1jb252XG4gKi9cbi8qKlxuICogRGVwcmVjYXRlZCwgdXNlIGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgIGluc3RlYWQuXG4gKlxuICogQGV4YW1wbGUgcHVibGlzaFxuICogQGV4YW1wbGUgY3JlYXRlXG4gKiBAZXhhbXBsZSBwcm9jZXNzXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICpcbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTiA9ICdtZXNzYWdpbmcub3BlcmF0aW9uJztcbi8qKlxuICogVGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgaWRlbnRpZmllZCBieSB0aGUgY2xpZW50IGluc3RydW1lbnRhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGUgYWN0dWFsIG1lc3NhZ2luZyBzeXN0ZW0gbWF5IGRpZmZlciBmcm9tIHRoZSBvbmUga25vd24gYnkgdGhlIGNsaWVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgS2Fma2EgY2xpZW50IGxpYnJhcmllcyB0byBjb21tdW5pY2F0ZSB3aXRoIEF6dXJlIEV2ZW50IEh1YnMsIHRoZSBgbWVzc2FnaW5nLnN5c3RlbWAgaXMgc2V0IHRvIGBrYWZrYWAgYmFzZWQgb24gdGhlIGluc3RydW1lbnRhdGlvbidzIGJlc3Qga25vd2xlZGdlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSAnbWVzc2FnaW5nLnN5c3RlbSc7XG4vKipcbiAqIERlcHJlY2F0ZWQsIHVzZSBgc2VydmVyLmFkZHJlc3NgIG9uIGNsaWVudCBzcGFucyBhbmQgYGNsaWVudC5hZGRyZXNzYCBvbiBzZXJ2ZXIgc3BhbnMuXG4gKlxuICogQGV4YW1wbGUgZXhhbXBsZS5jb21cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKlxuICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgYnkgYHNlcnZlci5hZGRyZXNzYCBvbiBjbGllbnQgc3BhbnMgYW5kIGBjbGllbnQuYWRkcmVzc2Agb24gc2VydmVyIHNwYW5zLlxuICovXG5leHBvcnRzLkFUVFJfTkVUX1BFRVJfTkFNRSA9ICduZXQucGVlci5uYW1lJztcbi8qKlxuICogRGVwcmVjYXRlZCwgdXNlIGBzZXJ2ZXIucG9ydGAgb24gY2xpZW50IHNwYW5zIGFuZCBgY2xpZW50LnBvcnRgIG9uIHNlcnZlciBzcGFucy5cbiAqXG4gKiBAZXhhbXBsZSA4MDgwXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICpcbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IGBzZXJ2ZXIucG9ydGAgb24gY2xpZW50IHNwYW5zIGFuZCBgY2xpZW50LnBvcnRgIG9uIHNlcnZlciBzcGFucy5cbiAqL1xuZXhwb3J0cy5BVFRSX05FVF9QRUVSX1BPUlQgPSAnbmV0LnBlZXIucG9ydCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3R5cGVzLmpzPzg0YWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfQ09ORklHID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gPSB2b2lkIDA7XG52YXIgRW5kT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChFbmRPcGVyYXRpb24pIHtcbiAgICBFbmRPcGVyYXRpb25bXCJBdXRvQWNrXCJdID0gXCJhdXRvIGFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIkFja1wiXSA9IFwiYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQWNrQWxsXCJdID0gXCJhY2tBbGxcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJSZWplY3RcIl0gPSBcInJlamVjdFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIk5hY2tcIl0gPSBcIm5hY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJOYWNrQWxsXCJdID0gXCJuYWNrQWxsXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQ2hhbm5lbENsb3NlZFwiXSA9IFwiY2hhbm5lbCBjbG9zZWRcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJDaGFubmVsRXJyb3JcIl0gPSBcImNoYW5uZWwgZXJyb3JcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJJbnN0cnVtZW50YXRpb25UaW1lb3V0XCJdID0gXCJpbnN0cnVtZW50YXRpb24gdGltZW91dFwiO1xufSkoRW5kT3BlcmF0aW9uID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gfHwgKGV4cG9ydHMuRW5kT3BlcmF0aW9uID0ge30pKTtcbmV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSB7XG4gICAgY29uc3VtZVRpbWVvdXRNczogMTAwMCAqIDYwLFxuICAgIHVzZUxpbmtzRm9yQ29uc3VtZTogZmFsc2UsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\");\nconst semconv_obsolete_1 = __webpack_require__(/*! ../src/semconv-obsolete */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) => exchangeName !== '' ? exchangeName : '<default>';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) => {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) => {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) => {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -> 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) => {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) => {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) => {\n    const product = conn.serverProperties.product?.toLowerCase?.();\n    if (product) {\n        return {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) => {\n    const attributes = {\n        [semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions?.protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL, protocol, 'protocol'),\n        });\n        const hostname = getHostname(connectOptions?.hostname);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_1.ATTR_NET_PEER_NAME, hostname, 'hostname'),\n        });\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_1.ATTR_NET_PEER_PORT, port, 'port'),\n        });\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semconv_obsolete_1.ATTR_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL, protocol, 'protocol'),\n            });\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_1.ATTR_NET_PEER_NAME, hostname, 'hostname'),\n            });\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_1.ATTR_NET_PEER_PORT, port, 'port'),\n            });\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) => {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) => {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) => {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyx5Q0FBeUMsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRywyQkFBMkI7QUFDbFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNJQUFvQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxpTUFBVztBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyx3TkFBeUI7QUFDNUQsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0RkFBNEYsWUFBWTtBQUN4RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzPzVhMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBleHBvcnRzLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBleHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9IGV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyID0gZXhwb3J0cy5ub3JtYWxpemVFeGNoYW5nZSA9IGV4cG9ydHMuQ09OTkVDVElPTl9BVFRSSUJVVEVTID0gZXhwb3J0cy5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUiA9IGV4cG9ydHMuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQgPSBleHBvcnRzLk1FU1NBR0VfU1RPUkVEX1NQQU4gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3Qgc2VtY29udl8xID0gcmVxdWlyZShcIi4vc2VtY29udlwiKTtcbmNvbnN0IHNlbWNvbnZfb2Jzb2xldGVfMSA9IHJlcXVpcmUoXCIuLi9zcmMvc2VtY29udi1vYnNvbGV0ZVwiKTtcbmV4cG9ydHMuTUVTU0FHRV9TVE9SRURfU1BBTiA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLm1lc3NhZ2Uuc3RvcmVkLXNwYW4nKTtcbmV4cG9ydHMuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLnNwYW5zLW5vdC1lbmRlZCcpO1xuZXhwb3J0cy5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUiA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNoYW5uZWwuY29uc3VtZXItdGltZW91dC10aW1lcicpO1xuZXhwb3J0cy5DT05ORUNUSU9OX0FUVFJJQlVURVMgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jb25uZWN0aW9uLmF0dHJpYnV0ZXMnKTtcbmNvbnN0IElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSA9ICgwLCBhcGlfMS5jcmVhdGVDb250ZXh0S2V5KSgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNoYW5uZWwuaXMtY29uZmlybS1jaGFubmVsJyk7XG5jb25zdCBub3JtYWxpemVFeGNoYW5nZSA9IChleGNoYW5nZU5hbWUpID0+IGV4Y2hhbmdlTmFtZSAhPT0gJycgPyBleGNoYW5nZU5hbWUgOiAnPGRlZmF1bHQ+JztcbmV4cG9ydHMubm9ybWFsaXplRXhjaGFuZ2UgPSBub3JtYWxpemVFeGNoYW5nZTtcbmNvbnN0IGNlbnNvclBhc3N3b3JkID0gKHVybCkgPT4ge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvOlteOkAvXSpALywgJzoqKipAJyk7XG59O1xuY29uc3QgZ2V0UG9ydCA9IChwb3J0RnJvbVVybCwgcmVzb2x2ZWRQcm90b2NvbCkgPT4ge1xuICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgcmVzb2x2ZWQgcHJvdG9jb2wgd2hpY2ggaXMgdXBwZXIgY2FzZVxuICAgIC8vIHRoaXMgY29kZSBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgdGhlIGFtcXBsaWIgd2hpY2ggaXMgdXNlZCB0byBzZXQgY29ubmVjdGlvbiBwYXJhbXNcbiAgICByZXR1cm4gcG9ydEZyb21VcmwgfHwgKHJlc29sdmVkUHJvdG9jb2wgPT09ICdBTVFQJyA/IDU2NzIgOiA1NjcxKTtcbn07XG5jb25zdCBnZXRQcm90b2NvbCA9IChwcm90b2NvbEZyb21VcmwpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZFByb3RvY29sID0gcHJvdG9jb2xGcm9tVXJsIHx8ICdhbXFwJztcbiAgICAvLyB0aGUgc3Vic3RyaW5nIHJlbW92ZWQgdGhlICc6JyBwYXJ0IG9mIHRoZSBwcm90b2NvbCAoJ2FtcXA6JyAtPiAnYW1xcCcpXG4gICAgY29uc3Qgbm9FbmRpbmdDb2xvbiA9IHJlc29sdmVkUHJvdG9jb2wuZW5kc1dpdGgoJzonKVxuICAgICAgICA/IHJlc29sdmVkUHJvdG9jb2wuc3Vic3RyaW5nKDAsIHJlc29sdmVkUHJvdG9jb2wubGVuZ3RoIC0gMSlcbiAgICAgICAgOiByZXNvbHZlZFByb3RvY29sO1xuICAgIC8vIHVwcGVyIGNhc2VzIHRvIG1hdGNoIHNwZWNcbiAgICByZXR1cm4gbm9FbmRpbmdDb2xvbi50b1VwcGVyQ2FzZSgpO1xufTtcbmNvbnN0IGdldEhvc3RuYW1lID0gKGhvc3RuYW1lRnJvbVVybCkgPT4ge1xuICAgIC8vIGlmIHVzZXIgc3VwcGxpZXMgZW1wdHkgaG9zdG5hbWUsIGl0IGdldHMgZm9yd2FyZGVkIHRvICduZXQnIHBhY2thZ2Ugd2hpY2ggZGVmYXVsdCBpdCB0byBsb2NhbGhvc3QuXG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxMi54L2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcbiAgICByZXR1cm4gaG9zdG5hbWVGcm9tVXJsIHx8ICdsb2NhbGhvc3QnO1xufTtcbmNvbnN0IGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2cgPSAodXJsLCBhdHRyaWJ1dGVLZXksIGF0dHJpYnV0ZVZhbHVlLCBuYW1lRm9yTG9nKSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IFthdHRyaWJ1dGVLZXldOiBhdHRyaWJ1dGVWYWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBpXzEuZGlhZy5lcnJvcihgYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvdWxkIG5vdCBleHRyYWN0IGNvbm5lY3Rpb24gYXR0cmlidXRlICR7bmFtZUZvckxvZ30gZnJvbSB1c2VyIHN1cHBsaWVkIHVybGAsIHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyID0gKGNvbm4pID0+IHtcbiAgICBjb25zdCBwcm9kdWN0ID0gY29ubi5zZXJ2ZXJQcm9wZXJ0aWVzLnByb2R1Y3Q/LnRvTG93ZXJDYXNlPy4oKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBwcm9kdWN0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5leHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlcjtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT05dOiAnMC45LjEnLCAvLyB0aGlzIGlzIHRoZSBvbmx5IHByb3RvY29sIHN1cHBvcnRlZCBieSB0aGUgaW5zdHJ1bWVudGVkIGxpYnJhcnlcbiAgICB9O1xuICAgIHVybCA9IHVybCB8fCAnYW1xcDovL2xvY2FsaG9zdCc7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RPcHRpb25zID0gdXJsO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKGNvbm5lY3RPcHRpb25zPy5wcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19QUk9UT0NPTCwgcHJvdG9jb2wsICdwcm90b2NvbCcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZShjb25uZWN0T3B0aW9ucz8uaG9zdG5hbWUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIC4uLmV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1jb252XzEuQVRUUl9ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydChjb25uZWN0T3B0aW9ucy5wb3J0LCBwcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWNvbnZfMS5BVFRSX05FVF9QRUVSX1BPUlQsIHBvcnQsICdwb3J0JyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY2Vuc29yZWRVcmwgPSBjZW5zb3JQYXNzd29yZCh1cmwpO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19VUkxdID0gY2Vuc29yZWRVcmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoY2Vuc29yZWRVcmwpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBnZXRQcm90b2NvbCh1cmxQYXJ0cy5wcm90b2NvbCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1jb252X29ic29sZXRlXzEuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZSh1cmxQYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1jb252XzEuQVRUUl9ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBnZXRQb3J0KHVybFBhcnRzLnBvcnQgPyBwYXJzZUludCh1cmxQYXJ0cy5wb3J0KSA6IHVuZGVmaW5lZCwgcHJvdG9jb2wpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtY29udl8xLkFUVFJfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBlcnJvciB3aGlsZSBleHRyYWN0aW5nIGNvbm5lY3Rpb24gZGV0YWlscyBmcm9tIGNvbm5lY3Rpb24gdXJsJywge1xuICAgICAgICAgICAgICAgIGNlbnNvcmVkVXJsLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsID0gZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsO1xuY29uc3QgbWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZLCB0cnVlKTtcbn07XG5leHBvcnRzLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBtYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5kZWxldGVWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkpO1xufTtcbmV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LmdldFZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSkgPT09IHRydWU7XG59O1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGlzQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.55.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy92ZXJzaW9uLmpzPzhiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC41NS4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\");\nconst semconv_obsolete_1 = __webpack_require__(/*! ../src/semconv-obsolete */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['>=0.5.5 <1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    setConfig(config = {}) {\n        super.setConfig({ ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = {\n                        ...urlAttributes,\n                        ...serverAttributes,\n                    };\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails => msgDetails.msg === message);\n            if (msgIndex < 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {\n                for (let i = 0; i <= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() => {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = msg.properties.headers ?? {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = msg.fields?.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? api_1.trace.getSpan(parentContext)?.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: {\n                        ...channel?.connection?.[utils_1.CONNECTION_ATTRIBUTES],\n                        [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION]: exchange,\n                        [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION_KIND]: semconv_obsolete_1.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,\n                        [semconv_obsolete_1.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: msg.fields?.routingKey,\n                        [semconv_1.ATTR_MESSAGING_OPERATION]: semconv_obsolete_1.MESSAGING_OPERATION_VALUE_PROCESS,\n                        [semconv_obsolete_1.OLD_ATTR_MESSAGING_MESSAGE_ID]: msg?.properties.messageId,\n                        [semconv_obsolete_1.ATTR_MESSAGING_CONVERSATION_ID]: msg?.properties.correlationId,\n                    },\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!options?.noAck) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () => {\n                    onMessage.call(this, msg);\n                });\n                if (options?.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e => {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback?.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e => {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                ...channel.connection[utils_1.CONNECTION_ATTRIBUTES],\n                [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION]: exchange,\n                [semconv_obsolete_1.ATTR_MESSAGING_DESTINATION_KIND]: semconv_obsolete_1.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,\n                [semconv_obsolete_1.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey,\n                [semconv_obsolete_1.OLD_ATTR_MESSAGING_MESSAGE_ID]: options?.messageId,\n                [semconv_obsolete_1.ATTR_MESSAGING_CONVERSATION_ID]: options?.correlationId,\n            },\n        });\n        const modifiedOptions = options ?? {};\n        modifiedOptions.headers = modifiedOptions.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &&\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        spansNotEnded.forEach(msgDetails => {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), e => {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i < spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxrS0FBcUI7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMscU1BQWdDO0FBQ2xFLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDLDJCQUEyQixtQkFBTyxDQUFDLHdOQUF5QjtBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyw2TEFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2TEFBUztBQUNqQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0EsNEZBQTRGLG9CQUFvQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRCx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsbUZBQW1GLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2FtcXBsaWIuanM/MDA2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG5jb25zdCBzZW1jb252X29ic29sZXRlXzEgPSByZXF1aXJlKFwiLi4vc3JjL3NlbWNvbnYtb2Jzb2xldGVcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5jb25zdCBzdXBwb3J0ZWRWZXJzaW9ucyA9IFsnPj0wLjUuNSA8MSddO1xuY2xhc3MgQW1xcGxpYkluc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIHsgLi4udHlwZXNfMS5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0pO1xuICAgIH1cbiAgICBzZXRDb25maWcoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIuc2V0Q29uZmlnKHsgLi4udHlwZXNfMS5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0pO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBjaGFubmVsTW9kZWxNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jaGFubmVsX21vZGVsLmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRmlsZSgnYW1xcGxpYi9saWIvY2FsbGJhY2tfbW9kZWwuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jb25uZWN0LmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDb25uZWN0LmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignYW1xcGxpYicsIHN1cHBvcnRlZFZlcnNpb25zLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgW2NoYW5uZWxNb2RlbE1vZHVsZUZpbGUsIGNvbm5lY3RNb2R1bGVGaWxlLCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZV0pO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBwYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBtb2R1bGVFeHBvcnRzID0gdGhpcy51bnBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKTtcbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLmNvbm5lY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdjb25uZWN0JywgdGhpcy5nZXRDb25uZWN0UGF0Y2guYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHVucGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuY29ubmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICBwYXRjaENoYW5uZWxNb2RlbChtb2R1bGVFeHBvcnRzLCBtb2R1bGVWZXJzaW9uKSB7XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0UHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5jb25zdW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnY29uc3VtZScsIHRoaXMuZ2V0Q29uc3VtZVBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2snLCB0aGlzLmdldEFja1BhdGNoLmJpbmQodGhpcywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFjaycsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5OYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnJlamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJywgdGhpcy5nZXRBY2tBbGxQYXRjaC5iaW5kKHRoaXMsIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BY2tBbGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2tBbGwnLCB0aGlzLmdldEFja0FsbFBhdGNoLmJpbmQodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uTmFja0FsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5lbWl0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnZW1pdCcsIHRoaXMuZ2V0Q2hhbm5lbEVtaXRQYXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0Q29uZmlybWVkUHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICB1bnBhdGNoQ2hhbm5lbE1vZGVsKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmNvbnN1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2NvbnN1bWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2FjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5yZWplY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFja0FsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmVtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2VtaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgZ2V0Q29ubmVjdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaGVkQ29ubmVjdCh1cmwsIHNvY2tldE9wdGlvbnMsIG9wZW5DYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgdXJsLCBzb2NrZXRPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBjb25uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybEF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwpKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIpKGNvbm4pO1xuICAgICAgICAgICAgICAgICAgICBjb25uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVybEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zZXJ2ZXJBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGFubmVsRW1pdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW1pdChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVGltZXIgPSB0aGlzW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFjdGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja0FsbFBhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2tBbGwocmVxdWV1ZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlT3JFbXB0eSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0QWNrUGF0Y2goaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFjayhtZXNzYWdlLCBhbGxVcFRvT3JSZXF1ZXVlLCByZXF1ZXVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGlzIHBhdGNoIGluIHJlamVjdCBmdW5jdGlvbiBhcyB3ZWxsLCBidXQgaXQgaGFzIGRpZmZlcmVudCBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVldWVSZXNvbHZlZCA9IGVuZE9wZXJhdGlvbiA9PT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0ID8gYWxsVXBUb09yUmVxdWV1ZSA6IHJlcXVldWU7XG4gICAgICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA/PyBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1zZ0luZGV4ID0gc3BhbnNOb3RFbmRlZC5maW5kSW5kZXgobXNnRGV0YWlscyA9PiBtc2dEZXRhaWxzLm1zZyA9PT0gbWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAobXNnSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW4gaW4gaGFwcHkgZmxvd1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBwb3NzaWJsZSBpZiB1c2VyIGlzIGNhbGxpbmcgdGhlIGFwaSBmdW5jdGlvbiBhY2sgdHdpY2Ugd2l0aCBzYW1lIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBzZWxmLmVuZENvbnN1bWVyU3BhbihtZXNzYWdlLCBpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIHJlcXVldWVSZXNvbHZlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRPcGVyYXRpb24gIT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCAmJiBhbGxVcFRvT3JSZXF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbXNnSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZENvbnN1bWVyU3BhbihzcGFuc05vdEVuZGVkW2ldLm1zZywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZSgwLCBtc2dJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIHNwYW5zTm90RW5kZWQuc3BsaWNlKG1zZ0luZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb25zdW1lUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb25zdW1lKHF1ZXVlLCBvbk1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hhbm5lbCwgdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnN1bWVUaW1lb3V0TXMgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrQ29uc3VtZVRpbWVvdXRPbkNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbnN1bWVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdID0gdGltZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRPbk1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgLy8gbXNnIGlzIGV4cGVjdGVkIHRvIGJlIG51bGwgZm9yIHNpZ25hbGluZyBjb25zdW1lciBjYW5jZWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2NvbnN1bWVyLWNhbmNlbC5odG1sXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkbyBub3Qgc3RhcnQgYSBzcGFuLCBhcyB0aGlzIGlzIG5vdCBhIHJlYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25NZXNzYWdlLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IG1zZy5wcm9wZXJ0aWVzLmhlYWRlcnMgPz8ge307XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENvbnRleHQgPSBhcGlfMS5wcm9wYWdhdGlvbi5leHRyYWN0KGFwaV8xLlJPT1RfQ09OVEVYVCwgaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjaGFuZ2UgPSBtc2cuZmllbGRzPy5leGNoYW5nZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlua3M7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2NvbmZpZy51c2VMaW5rc0ZvckNvbnN1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U3BhbkNvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFwaV8xLnRyYWNlLmdldFNwYW4ocGFyZW50Q29udGV4dCk/LnNwYW5Db250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogcGFyZW50U3BhbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNlbGYudHJhY2VyLnN0YXJ0U3BhbihgJHtxdWV1ZX0gcHJvY2Vzc2AsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ09OU1VNRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoYW5uZWw/LmNvbm5lY3Rpb24/Llt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OXTogZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRdOiBzZW1jb252X29ic29sZXRlXzEuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogbXNnLmZpZWxkcz8ucm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OXTogc2VtY29udl9vYnNvbGV0ZV8xLk1FU1NBR0lOR19PUEVSQVRJT05fVkFMVUVfUFJPQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuT0xEX0FUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBtc2c/LnByb3BlcnRpZXMubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBtc2c/LnByb3BlcnRpZXMuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGlua3MsXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVIb29rKHNwYW4sIHsgbW9kdWxlVmVyc2lvbiwgbXNnIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvbnN1bWVySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zPy5ub0Fjaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbWVzc2FnZSBvbiB0aGUgY2hhbm5lbCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHNwYW4gb24gYWNrQWxsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9mQ29uc3VtZTogKDAsIGNvcmVfMS5oclRpbWUpKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc3BhbiBvbiB0aGUgbWVzc2FnZSwgc28gd2UgY2FuIGVuZCBpdCB3aGVuIHVzZXIgY2FsbCAnYWNrJyBvbiBpdFxuICAgICAgICAgICAgICAgICAgICBtc2dbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHNwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNldENvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICA6IGFwaV8xLlJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LndpdGgoYXBpXzEudHJhY2Uuc2V0U3BhbihzZXRDb250ZXh0LCBzcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5ub0Fjaykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGxDb25zdW1lRW5kSG9vayhzcGFuLCBtc2csIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BdXRvQWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJndW1lbnRzWzFdID0gcGF0Y2hlZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb25maXJtZWRQdWJsaXNoUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb25maXJtZWRQdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9ID0gc2VsZi5jcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hIb29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgaWYgKHB1Ymxpc2hIb29rKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hIb29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG1vZGlmaWVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0Y2hlZE9uQ29uZmlybSA9IGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s/LmNhbGwodGhpcywgZXJyLCBvayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hDb25maXJtSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hDb25maXJtSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hDb25maXJtSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1FcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoQ29uZmlybUhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlIGNvbmZpcm1hdGlvbiBoYXMgYmVlbiBuYWNrJ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjYWxsaW5nIGNvbmZpcm0gY2hhbm5lbCBwdWJsaXNoIGZ1bmN0aW9uIGlzIHN0b3JpbmcgdGhlIG1lc3NhZ2UgaW4gcXVldWUgYW5kIHJlZ2lzdGVyaW5nIHRoZSBjYWxsYmFjayBmb3IgYnJva2VyIGNvbmZpcm0uXG4gICAgICAgICAgICAvLyBzcGFuIGVuZHMgaW4gdGhlIHBhdGNoZWQgY2FsbGJhY2suXG4gICAgICAgICAgICBjb25zdCBtYXJrZWRDb250ZXh0ID0gKDAsIHV0aWxzXzEubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEuY29udGV4dC5hY3RpdmUoKSk7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNDb3B5ID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAgICAgICBhcmd1bWVudHNDb3B5WzNdID0gbW9kaWZpZWRPcHRpb25zO1xuICAgICAgICAgICAgYXJndW1lbnRzQ29weVs0XSA9IGFwaV8xLmNvbnRleHQuYmluZCgoMCwgdXRpbHNfMS51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLnRyYWNlLnNldFNwYW4obWFya2VkQ29udGV4dCwgc3BhbikpLCBwYXRjaGVkT25Db25maXJtKTtcbiAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgobWFya2VkQ29udGV4dCwgb3JpZ2luYWwuYmluZCh0aGlzLCAuLi5hcmd1bWVudHNDb3B5KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFB1Ymxpc2hQYXRjaChtb2R1bGVWZXJzaW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEuY29udGV4dC5hY3RpdmUoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3b3JrIGFscmVhZHkgZG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzcGFuLCBtb2RpZmllZE9wdGlvbnMgfSA9IHNlbGYuY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaEhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG1vZGlmaWVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2FsbGluZyBub3JtYWwgY2hhbm5lbCBwdWJsaXNoIGZ1bmN0aW9uIGlzIG9ubHkgc3RvcmluZyB0aGUgbWVzc2FnZSBpbiBxdWV1ZS5cbiAgICAgICAgICAgICAgICAvLyBpdCBkb2VzIG5vdCBzZW5kIGl0IGFuZCB3YWl0cyBmb3IgYW4gYWNrLCBzbyB0aGUgc3BhbiBkdXJhdGlvbiBpcyBleHBlY3RlZCB0byBiZSB2ZXJ5IHNob3J0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c0NvcHkgPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNDb3B5WzNdID0gbW9kaWZpZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzQ29weSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFeGNoYW5nZSA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZUV4Y2hhbmdlKShleGNoYW5nZSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYHB1Ymxpc2ggJHtub3JtYWxpemVkRXhjaGFuZ2V9YCwge1xuICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuUFJPRFVDRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uY2hhbm5lbC5jb25uZWN0aW9uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSxcbiAgICAgICAgICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OXTogZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EXTogc2VtY29udl9vYnNvbGV0ZV8xLk1FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EX1ZBTFVFX1RPUElDLFxuICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgIFtzZW1jb252X29ic29sZXRlXzEuT0xEX0FUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBvcHRpb25zPy5tZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBvcHRpb25zPy5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzID0gbW9kaWZpZWRPcHRpb25zLmhlYWRlcnMgPz8ge307XG4gICAgICAgIGFwaV8xLnByb3BhZ2F0aW9uLmluamVjdChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pLCBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHJldHVybiB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9O1xuICAgIH1cbiAgICBlbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZFNwYW4gPSBtZXNzYWdlW3V0aWxzXzEuTUVTU0FHRV9TVE9SRURfU1BBTl07XG4gICAgICAgIGlmICghc3RvcmVkU3BhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlzUmVqZWN0ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9yZWRTcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsQ2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiAhPT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gYCR7b3BlcmF0aW9ufSBjYWxsZWQgb24gbWVzc2FnZSR7cmVxdWV1ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnIHdpdGggcmVxdWV1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWV1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcgd2l0aG91dCByZXF1ZXVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9YFxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvbnN1bWVFbmRIb29rKHN0b3JlZFNwYW4sIG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbik7XG4gICAgICAgIHN0b3JlZFNwYW4uZW5kKCk7XG4gICAgICAgIG1lc3NhZ2VbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5kQWxsU3BhbnNPbkNoYW5uZWwoY2hhbm5lbCwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHNwYW5zTm90RW5kZWQgPSBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID8/IFtdO1xuICAgICAgICBzcGFuc05vdEVuZGVkLmZvckVhY2gobXNnRGV0YWlscyA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZENvbnN1bWVyU3Bhbihtc2dEZXRhaWxzLm1zZywgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPSBbXTtcbiAgICB9XG4gICAgY2FsbENvbnN1bWVFbmRIb29rKHNwYW4sIG1zZywgcmVqZWN0ZWQsIGVuZE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVFbmRIb29rIH0gPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBpZiAoIWNvbnN1bWVFbmRIb29rKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZUVuZEhvb2soc3BhbiwgeyBtc2csIHJlamVjdGVkLCBlbmRPcGVyYXRpb24gfSksIGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogY29uc3VtZXJFbmRIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBjaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgY29uc3Qgc3BhbnNOb3RFbmRlZCA9IGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPz8gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVUaW1lb3V0TXMgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFuc05vdEVuZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyTWVzc2FnZSA9IHNwYW5zTm90RW5kZWRbaV07XG4gICAgICAgICAgICBjb25zdCB0aW1lRnJvbUNvbnN1bWUgPSAoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShjdXJyTWVzc2FnZS50aW1lT2ZDb25zdW1lLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBpZiAoKDAsIGNvcmVfMS5oclRpbWVUb01pbGxpc2Vjb25kcykodGltZUZyb21Db25zdW1lKSA8IGNvbnN1bWVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5kQ29uc3VtZXJTcGFuKGN1cnJNZXNzYWdlLm1zZywgbnVsbCwgdHlwZXNfMS5FbmRPcGVyYXRpb24uSW5zdHJ1bWVudGF0aW9uVGltZW91dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgaSk7XG4gICAgfVxufVxuZXhwb3J0cy5BbXFwbGliSW5zdHJ1bWVudGF0aW9uID0gQW1xcGxpYkluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcXBsaWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndOperation = exports.DEFAULT_CONFIG = exports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar amqplib_1 = __webpack_require__(/*! ./amqplib */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\");\nObject.defineProperty(exports, \"AmqplibInstrumentation\", ({ enumerable: true, get: function () { return amqplib_1.AmqplibInstrumentation; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nObject.defineProperty(exports, \"DEFAULT_CONFIG\", ({ enumerable: true, get: function () { return types_1.DEFAULT_CONFIG; } }));\nObject.defineProperty(exports, \"EndOperation\", ({ enumerable: true, get: function () { return types_1.EndOperation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsaU1BQVc7QUFDbkMsMERBQXlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzdJLGNBQWMsbUJBQU8sQ0FBQyw2TEFBUztBQUMvQixrREFBaUQsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDM0gsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvaW5kZXguanM/NTRiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5kT3BlcmF0aW9uID0gZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IGV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgYW1xcGxpYl8xID0gcmVxdWlyZShcIi4vYW1xcGxpYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFtcXBsaWJJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFtcXBsaWJfMS5BbXFwbGliSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfQ09ORklHXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkRFRkFVTFRfQ09ORklHOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kT3BlcmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkVuZE9wZXJhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js ***!
  \*****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ATTR_MESSAGING_CONVERSATION_ID = exports.OLD_ATTR_MESSAGING_MESSAGE_ID = exports.MESSAGING_DESTINATION_KIND_VALUE_TOPIC = exports.ATTR_MESSAGING_URL = exports.ATTR_MESSAGING_PROTOCOL_VERSION = exports.ATTR_MESSAGING_PROTOCOL = exports.MESSAGING_OPERATION_VALUE_PROCESS = exports.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY = exports.ATTR_MESSAGING_DESTINATION_KIND = exports.ATTR_MESSAGING_DESTINATION = void 0;\n/*\n * This file contains constants for values that where replaced/removed from\n * Semantic Conventions long enough ago that they do not have `ATTR_*`\n * constants in the `@opentelemetry/semantic-conventions` package. Eventually\n * it is expected that this instrumention will be updated to emit telemetry\n * using modern Semantic Conventions, dropping the need for the constants in\n * this file.\n */\n/**\n * The message destination name. This might be equal to the span name but is required nevertheless.\n *\n * @deprecated Use ATTR_MESSAGING_DESTINATION_NAME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_DESTINATION = 'messaging.destination';\n/**\n * The kind of message destination.\n *\n * @deprecated Removed in semconv v1.20.0.\n */\nexports.ATTR_MESSAGING_DESTINATION_KIND = 'messaging.destination_kind';\n/**\n * RabbitMQ message routing key.\n *\n * @deprecated Use ATTR_MESSAGING_RABBITMQ_DESTINATION_ROUTING_KEY in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY = 'messaging.rabbitmq.routing_key';\n/**\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n *\n * @deprecated Use MESSAGING_OPERATION_TYPE_VALUE_PROCESS in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.MESSAGING_OPERATION_VALUE_PROCESS = 'process';\n/**\n * The name of the transport protocol.\n *\n * @deprecated Use ATTR_NETWORK_PROTOCOL_NAME.\n */\nexports.ATTR_MESSAGING_PROTOCOL = 'messaging.protocol';\n/**\n * The version of the transport protocol.\n *\n * @deprecated Use ATTR_NETWORK_PROTOCOL_VERSION.\n */\nexports.ATTR_MESSAGING_PROTOCOL_VERSION = 'messaging.protocol_version';\n/**\n * Connection string.\n *\n * @deprecated Removed in semconv v1.17.0.\n */\nexports.ATTR_MESSAGING_URL = 'messaging.url';\n/**\n * The kind of message destination.\n *\n * @deprecated Removed in semconv v1.20.0.\n */\nexports.MESSAGING_DESTINATION_KIND_VALUE_TOPIC = 'topic';\n/**\n * A value used by the messaging system as an identifier for the message, represented as a string.\n *\n * @deprecated Use ATTR_MESSAGING_MESSAGE_ID in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n *\n * Note: changing to `ATTR_MESSAGING_MESSAGE_ID` means a change in value from `messaging.message_id` to `messaging.message.id`.\n */\nexports.OLD_ATTR_MESSAGING_MESSAGE_ID = 'messaging.message_id';\n/**\n * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.\n *\n * @deprecated Use ATTR_MESSAGING_MESSAGE_CONVERSATION_ID in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).\n */\nexports.ATTR_MESSAGING_CONVERSATION_ID = 'messaging.conversation_id';\n//# sourceMappingURL=semconv-obsolete.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9zZW1jb252LW9ic29sZXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxHQUFHLHFDQUFxQyxHQUFHLDhDQUE4QyxHQUFHLDBCQUEwQixHQUFHLHVDQUF1QyxHQUFHLCtCQUErQixHQUFHLHlDQUF5QyxHQUFHLDJDQUEyQyxHQUFHLHVDQUF1QyxHQUFHLGtDQUFrQztBQUNqWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1IQUFtSDtBQUNuTTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxtSEFBbUg7QUFDbk47QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxzSkFBc0osU0FBUztBQUMvSjtBQUNBLHVGQUF1RixtSEFBbUg7QUFDMU07QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsbUhBQW1IO0FBQzdMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLG1KQUFtSixtQkFBbUI7QUFDdEs7QUFDQSx1RkFBdUYsbUhBQW1IO0FBQzFNO0FBQ0Esc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvc2VtY29udi1vYnNvbGV0ZS5qcz82YzRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEID0gZXhwb3J0cy5PTERfQVRUUl9NRVNTQUdJTkdfTUVTU0FHRV9JRCA9IGV4cG9ydHMuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX1VSTCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0xfVkVSU0lPTiA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0wgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVkFMVUVfUFJPQ0VTUyA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVkgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkQgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OID0gdm9pZCAwO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBjb25zdGFudHMgZm9yIHZhbHVlcyB0aGF0IHdoZXJlIHJlcGxhY2VkL3JlbW92ZWQgZnJvbVxuICogU2VtYW50aWMgQ29udmVudGlvbnMgbG9uZyBlbm91Z2ggYWdvIHRoYXQgdGhleSBkbyBub3QgaGF2ZSBgQVRUUl8qYFxuICogY29uc3RhbnRzIGluIHRoZSBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgIHBhY2thZ2UuIEV2ZW50dWFsbHlcbiAqIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhpcyBpbnN0cnVtZW50aW9uIHdpbGwgYmUgdXBkYXRlZCB0byBlbWl0IHRlbGVtZXRyeVxuICogdXNpbmcgbW9kZXJuIFNlbWFudGljIENvbnZlbnRpb25zLCBkcm9wcGluZyB0aGUgbmVlZCBmb3IgdGhlIGNvbnN0YW50cyBpblxuICogdGhpcyBmaWxlLlxuICovXG4vKipcbiAqIFRoZSBtZXNzYWdlIGRlc3RpbmF0aW9uIG5hbWUuIFRoaXMgbWlnaHQgYmUgZXF1YWwgdG8gdGhlIHNwYW4gbmFtZSBidXQgaXMgcmVxdWlyZWQgbmV2ZXJ0aGVsZXNzLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBBVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FIGluIFtpbmN1YmF0aW5nIGVudHJ5LXBvaW50XSh7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvYmxvYi9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zL1JFQURNRS5tZCN1bnN0YWJsZS1zZW1jb252fSkuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT04gPSAnbWVzc2FnaW5nLmRlc3RpbmF0aW9uJztcbi8qKlxuICogVGhlIGtpbmQgb2YgbWVzc2FnZSBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHNlbWNvbnYgdjEuMjAuMC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbl9raW5kJztcbi8qKlxuICogUmFiYml0TVEgbWVzc2FnZSByb3V0aW5nIGtleS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQVRUUl9NRVNTQUdJTkdfUkFCQklUTVFfREVTVElOQVRJT05fUk9VVElOR19LRVkgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWSA9ICdtZXNzYWdpbmcucmFiYml0bXEucm91dGluZ19rZXknO1xuLyoqXG4gKiBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUga2luZCBvZiBtZXNzYWdlIGNvbnN1bXB0aW9uIGFzIGRlZmluZWQgaW4gdGhlIFtPcGVyYXRpb24gbmFtZXNdKCNvcGVyYXRpb24tbmFtZXMpIHNlY3Rpb24gYWJvdmUuIElmIHRoZSBvcGVyYXRpb24gaXMgJiMzNDtzZW5kJiMzNDssIHRoaXMgYXR0cmlidXRlIE1VU1QgTk9UIGJlIHNldCwgc2luY2UgdGhlIG9wZXJhdGlvbiBjYW4gYmUgaW5mZXJyZWQgZnJvbSB0aGUgc3BhbiBraW5kIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1BST0NFU1MgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1ZBTFVFX1BST0NFU1MgPSAncHJvY2Vzcyc7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSB0cmFuc3BvcnQgcHJvdG9jb2wuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIEFUVFJfTkVUV09SS19QUk9UT0NPTF9OQU1FLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MID0gJ21lc3NhZ2luZy5wcm90b2NvbCc7XG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSB0cmFuc3BvcnQgcHJvdG9jb2wuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIEFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04gPSAnbWVzc2FnaW5nLnByb3RvY29sX3ZlcnNpb24nO1xuLyoqXG4gKiBDb25uZWN0aW9uIHN0cmluZy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHNlbWNvbnYgdjEuMTcuMC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19VUkwgPSAnbWVzc2FnaW5nLnVybCc7XG4vKipcbiAqIFRoZSBraW5kIG9mIG1lc3NhZ2UgZGVzdGluYXRpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgUmVtb3ZlZCBpbiBzZW1jb252IHYxLjIwLjAuXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRfVkFMVUVfVE9QSUMgPSAndG9waWMnO1xuLyoqXG4gKiBBIHZhbHVlIHVzZWQgYnkgdGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgYW4gaWRlbnRpZmllciBmb3IgdGhlIG1lc3NhZ2UsIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBBVFRSX01FU1NBR0lOR19NRVNTQUdFX0lEIGluIFtpbmN1YmF0aW5nIGVudHJ5LXBvaW50XSh7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvYmxvYi9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zL1JFQURNRS5tZCN1bnN0YWJsZS1zZW1jb252fSkuXG4gKlxuICogTm90ZTogY2hhbmdpbmcgdG8gYEFUVFJfTUVTU0FHSU5HX01FU1NBR0VfSURgIG1lYW5zIGEgY2hhbmdlIGluIHZhbHVlIGZyb20gYG1lc3NhZ2luZy5tZXNzYWdlX2lkYCB0byBgbWVzc2FnaW5nLm1lc3NhZ2UuaWRgLlxuICovXG5leHBvcnRzLk9MRF9BVFRSX01FU1NBR0lOR19NRVNTQUdFX0lEID0gJ21lc3NhZ2luZy5tZXNzYWdlX2lkJztcbi8qKlxuICogVGhlIFtjb252ZXJzYXRpb24gSURdKCNjb252ZXJzYXRpb25zKSBpZGVudGlmeWluZyB0aGUgY29udmVyc2F0aW9uIHRvIHdoaWNoIHRoZSBtZXNzYWdlIGJlbG9uZ3MsIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiBTb21ldGltZXMgY2FsbGVkICYjMzQ7Q29ycmVsYXRpb24gSUQmIzM0Oy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQVRUUl9NRVNTQUdJTkdfTUVTU0FHRV9DT05WRVJTQVRJT05fSUQgaW4gW2luY3ViYXRpbmcgZW50cnktcG9pbnRdKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9ibG9iL21haW4vc2VtYW50aWMtY29udmVudGlvbnMvUkVBRE1FLm1kI3Vuc3RhYmxlLXNlbWNvbnZ9KS5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19DT05WRVJTQVRJT05fSUQgPSAnbWVzc2FnaW5nLmNvbnZlcnNhdGlvbl9pZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LW9ic29sZXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ATTR_NET_PEER_PORT = exports.ATTR_NET_PEER_NAME = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * Deprecated, use `messaging.operation.type` instead.\n *\n * @example publish\n * @example create\n * @example process\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `messaging.operation.type`.\n */\nexports.ATTR_MESSAGING_OPERATION = 'messaging.operation';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Deprecated, use `server.address` on client spans and `client.address` on server spans.\n *\n * @example example.com\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `server.address` on client spans and `client.address` on server spans.\n */\nexports.ATTR_NET_PEER_NAME = 'net.peer.name';\n/**\n * Deprecated, use `server.port` on client spans and `client.port` on server spans.\n *\n * @example 8080\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `server.port` on client spans and `client.port` on server spans.\n */\nexports.ATTR_NET_PEER_PORT = 'net.peer.port';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDZCQUE2QixHQUFHLGdDQUFnQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjU1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvc2VtY29udi5qcz9kMzY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVRUUl9ORVRfUEVFUl9QT1JUID0gZXhwb3J0cy5BVFRSX05FVF9QRUVSX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX1NZU1RFTSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OID0gdm9pZCAwO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGNvcHkgb2YgdW5zdGFibGUgc2VtYW50aWMgY29udmVudGlvbiBkZWZpbml0aW9uc1xuICogdXNlZCBieSB0aGlzIHBhY2thZ2UuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWpzL3RyZWUvbWFpbi9zZW1hbnRpYy1jb252ZW50aW9ucyN1bnN0YWJsZS1zZW1jb252XG4gKi9cbi8qKlxuICogRGVwcmVjYXRlZCwgdXNlIGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgIGluc3RlYWQuXG4gKlxuICogQGV4YW1wbGUgcHVibGlzaFxuICogQGV4YW1wbGUgY3JlYXRlXG4gKiBAZXhhbXBsZSBwcm9jZXNzXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICpcbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTiA9ICdtZXNzYWdpbmcub3BlcmF0aW9uJztcbi8qKlxuICogVGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgaWRlbnRpZmllZCBieSB0aGUgY2xpZW50IGluc3RydW1lbnRhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGUgYWN0dWFsIG1lc3NhZ2luZyBzeXN0ZW0gbWF5IGRpZmZlciBmcm9tIHRoZSBvbmUga25vd24gYnkgdGhlIGNsaWVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgS2Fma2EgY2xpZW50IGxpYnJhcmllcyB0byBjb21tdW5pY2F0ZSB3aXRoIEF6dXJlIEV2ZW50IEh1YnMsIHRoZSBgbWVzc2FnaW5nLnN5c3RlbWAgaXMgc2V0IHRvIGBrYWZrYWAgYmFzZWQgb24gdGhlIGluc3RydW1lbnRhdGlvbidzIGJlc3Qga25vd2xlZGdlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSAnbWVzc2FnaW5nLnN5c3RlbSc7XG4vKipcbiAqIERlcHJlY2F0ZWQsIHVzZSBgc2VydmVyLmFkZHJlc3NgIG9uIGNsaWVudCBzcGFucyBhbmQgYGNsaWVudC5hZGRyZXNzYCBvbiBzZXJ2ZXIgc3BhbnMuXG4gKlxuICogQGV4YW1wbGUgZXhhbXBsZS5jb21cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKlxuICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgYnkgYHNlcnZlci5hZGRyZXNzYCBvbiBjbGllbnQgc3BhbnMgYW5kIGBjbGllbnQuYWRkcmVzc2Agb24gc2VydmVyIHNwYW5zLlxuICovXG5leHBvcnRzLkFUVFJfTkVUX1BFRVJfTkFNRSA9ICduZXQucGVlci5uYW1lJztcbi8qKlxuICogRGVwcmVjYXRlZCwgdXNlIGBzZXJ2ZXIucG9ydGAgb24gY2xpZW50IHNwYW5zIGFuZCBgY2xpZW50LnBvcnRgIG9uIHNlcnZlciBzcGFucy5cbiAqXG4gKiBAZXhhbXBsZSA4MDgwXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICpcbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IGBzZXJ2ZXIucG9ydGAgb24gY2xpZW50IHNwYW5zIGFuZCBgY2xpZW50LnBvcnRgIG9uIHNlcnZlciBzcGFucy5cbiAqL1xuZXhwb3J0cy5BVFRSX05FVF9QRUVSX1BPUlQgPSAnbmV0LnBlZXIucG9ydCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3R5cGVzLmpzPzVhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfQ09ORklHID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gPSB2b2lkIDA7XG52YXIgRW5kT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChFbmRPcGVyYXRpb24pIHtcbiAgICBFbmRPcGVyYXRpb25bXCJBdXRvQWNrXCJdID0gXCJhdXRvIGFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIkFja1wiXSA9IFwiYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQWNrQWxsXCJdID0gXCJhY2tBbGxcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJSZWplY3RcIl0gPSBcInJlamVjdFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIk5hY2tcIl0gPSBcIm5hY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJOYWNrQWxsXCJdID0gXCJuYWNrQWxsXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQ2hhbm5lbENsb3NlZFwiXSA9IFwiY2hhbm5lbCBjbG9zZWRcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJDaGFubmVsRXJyb3JcIl0gPSBcImNoYW5uZWwgZXJyb3JcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJJbnN0cnVtZW50YXRpb25UaW1lb3V0XCJdID0gXCJpbnN0cnVtZW50YXRpb24gdGltZW91dFwiO1xufSkoRW5kT3BlcmF0aW9uID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gfHwgKGV4cG9ydHMuRW5kT3BlcmF0aW9uID0ge30pKTtcbmV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSB7XG4gICAgY29uc3VtZVRpbWVvdXRNczogMTAwMCAqIDYwLFxuICAgIHVzZUxpbmtzRm9yQ29uc3VtZTogZmFsc2UsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv.js\");\nconst semconv_obsolete_1 = __webpack_require__(/*! ../src/semconv-obsolete */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/semconv-obsolete.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) => exchangeName !== '' ? exchangeName : '<default>';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) => {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) => {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) => {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -> 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) => {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) => {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) => {\n    const product = conn.serverProperties.product?.toLowerCase?.();\n    if (product) {\n        return {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) => {\n    const attributes = {\n        [semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions?.protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL, protocol, 'protocol'),\n        });\n        const hostname = getHostname(connectOptions?.hostname);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_1.ATTR_NET_PEER_NAME, hostname, 'hostname'),\n        });\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semconv_1.ATTR_NET_PEER_PORT, port, 'port'),\n        });\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semconv_obsolete_1.ATTR_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_obsolete_1.ATTR_MESSAGING_PROTOCOL, protocol, 'protocol'),\n            });\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_1.ATTR_NET_PEER_NAME, hostname, 'hostname'),\n            });\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semconv_1.ATTR_NET_PEER_PORT, port, 'port'),\n            });\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) => {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) => {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) => {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyx5Q0FBeUMsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRywyQkFBMkI7QUFDbFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNJQUFvQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxpTUFBVztBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyx3TkFBeUI7QUFDNUQsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0RkFBNEYsWUFBWTtBQUN4RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41NS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzP2UyNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBleHBvcnRzLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBleHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9IGV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyID0gZXhwb3J0cy5ub3JtYWxpemVFeGNoYW5nZSA9IGV4cG9ydHMuQ09OTkVDVElPTl9BVFRSSUJVVEVTID0gZXhwb3J0cy5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUiA9IGV4cG9ydHMuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQgPSBleHBvcnRzLk1FU1NBR0VfU1RPUkVEX1NQQU4gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3Qgc2VtY29udl8xID0gcmVxdWlyZShcIi4vc2VtY29udlwiKTtcbmNvbnN0IHNlbWNvbnZfb2Jzb2xldGVfMSA9IHJlcXVpcmUoXCIuLi9zcmMvc2VtY29udi1vYnNvbGV0ZVwiKTtcbmV4cG9ydHMuTUVTU0FHRV9TVE9SRURfU1BBTiA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLm1lc3NhZ2Uuc3RvcmVkLXNwYW4nKTtcbmV4cG9ydHMuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLnNwYW5zLW5vdC1lbmRlZCcpO1xuZXhwb3J0cy5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUiA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNoYW5uZWwuY29uc3VtZXItdGltZW91dC10aW1lcicpO1xuZXhwb3J0cy5DT05ORUNUSU9OX0FUVFJJQlVURVMgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jb25uZWN0aW9uLmF0dHJpYnV0ZXMnKTtcbmNvbnN0IElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSA9ICgwLCBhcGlfMS5jcmVhdGVDb250ZXh0S2V5KSgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNoYW5uZWwuaXMtY29uZmlybS1jaGFubmVsJyk7XG5jb25zdCBub3JtYWxpemVFeGNoYW5nZSA9IChleGNoYW5nZU5hbWUpID0+IGV4Y2hhbmdlTmFtZSAhPT0gJycgPyBleGNoYW5nZU5hbWUgOiAnPGRlZmF1bHQ+JztcbmV4cG9ydHMubm9ybWFsaXplRXhjaGFuZ2UgPSBub3JtYWxpemVFeGNoYW5nZTtcbmNvbnN0IGNlbnNvclBhc3N3b3JkID0gKHVybCkgPT4ge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvOlteOkAvXSpALywgJzoqKipAJyk7XG59O1xuY29uc3QgZ2V0UG9ydCA9IChwb3J0RnJvbVVybCwgcmVzb2x2ZWRQcm90b2NvbCkgPT4ge1xuICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgcmVzb2x2ZWQgcHJvdG9jb2wgd2hpY2ggaXMgdXBwZXIgY2FzZVxuICAgIC8vIHRoaXMgY29kZSBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgdGhlIGFtcXBsaWIgd2hpY2ggaXMgdXNlZCB0byBzZXQgY29ubmVjdGlvbiBwYXJhbXNcbiAgICByZXR1cm4gcG9ydEZyb21VcmwgfHwgKHJlc29sdmVkUHJvdG9jb2wgPT09ICdBTVFQJyA/IDU2NzIgOiA1NjcxKTtcbn07XG5jb25zdCBnZXRQcm90b2NvbCA9IChwcm90b2NvbEZyb21VcmwpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZFByb3RvY29sID0gcHJvdG9jb2xGcm9tVXJsIHx8ICdhbXFwJztcbiAgICAvLyB0aGUgc3Vic3RyaW5nIHJlbW92ZWQgdGhlICc6JyBwYXJ0IG9mIHRoZSBwcm90b2NvbCAoJ2FtcXA6JyAtPiAnYW1xcCcpXG4gICAgY29uc3Qgbm9FbmRpbmdDb2xvbiA9IHJlc29sdmVkUHJvdG9jb2wuZW5kc1dpdGgoJzonKVxuICAgICAgICA/IHJlc29sdmVkUHJvdG9jb2wuc3Vic3RyaW5nKDAsIHJlc29sdmVkUHJvdG9jb2wubGVuZ3RoIC0gMSlcbiAgICAgICAgOiByZXNvbHZlZFByb3RvY29sO1xuICAgIC8vIHVwcGVyIGNhc2VzIHRvIG1hdGNoIHNwZWNcbiAgICByZXR1cm4gbm9FbmRpbmdDb2xvbi50b1VwcGVyQ2FzZSgpO1xufTtcbmNvbnN0IGdldEhvc3RuYW1lID0gKGhvc3RuYW1lRnJvbVVybCkgPT4ge1xuICAgIC8vIGlmIHVzZXIgc3VwcGxpZXMgZW1wdHkgaG9zdG5hbWUsIGl0IGdldHMgZm9yd2FyZGVkIHRvICduZXQnIHBhY2thZ2Ugd2hpY2ggZGVmYXVsdCBpdCB0byBsb2NhbGhvc3QuXG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxMi54L2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcbiAgICByZXR1cm4gaG9zdG5hbWVGcm9tVXJsIHx8ICdsb2NhbGhvc3QnO1xufTtcbmNvbnN0IGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2cgPSAodXJsLCBhdHRyaWJ1dGVLZXksIGF0dHJpYnV0ZVZhbHVlLCBuYW1lRm9yTG9nKSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IFthdHRyaWJ1dGVLZXldOiBhdHRyaWJ1dGVWYWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBpXzEuZGlhZy5lcnJvcihgYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvdWxkIG5vdCBleHRyYWN0IGNvbm5lY3Rpb24gYXR0cmlidXRlICR7bmFtZUZvckxvZ30gZnJvbSB1c2VyIHN1cHBsaWVkIHVybGAsIHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyID0gKGNvbm4pID0+IHtcbiAgICBjb25zdCBwcm9kdWN0ID0gY29ubi5zZXJ2ZXJQcm9wZXJ0aWVzLnByb2R1Y3Q/LnRvTG93ZXJDYXNlPy4oKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBwcm9kdWN0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5leHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlcjtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtY29udl9vYnNvbGV0ZV8xLkFUVFJfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT05dOiAnMC45LjEnLCAvLyB0aGlzIGlzIHRoZSBvbmx5IHByb3RvY29sIHN1cHBvcnRlZCBieSB0aGUgaW5zdHJ1bWVudGVkIGxpYnJhcnlcbiAgICB9O1xuICAgIHVybCA9IHVybCB8fCAnYW1xcDovL2xvY2FsaG9zdCc7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RPcHRpb25zID0gdXJsO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKGNvbm5lY3RPcHRpb25zPy5wcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19QUk9UT0NPTCwgcHJvdG9jb2wsICdwcm90b2NvbCcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZShjb25uZWN0T3B0aW9ucz8uaG9zdG5hbWUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIC4uLmV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1jb252XzEuQVRUUl9ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydChjb25uZWN0T3B0aW9ucy5wb3J0LCBwcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWNvbnZfMS5BVFRSX05FVF9QRUVSX1BPUlQsIHBvcnQsICdwb3J0JyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY2Vuc29yZWRVcmwgPSBjZW5zb3JQYXNzd29yZCh1cmwpO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWNvbnZfb2Jzb2xldGVfMS5BVFRSX01FU1NBR0lOR19VUkxdID0gY2Vuc29yZWRVcmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoY2Vuc29yZWRVcmwpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBnZXRQcm90b2NvbCh1cmxQYXJ0cy5wcm90b2NvbCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1jb252X29ic29sZXRlXzEuQVRUUl9NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZSh1cmxQYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1jb252XzEuQVRUUl9ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBnZXRQb3J0KHVybFBhcnRzLnBvcnQgPyBwYXJzZUludCh1cmxQYXJ0cy5wb3J0KSA6IHVuZGVmaW5lZCwgcHJvdG9jb2wpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtY29udl8xLkFUVFJfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBlcnJvciB3aGlsZSBleHRyYWN0aW5nIGNvbm5lY3Rpb24gZGV0YWlscyBmcm9tIGNvbm5lY3Rpb24gdXJsJywge1xuICAgICAgICAgICAgICAgIGNlbnNvcmVkVXJsLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsID0gZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsO1xuY29uc3QgbWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZLCB0cnVlKTtcbn07XG5leHBvcnRzLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBtYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5kZWxldGVWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkpO1xufTtcbmV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LmdldFZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSkgPT09IHRydWU7XG59O1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGlzQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.55.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy92ZXJzaW9uLmpzPzc3YzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC41NS4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.55.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");

/***/ })

};
;