"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nvar instrumentation_1 = __webpack_require__(/*! ./instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\");\nObject.defineProperty(exports, \"KafkaJsInstrumentation\", ({ enumerable: true, get: function () { return instrumentation_1.KafkaJsInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsd0JBQXdCLG1CQUFPLENBQUMsaU5BQW1CO0FBQ25ELDBEQUF5RCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNySiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xOC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL2luZGV4LmpzPzY2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnMsIEFzcGVjdG9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xudmFyIGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIi4vaW5zdHJ1bWVudGF0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2Fma2FKc0luc3RydW1lbnRhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdHJ1bWVudGF0aW9uXzEuS2Fma2FKc0luc3RydW1lbnRhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EVENT_LISTENERS_SET = void 0;\nexports.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet');\n//# sourceMappingURL=internal-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnRlcm5hbC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW50ZXJuYWwtdHlwZXMuanM/NGMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVWRU5UX0xJU1RFTkVSU19TRVQgPSB2b2lkIDA7XG5leHBvcnRzLkVWRU5UX0xJU1RFTkVSU19TRVQgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuaW5zdHJ1bWVudGF0aW9uLmthZmthanMuZXZlbnRMaXN0ZW5lcnNTZXQnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTextMapGetter = void 0;\n/*\nsame as open telemetry's `defaultTextMapGetter`,\nbut also handle case where header is buffer,\nadding toString() to make sure string is returned\n*/\nexports.bufferTextMapGetter = {\n    get(carrier, key) {\n        if (!carrier) {\n            return undefined;\n        }\n        const keys = Object.keys(carrier);\n        for (const carrierKey of keys) {\n            if (carrierKey === key || carrierKey.toLowerCase() === key) {\n                return carrier[carrierKey]?.toString();\n            }\n        }\n        return undefined;\n    },\n    keys(carrier) {\n        return carrier ? Object.keys(carrier) : [];\n    },\n};\n//# sourceMappingURL=propagator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9wcm9wYWdhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvcHJvcGFnYXRvci5qcz9lMmFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZmZXJUZXh0TWFwR2V0dGVyID0gdm9pZCAwO1xuLypcbnNhbWUgYXMgb3BlbiB0ZWxlbWV0cnkncyBgZGVmYXVsdFRleHRNYXBHZXR0ZXJgLFxuYnV0IGFsc28gaGFuZGxlIGNhc2Ugd2hlcmUgaGVhZGVyIGlzIGJ1ZmZlcixcbmFkZGluZyB0b1N0cmluZygpIHRvIG1ha2Ugc3VyZSBzdHJpbmcgaXMgcmV0dXJuZWRcbiovXG5leHBvcnRzLmJ1ZmZlclRleHRNYXBHZXR0ZXIgPSB7XG4gICAgZ2V0KGNhcnJpZXIsIGtleSkge1xuICAgICAgICBpZiAoIWNhcnJpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNhcnJpZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNhcnJpZXJLZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKGNhcnJpZXJLZXkgPT09IGtleSB8fCBjYXJyaWVyS2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXJyaWVyW2NhcnJpZXJLZXldPy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBrZXlzKGNhcnJpZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhcnJpZXIgPyBPYmplY3Qua2V5cyhjYXJyaWVyKSA6IFtdO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGFnYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * The number of messages sent, received, or processed in the scope of the batching operation.\n *\n * @example 0\n * @example 1\n * @example 2\n *\n * @note Instrumentations **SHOULD NOT** set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations **SHOULD** use `messaging.batch.message_count` for batching APIs and **SHOULD NOT** use it for single-message APIs.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count';\n/**\n * The message destination name\n *\n * @example MyQueue\n * @example MyTopic\n *\n * @note Destination name **SHOULD** uniquely identify a specific queue, topic or other entity within the broker. If\n * the broker doesn't have such notion, the destination name **SHOULD** uniquely identify the broker.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name';\n/**\n * The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.\n *\n * @example \"1\"\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id';\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute **MUST NOT** be set.\n *\n * @example \"myKey\"\n *\n * @note If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key';\n/**\n * A boolean that is true if the message is a tombstone.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone';\n/**\n * The offset of a record in the corresponding Kafka partition.\n *\n * @example 42\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset';\n/**\n * The system-specific name of the messaging operation.\n *\n * @example ack\n * @example nack\n * @example send\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name';\n/**\n * A string identifying the type of the messaging operation.\n *\n * @note If a custom value is used, it **MUST** be of low cardinality.\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Enum value \"process\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process';\n/**\n * Enum value \"receive\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive';\n/**\n * Enum value \"send\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send';\n/**\n * Enum value \"kafka\" for attribute {@link ATTR_MESSAGING_SYSTEM}.\n */\nexports.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka';\n/**\n * Number of messages that were delivered to the application.\n *\n * @note Records the number of messages pulled from the broker or number of messages dispatched to the application in push-based scenarios.\n * The metric **SHOULD** be reported once per message delivery. For example, if receiving and processing operations are both instrumented for a single message delivery, this counter is incremented when the message is received and not reported when it is processed.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages';\n/**\n * Duration of messaging operation initiated by a producer or consumer client.\n *\n * @note This metric **SHOULD NOT** be used to report processing duration - processing duration is reported in `messaging.process.duration` metric.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration';\n/**\n * Number of messages producer attempted to send to the broker.\n *\n * @note This metric **MUST NOT** count messages that were created but haven't yet been sent.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages';\n/**\n * Duration of processing operation.\n *\n * @note This metric **MUST** be reported for operations with `messaging.operation.type` that matches `process`.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlDQUF5QyxHQUFHLDZDQUE2QyxHQUFHLGtEQUFrRCxHQUFHLGlEQUFpRCxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQyxHQUFHLDhDQUE4QyxHQUFHLDhDQUE4QyxHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQyxHQUFHLDhDQUE4QyxHQUFHLHdDQUF3QyxHQUFHLCtDQUErQyxHQUFHLHVDQUF1QyxHQUFHLDBDQUEwQztBQUNwdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUNBQXVDLG9DQUFvQztBQUMzRTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvc2VtY29udi5qcz8yNTliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19QUk9DRVNTX0RVUkFUSU9OID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9TRU5UX01FU1NBR0VTID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04gPSBleHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTID0gZXhwb3J0cy5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBID0gZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfU0VORCA9IGV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfT0ZGU0VUID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVkgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQkFUQ0hfTUVTU0FHRV9DT1VOVCA9IHZvaWQgMDtcbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYSBjb3B5IG9mIHVuc3RhYmxlIHNlbWFudGljIGNvbnZlbnRpb24gZGVmaW5pdGlvbnNcbiAqIHVzZWQgYnkgdGhpcyBwYWNrYWdlLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy90cmVlL21haW4vc2VtYW50aWMtY29udmVudGlvbnMjdW5zdGFibGUtc2VtY29udlxuICovXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgc2VudCwgcmVjZWl2ZWQsIG9yIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGJhdGNoaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSAwXG4gKiBAZXhhbXBsZSAxXG4gKiBAZXhhbXBsZSAyXG4gKlxuICogQG5vdGUgSW5zdHJ1bWVudGF0aW9ucyAqKlNIT1VMRCBOT1QqKiBzZXQgYG1lc3NhZ2luZy5iYXRjaC5tZXNzYWdlX2NvdW50YCBvbiBzcGFucyB0aGF0IG9wZXJhdGUgd2l0aCBhIHNpbmdsZSBtZXNzYWdlLiBXaGVuIGEgbWVzc2FnaW5nIGNsaWVudCBsaWJyYXJ5IHN1cHBvcnRzIGJvdGggYmF0Y2ggYW5kIHNpbmdsZS1tZXNzYWdlIEFQSSBmb3IgdGhlIHNhbWUgb3BlcmF0aW9uLCBpbnN0cnVtZW50YXRpb25zICoqU0hPVUxEKiogdXNlIGBtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudGAgZm9yIGJhdGNoaW5nIEFQSXMgYW5kICoqU0hPVUxEIE5PVCoqIHVzZSBpdCBmb3Igc2luZ2xlLW1lc3NhZ2UgQVBJcy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQkFUQ0hfTUVTU0FHRV9DT1VOVCA9ICdtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudCc7XG4vKipcbiAqIFRoZSBtZXNzYWdlIGRlc3RpbmF0aW9uIG5hbWVcbiAqXG4gKiBAZXhhbXBsZSBNeVF1ZXVlXG4gKiBAZXhhbXBsZSBNeVRvcGljXG4gKlxuICogQG5vdGUgRGVzdGluYXRpb24gbmFtZSAqKlNIT1VMRCoqIHVuaXF1ZWx5IGlkZW50aWZ5IGEgc3BlY2lmaWMgcXVldWUsIHRvcGljIG9yIG90aGVyIGVudGl0eSB3aXRoaW4gdGhlIGJyb2tlci4gSWZcbiAqIHRoZSBicm9rZXIgZG9lc24ndCBoYXZlIHN1Y2ggbm90aW9uLCB0aGUgZGVzdGluYXRpb24gbmFtZSAqKlNIT1VMRCoqIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBicm9rZXIuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUUgPSAnbWVzc2FnaW5nLmRlc3RpbmF0aW9uLm5hbWUnO1xuLyoqXG4gKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcGFydGl0aW9uIG1lc3NhZ2VzIGFyZSBzZW50IHRvIG9yIHJlY2VpdmVkIGZyb20sIHVuaXF1ZSB3aXRoaW4gdGhlIGBtZXNzYWdpbmcuZGVzdGluYXRpb24ubmFtZWAuXG4gKlxuICogQGV4YW1wbGUgXCIxXCJcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbi5wYXJ0aXRpb24uaWQnO1xuLyoqXG4gKiBNZXNzYWdlIGtleXMgaW4gS2Fma2EgYXJlIHVzZWQgZm9yIGdyb3VwaW5nIGFsaWtlIG1lc3NhZ2VzIHRvIGVuc3VyZSB0aGV5J3JlIHByb2Nlc3NlZCBvbiB0aGUgc2FtZSBwYXJ0aXRpb24uIFRoZXkgZGlmZmVyIGZyb20gYG1lc3NhZ2luZy5tZXNzYWdlLmlkYCBpbiB0aGF0IHRoZXkncmUgbm90IHVuaXF1ZS4gSWYgdGhlIGtleSBpcyBgbnVsbGAsIHRoZSBhdHRyaWJ1dGUgKipNVVNUIE5PVCoqIGJlIHNldC5cbiAqXG4gKiBAZXhhbXBsZSBcIm15S2V5XCJcbiAqXG4gKiBAbm90ZSBJZiB0aGUga2V5IHR5cGUgaXMgbm90IHN0cmluZywgaXQncyBzdHJpbmcgcmVwcmVzZW50YXRpb24gaGFzIHRvIGJlIHN1cHBsaWVkIGZvciB0aGUgYXR0cmlidXRlLiBJZiB0aGUga2V5IGhhcyBubyB1bmFtYmlndW91cywgY2Fub25pY2FsIHN0cmluZyBmb3JtLCBkb24ndCBpbmNsdWRlIGl0cyB2YWx1ZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVkgPSAnbWVzc2FnaW5nLmthZmthLm1lc3NhZ2Uua2V5Jztcbi8qKlxuICogQSBib29sZWFuIHRoYXQgaXMgdHJ1ZSBpZiB0aGUgbWVzc2FnZSBpcyBhIHRvbWJzdG9uZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9UT01CU1RPTkUgPSAnbWVzc2FnaW5nLmthZmthLm1lc3NhZ2UudG9tYnN0b25lJztcbi8qKlxuICogVGhlIG9mZnNldCBvZiBhIHJlY29yZCBpbiB0aGUgY29ycmVzcG9uZGluZyBLYWZrYSBwYXJ0aXRpb24uXG4gKlxuICogQGV4YW1wbGUgNDJcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfT0ZGU0VUID0gJ21lc3NhZ2luZy5rYWZrYS5vZmZzZXQnO1xuLyoqXG4gKiBUaGUgc3lzdGVtLXNwZWNpZmljIG5hbWUgb2YgdGhlIG1lc3NhZ2luZyBvcGVyYXRpb24uXG4gKlxuICogQGV4YW1wbGUgYWNrXG4gKiBAZXhhbXBsZSBuYWNrXG4gKiBAZXhhbXBsZSBzZW5kXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FID0gJ21lc3NhZ2luZy5vcGVyYXRpb24ubmFtZSc7XG4vKipcbiAqIEEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIHRoZSBtZXNzYWdpbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBub3RlIElmIGEgY3VzdG9tIHZhbHVlIGlzIHVzZWQsIGl0ICoqTVVTVCoqIGJlIG9mIGxvdyBjYXJkaW5hbGl0eS5cbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRSA9ICdtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGUnO1xuLyoqXG4gKiBUaGUgbWVzc2FnaW5nIHN5c3RlbSBhcyBpZGVudGlmaWVkIGJ5IHRoZSBjbGllbnQgaW5zdHJ1bWVudGF0aW9uLlxuICpcbiAqIEBub3RlIFRoZSBhY3R1YWwgbWVzc2FnaW5nIHN5c3RlbSBtYXkgZGlmZmVyIGZyb20gdGhlIG9uZSBrbm93biBieSB0aGUgY2xpZW50LiBGb3IgZXhhbXBsZSwgd2hlbiB1c2luZyBLYWZrYSBjbGllbnQgbGlicmFyaWVzIHRvIGNvbW11bmljYXRlIHdpdGggQXp1cmUgRXZlbnQgSHVicywgdGhlIGBtZXNzYWdpbmcuc3lzdGVtYCBpcyBzZXQgdG8gYGthZmthYCBiYXNlZCBvbiB0aGUgaW5zdHJ1bWVudGF0aW9uJ3MgYmVzdCBrbm93bGVkZ2UuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1NZU1RFTSA9ICdtZXNzYWdpbmcuc3lzdGVtJztcbi8qKlxuICogRW51bSB2YWx1ZSBcInByb2Nlc3NcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1BST0NFU1MgPSAncHJvY2Vzcyc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJyZWNlaXZlXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEV9LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFID0gJ3JlY2VpdmUnO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwic2VuZFwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfU0VORCA9ICdzZW5kJztcbi8qKlxuICogRW51bSB2YWx1ZSBcImthZmthXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfU1lTVEVNfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBID0gJ2thZmthJztcbi8qKlxuICogTnVtYmVyIG9mIG1lc3NhZ2VzIHRoYXQgd2VyZSBkZWxpdmVyZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBub3RlIFJlY29yZHMgdGhlIG51bWJlciBvZiBtZXNzYWdlcyBwdWxsZWQgZnJvbSB0aGUgYnJva2VyIG9yIG51bWJlciBvZiBtZXNzYWdlcyBkaXNwYXRjaGVkIHRvIHRoZSBhcHBsaWNhdGlvbiBpbiBwdXNoLWJhc2VkIHNjZW5hcmlvcy5cbiAqIFRoZSBtZXRyaWMgKipTSE9VTEQqKiBiZSByZXBvcnRlZCBvbmNlIHBlciBtZXNzYWdlIGRlbGl2ZXJ5LiBGb3IgZXhhbXBsZSwgaWYgcmVjZWl2aW5nIGFuZCBwcm9jZXNzaW5nIG9wZXJhdGlvbnMgYXJlIGJvdGggaW5zdHJ1bWVudGVkIGZvciBhIHNpbmdsZSBtZXNzYWdlIGRlbGl2ZXJ5LCB0aGlzIGNvdW50ZXIgaXMgaW5jcmVtZW50ZWQgd2hlbiB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCBhbmQgbm90IHJlcG9ydGVkIHdoZW4gaXQgaXMgcHJvY2Vzc2VkLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9DT05TVU1FRF9NRVNTQUdFUyA9ICdtZXNzYWdpbmcuY2xpZW50LmNvbnN1bWVkLm1lc3NhZ2VzJztcbi8qKlxuICogRHVyYXRpb24gb2YgbWVzc2FnaW5nIG9wZXJhdGlvbiBpbml0aWF0ZWQgYnkgYSBwcm9kdWNlciBvciBjb25zdW1lciBjbGllbnQuXG4gKlxuICogQG5vdGUgVGhpcyBtZXRyaWMgKipTSE9VTEQgTk9UKiogYmUgdXNlZCB0byByZXBvcnQgcHJvY2Vzc2luZyBkdXJhdGlvbiAtIHByb2Nlc3NpbmcgZHVyYXRpb24gaXMgcmVwb3J0ZWQgaW4gYG1lc3NhZ2luZy5wcm9jZXNzLmR1cmF0aW9uYCBtZXRyaWMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX09QRVJBVElPTl9EVVJBVElPTiA9ICdtZXNzYWdpbmcuY2xpZW50Lm9wZXJhdGlvbi5kdXJhdGlvbic7XG4vKipcbiAqIE51bWJlciBvZiBtZXNzYWdlcyBwcm9kdWNlciBhdHRlbXB0ZWQgdG8gc2VuZCB0byB0aGUgYnJva2VyLlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqTVVTVCBOT1QqKiBjb3VudCBtZXNzYWdlcyB0aGF0IHdlcmUgY3JlYXRlZCBidXQgaGF2ZW4ndCB5ZXQgYmVlbiBzZW50LlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9TRU5UX01FU1NBR0VTID0gJ21lc3NhZ2luZy5jbGllbnQuc2VudC5tZXNzYWdlcyc7XG4vKipcbiAqIER1cmF0aW9uIG9mIHByb2Nlc3Npbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqTVVTVCoqIGJlIHJlcG9ydGVkIGZvciBvcGVyYXRpb25zIHdpdGggYG1lc3NhZ2luZy5vcGVyYXRpb24udHlwZWAgdGhhdCBtYXRjaGVzIGBwcm9jZXNzYC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19QUk9DRVNTX0RVUkFUSU9OID0gJ21lc3NhZ2luZy5wcm9jZXNzLmR1cmF0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbWNvbnYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.18.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzP2U1NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC4xOC4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(";globalThis[\"_sentryRewritesTunnelPath\"] = undefined;globalThis[\"SENTRY_RELEASE\"] = undefined;globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryNextJsVersion\"] = \"14.2.35\";globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.39.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst internal_types_1 = __webpack_require__(/*! ./internal-types */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\");\nconst propagator_1 = __webpack_require__(/*! ./propagator */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\");\nfunction prepareCounter(meter, value, attributes) {\n    return (errorType) => {\n        meter.add(value, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nfunction prepareDurationHistogram(meter, value, attributes) {\n    return (errorType) => {\n        meter.record((Date.now() - value) / 1000, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nconst HISTOGRAM_BUCKET_BOUNDARIES = [\n    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,\n];\nclass KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    _updateMetricInstruments() {\n        this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n        this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);\n        this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);\n        this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n    }\n    init() {\n        const unpatch = (moduleExports) => {\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'producer');\n            }\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'consumer');\n            }\n        };\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('kafkajs', ['>=0.3.0 <3'], (moduleExports) => {\n            unpatch(moduleExports);\n            this._wrap(moduleExports?.Kafka?.prototype, 'producer', this._getProducerPatch());\n            this._wrap(moduleExports?.Kafka?.prototype, 'consumer', this._getConsumerPatch());\n            return moduleExports;\n        }, unpatch);\n        return module;\n    }\n    _getConsumerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newConsumer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {\n                    instrumentation._unwrap(newConsumer, 'run');\n                }\n                instrumentation._wrap(newConsumer, 'run', instrumentation._getConsumerRunPatch());\n                instrumentation._setKafkaEventListeners(newConsumer);\n                return newConsumer;\n            };\n        };\n    }\n    _setKafkaEventListeners(kafkaObj) {\n        if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])\n            return;\n        // The REQUEST Consumer event was added in kafkajs@1.5.0.\n        if (kafkaObj.events?.REQUEST) {\n            kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));\n        }\n        kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;\n    }\n    _recordClientDurationMetric(event) {\n        const [address, port] = event.payload.broker.split(':');\n        this._clientDuration.record(event.payload.duration / 1000, {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,\n            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,\n            [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10),\n        });\n    }\n    _getProducerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newProducer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {\n                    instrumentation._unwrap(newProducer, 'sendBatch');\n                }\n                instrumentation._wrap(newProducer, 'sendBatch', instrumentation._getSendBatchPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.send)) {\n                    instrumentation._unwrap(newProducer, 'send');\n                }\n                instrumentation._wrap(newProducer, 'send', instrumentation._getSendPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {\n                    instrumentation._unwrap(newProducer, 'transaction');\n                }\n                instrumentation._wrap(newProducer, 'transaction', instrumentation._getProducerTransactionPatch());\n                instrumentation._setKafkaEventListeners(newProducer);\n                return newProducer;\n            };\n        };\n    }\n    _getConsumerRunPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function run(...args) {\n                const config = args[0];\n                if (config?.eachMessage) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {\n                        instrumentation._unwrap(config, 'eachMessage');\n                    }\n                    instrumentation._wrap(config, 'eachMessage', instrumentation._getConsumerEachMessagePatch());\n                }\n                if (config?.eachBatch) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {\n                        instrumentation._unwrap(config, 'eachBatch');\n                    }\n                    instrumentation._wrap(config, 'eachBatch', instrumentation._getConsumerEachBatchPatch());\n                }\n                return original.call(this, config);\n            };\n        };\n    }\n    _getConsumerEachMessagePatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function eachMessage(...args) {\n                const payload = args[0];\n                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);\n                const span = instrumentation._startConsumerSpan({\n                    topic: payload.topic,\n                    message: payload.message,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                    ctx: propagatedContext,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    },\n                });\n                const pendingMetrics = [\n                    prepareDurationHistogram(instrumentation._processDuration, Date.now(), {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                    prepareCounter(instrumentation._consumedMessages, 1, {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                ];\n                const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {\n                    return original.apply(this, args);\n                });\n                return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);\n            };\n        };\n    }\n    _getConsumerEachBatchPatch() {\n        return (original) => {\n            const instrumentation = this;\n            return function eachBatch(...args) {\n                const payload = args[0];\n                // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n                const receivingSpan = instrumentation._startConsumerSpan({\n                    topic: payload.batch.topic,\n                    message: undefined,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,\n                    ctx: api_1.ROOT_CONTEXT,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                    },\n                });\n                return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {\n                    const startTime = Date.now();\n                    const spans = [];\n                    const pendingMetrics = [\n                        prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }),\n                    ];\n                    payload.batch.messages.forEach(message => {\n                        const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);\n                        const spanContext = api_1.trace\n                            .getSpan(propagatedContext)\n                            ?.spanContext();\n                        let origSpanLink;\n                        if (spanContext) {\n                            origSpanLink = {\n                                context: spanContext,\n                            };\n                        }\n                        spans.push(instrumentation._startConsumerSpan({\n                            topic: payload.batch.topic,\n                            message,\n                            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                            link: origSpanLink,\n                            attributes: {\n                                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                            },\n                        }));\n                        pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }));\n                    });\n                    const batchMessagePromise = original.apply(this, args);\n                    spans.unshift(receivingSpan);\n                    return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);\n                });\n            };\n        };\n    }\n    _getProducerTransactionPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function transaction(...args) {\n                const transactionSpan = instrumentation.tracer.startSpan('transaction');\n                const transactionPromise = original.apply(this, args);\n                transactionPromise\n                    .then((transaction) => {\n                    const originalSend = transaction.send;\n                    transaction.send = function send(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendPatch()(originalSend);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalSendBatch = transaction.sendBatch;\n                    transaction.sendBatch = function sendBatch(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendBatchPatch()(originalSendBatch);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalCommit = transaction.commit;\n                    transaction.commit = function commit(...args) {\n                        const originCommitPromise = originalCommit\n                            .apply(this, args)\n                            .then(() => {\n                            transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });\n                        });\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);\n                    };\n                    const originalAbort = transaction.abort;\n                    transaction.abort = function abort(...args) {\n                        const originAbortPromise = originalAbort.apply(this, args);\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);\n                    };\n                })\n                    .catch(err => {\n                    transactionSpan.setStatus({\n                        code: api_1.SpanStatusCode.ERROR,\n                        message: err?.message,\n                    });\n                    transactionSpan.recordException(err);\n                    transactionSpan.end();\n                });\n                return transactionPromise;\n            };\n        };\n    }\n    _getSendBatchPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function sendBatch(...args) {\n                const batch = args[0];\n                const messages = batch.topicMessages || [];\n                const spans = [];\n                const pendingMetrics = [];\n                messages.forEach(topicMessage => {\n                    topicMessage.messages.forEach(message => {\n                        spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));\n                        pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,\n                            ...(message.partition !== undefined\n                                ? {\n                                    [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition),\n                                }\n                                : {}),\n                        }));\n                    });\n                });\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _getSendPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function send(...args) {\n                const record = args[0];\n                const spans = record.messages.map(message => {\n                    return instrumentation._startProducerSpan(record.topic, message);\n                });\n                const pendingMetrics = record.messages.map(m => prepareCounter(instrumentation._sentMessages, 1, {\n                    [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                    [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                    [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,\n                    ...(m.partition !== undefined\n                        ? {\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition),\n                        }\n                        : {}),\n                }));\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {\n        return Promise.resolve(sendPromise)\n            .then(result => {\n            pendingMetrics.forEach(m => m());\n            return result;\n        })\n            .catch(reason => {\n            let errorMessage;\n            let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;\n            if (typeof reason === 'string' || reason === undefined) {\n                errorMessage = reason;\n            }\n            else if (typeof reason === 'object' &&\n                Object.prototype.hasOwnProperty.call(reason, 'message')) {\n                errorMessage = reason.message;\n                errorType = reason.constructor.name;\n            }\n            pendingMetrics.forEach(m => m(errorType));\n            spans.forEach(span => {\n                span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: errorMessage,\n                });\n            });\n            throw reason;\n        })\n            .finally(() => {\n            spans.forEach(span => span.end());\n        });\n    }\n    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes, }) {\n        const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n            ? 'poll' // for batch processing spans\n            : operationType; // for individual message processing spans\n        const span = this.tracer.startSpan(`${operationName} ${topic}`, {\n            kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n                ? api_1.SpanKind.CLIENT\n                : api_1.SpanKind.CONSUMER,\n            attributes: {\n                ...attributes,\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset,\n            },\n            links: link ? [link] : [],\n        }, ctx);\n        const { consumerHook } = this.getConfig();\n        if (consumerHook && message) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('consumerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n    _startProducerSpan(topic, message) {\n        const span = this.tracer.startSpan(`send ${topic}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined\n                    ? String(message.partition)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND,\n            },\n        });\n        message.headers = message.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);\n        const { producerHook } = this.getConfig();\n        if (producerHook) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('producerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n}\nexports.KafkaJsInstrumentation = KafkaJsInstrumentation;\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWEsQ0FBQyxvREFBb0QseUNBQXlDLDBDQUEwQywrQ0FBK0M7QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLHFNQUFnQztBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQywwTEFBcUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsK01BQWtCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLHVNQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaU1BQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELElBQUk7QUFDeEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0QsSUFBSTtBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxVQUFVLHlEQUF5RDtBQUNyTDtBQUNBO0FBQ0EsMEdBQTBHLFVBQVUseURBQXlEO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQkFBK0I7QUFDdkYseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4Q0FBOEMsZUFBZSxFQUFFLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanM/YTlhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjs7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlc1R1bm5lbFBhdGhcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIlNFTlRSWV9SRUxFQVNFXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJfc2VudHJ5QmFzZVBhdGhcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlOZXh0SnNWZXJzaW9uXCJdID0gXCIxNC4yLjM1XCI7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlRnJhbWVzRGlzdERpclwiXSA9IFwiLm5leHRcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkthZmthSnNJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgaW50ZXJuYWxfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsLXR5cGVzXCIpO1xuY29uc3QgcHJvcGFnYXRvcl8xID0gcmVxdWlyZShcIi4vcHJvcGFnYXRvclwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5mdW5jdGlvbiBwcmVwYXJlQ291bnRlcihtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5hZGQodmFsdWUsIHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi4oZXJyb3JUeXBlID8geyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0VSUk9SX1RZUEVdOiBlcnJvclR5cGUgfSA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5yZWNvcmQoKERhdGUubm93KCkgLSB2YWx1ZSkgLyAxMDAwLCB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4uKGVycm9yVHlwZSA/IHsgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXTogZXJyb3JUeXBlIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgPSBbXG4gICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSwgNy41LCAxMCxcbl07XG5jbGFzcyBLYWZrYUpzSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgY29uZmlnKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9jbGllbnREdXJhdGlvbiA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04sIHsgYWR2aWNlOiB7IGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTIH0gfSk7XG4gICAgICAgIHRoaXMuX3NlbnRNZXNzYWdlcyA9IHRoaXMubWV0ZXIuY3JlYXRlQ291bnRlcihzZW1jb252XzEuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyk7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkTWVzc2FnZXMgPSB0aGlzLm1ldGVyLmNyZWF0ZUNvdW50ZXIoc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0R1cmF0aW9uID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiwgeyBhZHZpY2U6IHsgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgfSB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgdW5wYXRjaCA9IChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZS5wcm9kdWNlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5LYWZrYS5wcm90b3R5cGUsICdwcm9kdWNlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHM/LkthZmthPy5wcm90b3R5cGUuY29uc3VtZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuS2Fma2EucHJvdG90eXBlLCAnY29uc3VtZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdrYWZrYWpzJywgWyc+PTAuMy4wIDwzJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICB1bnBhdGNoKG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAncHJvZHVjZXInLCB0aGlzLl9nZXRQcm9kdWNlclBhdGNoKCkpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAnY29uc3VtZXInLCB0aGlzLl9nZXRDb25zdW1lclBhdGNoKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIHVucGF0Y2gpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBfZ2V0Q29uc3VtZXJQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb25zdW1lciA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShuZXdDb25zdW1lci5ydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld0NvbnN1bWVyLCAncnVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdDb25zdW1lciwgJ3J1bicsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJSdW5QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3Q29uc3VtZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb25zdW1lcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKGthZmthT2JqKSB7XG4gICAgICAgIGlmIChrYWZrYU9ialtpbnRlcm5hbF90eXBlc18xLkVWRU5UX0xJU1RFTkVSU19TRVRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgUkVRVUVTVCBDb25zdW1lciBldmVudCB3YXMgYWRkZWQgaW4ga2Fma2Fqc0AxLjUuMC5cbiAgICAgICAgaWYgKGthZmthT2JqLmV2ZW50cz8uUkVRVUVTVCkge1xuICAgICAgICAgICAga2Fma2FPYmoub24oa2Fma2FPYmouZXZlbnRzLlJFUVVFU1QsIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uTWV0cmljLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGthZmthT2JqW2ludGVybmFsX3R5cGVzXzEuRVZFTlRfTElTVEVORVJTX1NFVF0gPSB0cnVlO1xuICAgIH1cbiAgICBfcmVjb3JkQ2xpZW50RHVyYXRpb25NZXRyaWMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3MsIHBvcnRdID0gZXZlbnQucGF5bG9hZC5icm9rZXIuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5fY2xpZW50RHVyYXRpb24ucmVjb3JkKGV2ZW50LnBheWxvYWQuZHVyYXRpb24gLyAxMDAwLCB7XG4gICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IGAke2V2ZW50LnBheWxvYWQuYXBpTmFtZX1gLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyLnBhcnNlSW50KHBvcnQsIDEwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZXIoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y2VyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnNlbmRCYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIuc2VuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3NlbmQnLCBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIudHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nLCBpbnN0cnVtZW50YXRpb24uX2dldFByb2R1Y2VyVHJhbnNhY3Rpb25QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3UHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9kdWNlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lclJ1blBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmVhY2hNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShjb25maWcuZWFjaE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChjb25maWcsICdlYWNoTWVzc2FnZScsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJFYWNoTWVzc2FnZVBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5lYWNoQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKGNvbmZpZy5lYWNoQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAoY29uZmlnLCAnZWFjaEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25zdW1lckVhY2hCYXRjaFBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaE1lc3NhZ2VQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVhY2hNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wYWdhdGVkQ29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBwYXlsb2FkLm1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IHByb3BhZ2F0ZWRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShpbnN0cnVtZW50YXRpb24uX3Byb2Nlc3NEdXJhdGlvbiwgRGF0ZS5ub3coKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9jb25zdW1lZE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29uc3QgZWFjaE1lc3NhZ2VQcm9taXNlID0gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4ocHJvcGFnYXRlZENvbnRleHQsIHNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbc3Bhbl0sIHBlbmRpbmdNZXRyaWNzLCBlYWNoTWVzc2FnZVByb21pc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZWFjaEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vdHJhY2Uvc2VtYW50aWNfY29udmVudGlvbnMvbWVzc2FnaW5nLm1kI3RvcGljLXdpdGgtbXVsdGlwbGUtY29uc3VtZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2aW5nU3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogYXBpXzEuUk9PVF9DT05URVhULFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlRdOiBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVjZWl2aW5nU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX2NvbnN1bWVkTWVzc2FnZXMsIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMubGVuZ3RoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQuYmF0Y2gudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5iYXRjaC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BhZ2F0ZWRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIG1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbkNvbnRleHQgPSBhcGlfMS50cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTcGFuKHByb3BhZ2F0ZWRDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8uc3BhbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnU3Bhbkxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnU3BhbkxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IG9yaWdTcGFuTGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MucHVzaChwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0oaW5zdHJ1bWVudGF0aW9uLl9wcm9jZXNzRHVyYXRpb24sIHN0YXJ0VGltZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoTWVzc2FnZVByb21pc2UgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbnMudW5zaGlmdChyZWNlaXZpbmdTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBiYXRjaE1lc3NhZ2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclRyYW5zYWN0aW9uUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2FjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25TcGFuID0gaW5zdHJ1bWVudGF0aW9uLnRyYWNlci5zdGFydFNwYW4oJ3RyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Qcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNlbmQgPSB0cmFuc2FjdGlvbi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kID0gZnVuY3Rpb24gc2VuZCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgdHJhbnNhY3Rpb25TcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWQgPSBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKG9yaWdpbmFsU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQuYXBwbHkodGhpcywgYXJncykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2VuZEJhdGNoID0gdHJhbnNhY3Rpb24uc2VuZEJhdGNoO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kQmF0Y2ggPSBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHRyYW5zYWN0aW9uU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkID0gaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKG9yaWdpbmFsU2VuZEJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZC5hcHBseSh0aGlzLCBhcmdzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyPy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDb21taXQgPSB0cmFuc2FjdGlvbi5jb21taXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNvbW1pdCA9IGZ1bmN0aW9uIGNvbW1pdCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5Db21taXRQcm9taXNlID0gb3JpZ2luYWxDb21taXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLk9LIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbdHJhbnNhY3Rpb25TcGFuXSwgW10sIG9yaWdpbkNvbW1pdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEFib3J0ID0gdHJhbnNhY3Rpb24uYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luQWJvcnRQcm9taXNlID0gb3JpZ2luYWxBYm9ydC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2VuZFNwYW5zT25Qcm9taXNlKFt0cmFuc2FjdGlvblNwYW5dLCBbXSwgb3JpZ2luQWJvcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0U2VuZEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGJhdGNoLnRvcGljTWVzc2FnZXMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2godG9waWNNZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNNZXNzYWdlLm1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4odG9waWNNZXNzYWdlLnRvcGljLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTWV0cmljcy5wdXNoKHByZXBhcmVDb3VudGVyKGluc3RydW1lbnRhdGlvbi5fc2VudE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljTWVzc2FnZS50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4obWVzc2FnZS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRTZW5kUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gcmVjb3JkLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4ocmVjb3JkLnRvcGljLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IHJlY29yZC5tZXNzYWdlcy5tYXAobSA9PiBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX3NlbnRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiByZWNvcmQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIC4uLihtLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhtLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIHNlbmRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VuZFByb21pc2UpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgbGV0IGVycm9yVHlwZSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuRVJST1JfVFlQRV9WQUxVRV9PVEhFUjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyB8fCByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYXNvbiwgJ21lc3NhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZSA9IHJlYXNvbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oZXJyb3JUeXBlKSk7XG4gICAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvclR5cGUpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHNwYW4uZW5kKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0Q29uc3VtZXJTcGFuKHsgdG9waWMsIG1lc3NhZ2UsIG9wZXJhdGlvblR5cGUsIGN0eCwgbGluaywgYXR0cmlidXRlcywgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uVHlwZSA9PT0gc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFXG4gICAgICAgICAgICA/ICdwb2xsJyAvLyBmb3IgYmF0Y2ggcHJvY2Vzc2luZyBzcGFuc1xuICAgICAgICAgICAgOiBvcGVyYXRpb25UeXBlOyAvLyBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIHByb2Nlc3Npbmcgc3BhbnNcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihgJHtvcGVyYXRpb25OYW1lfSAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IG9wZXJhdGlvblR5cGUgPT09IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRVxuICAgICAgICAgICAgICAgID8gYXBpXzEuU3BhbktpbmQuQ0xJRU5UXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuS2luZC5DT05TVU1FUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRV06IG9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IG9wZXJhdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2U/LmtleVxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLmtleSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORV06IG1lc3NhZ2U/LmtleSAmJiBtZXNzYWdlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVF06IG1lc3NhZ2U/Lm9mZnNldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rczogbGluayA/IFtsaW5rXSA6IFtdLFxuICAgICAgICB9LCBjdHgpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVySG9vayB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKGNvbnN1bWVySG9vayAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZXJIb29rKHNwYW4sIHsgdG9waWMsIG1lc3NhZ2UgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmVycm9yKCdjb25zdW1lckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfc3RhcnRQcm9kdWNlclNwYW4odG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3Bhbihgc2VuZCAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlBST0RVQ0VSLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2Uua2V5XG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2Uua2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FXTogbWVzc2FnZS5rZXkgJiYgbWVzc2FnZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBtZXNzYWdlLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVdOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzID0gbWVzc2FnZS5oZWFkZXJzID8/IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSwgbWVzc2FnZS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgeyBwcm9kdWNlckhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChwcm9kdWNlckhvb2spIHtcbiAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwcm9kdWNlckhvb2soc3BhbiwgeyB0b3BpYywgbWVzc2FnZSB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZXJyb3IoJ3Byb2R1Y2VySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gS2Fma2FKc0luc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydW1lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nvar instrumentation_1 = __webpack_require__(/*! ./instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\");\nObject.defineProperty(exports, \"KafkaJsInstrumentation\", ({ enumerable: true, get: function () { return instrumentation_1.KafkaJsInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsd0JBQXdCLG1CQUFPLENBQUMsaU5BQW1CO0FBQ25ELDBEQUF5RCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNySiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb2xpZC1jb25uZWN0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xOC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL2luZGV4LmpzPzM1ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnMsIEFzcGVjdG9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xudmFyIGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIi4vaW5zdHJ1bWVudGF0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2Fma2FKc0luc3RydW1lbnRhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdHJ1bWVudGF0aW9uXzEuS2Fma2FKc0luc3RydW1lbnRhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EVENT_LISTENERS_SET = void 0;\nexports.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet');\n//# sourceMappingURL=internal-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnRlcm5hbC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW50ZXJuYWwtdHlwZXMuanM/MWEzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVWRU5UX0xJU1RFTkVSU19TRVQgPSB2b2lkIDA7XG5leHBvcnRzLkVWRU5UX0xJU1RFTkVSU19TRVQgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuaW5zdHJ1bWVudGF0aW9uLmthZmthanMuZXZlbnRMaXN0ZW5lcnNTZXQnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTextMapGetter = void 0;\n/*\nsame as open telemetry's `defaultTextMapGetter`,\nbut also handle case where header is buffer,\nadding toString() to make sure string is returned\n*/\nexports.bufferTextMapGetter = {\n    get(carrier, key) {\n        if (!carrier) {\n            return undefined;\n        }\n        const keys = Object.keys(carrier);\n        for (const carrierKey of keys) {\n            if (carrierKey === key || carrierKey.toLowerCase() === key) {\n                return carrier[carrierKey]?.toString();\n            }\n        }\n        return undefined;\n    },\n    keys(carrier) {\n        return carrier ? Object.keys(carrier) : [];\n    },\n};\n//# sourceMappingURL=propagator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9wcm9wYWdhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvcHJvcGFnYXRvci5qcz81NTRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZmZXJUZXh0TWFwR2V0dGVyID0gdm9pZCAwO1xuLypcbnNhbWUgYXMgb3BlbiB0ZWxlbWV0cnkncyBgZGVmYXVsdFRleHRNYXBHZXR0ZXJgLFxuYnV0IGFsc28gaGFuZGxlIGNhc2Ugd2hlcmUgaGVhZGVyIGlzIGJ1ZmZlcixcbmFkZGluZyB0b1N0cmluZygpIHRvIG1ha2Ugc3VyZSBzdHJpbmcgaXMgcmV0dXJuZWRcbiovXG5leHBvcnRzLmJ1ZmZlclRleHRNYXBHZXR0ZXIgPSB7XG4gICAgZ2V0KGNhcnJpZXIsIGtleSkge1xuICAgICAgICBpZiAoIWNhcnJpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNhcnJpZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNhcnJpZXJLZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKGNhcnJpZXJLZXkgPT09IGtleSB8fCBjYXJyaWVyS2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXJyaWVyW2NhcnJpZXJLZXldPy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBrZXlzKGNhcnJpZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhcnJpZXIgPyBPYmplY3Qua2V5cyhjYXJyaWVyKSA6IFtdO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGFnYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * The number of messages sent, received, or processed in the scope of the batching operation.\n *\n * @example 0\n * @example 1\n * @example 2\n *\n * @note Instrumentations **SHOULD NOT** set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations **SHOULD** use `messaging.batch.message_count` for batching APIs and **SHOULD NOT** use it for single-message APIs.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count';\n/**\n * The message destination name\n *\n * @example MyQueue\n * @example MyTopic\n *\n * @note Destination name **SHOULD** uniquely identify a specific queue, topic or other entity within the broker. If\n * the broker doesn't have such notion, the destination name **SHOULD** uniquely identify the broker.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name';\n/**\n * The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.\n *\n * @example \"1\"\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id';\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute **MUST NOT** be set.\n *\n * @example \"myKey\"\n *\n * @note If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key';\n/**\n * A boolean that is true if the message is a tombstone.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone';\n/**\n * The offset of a record in the corresponding Kafka partition.\n *\n * @example 42\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset';\n/**\n * The system-specific name of the messaging operation.\n *\n * @example ack\n * @example nack\n * @example send\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name';\n/**\n * A string identifying the type of the messaging operation.\n *\n * @note If a custom value is used, it **MUST** be of low cardinality.\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Enum value \"process\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process';\n/**\n * Enum value \"receive\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive';\n/**\n * Enum value \"send\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send';\n/**\n * Enum value \"kafka\" for attribute {@link ATTR_MESSAGING_SYSTEM}.\n */\nexports.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka';\n/**\n * Number of messages that were delivered to the application.\n *\n * @note Records the number of messages pulled from the broker or number of messages dispatched to the application in push-based scenarios.\n * The metric **SHOULD** be reported once per message delivery. For example, if receiving and processing operations are both instrumented for a single message delivery, this counter is incremented when the message is received and not reported when it is processed.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages';\n/**\n * Duration of messaging operation initiated by a producer or consumer client.\n *\n * @note This metric **SHOULD NOT** be used to report processing duration - processing duration is reported in `messaging.process.duration` metric.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration';\n/**\n * Number of messages producer attempted to send to the broker.\n *\n * @note This metric **MUST NOT** count messages that were created but haven't yet been sent.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages';\n/**\n * Duration of processing operation.\n *\n * @note This metric **MUST** be reported for operations with `messaging.operation.type` that matches `process`.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlDQUF5QyxHQUFHLDZDQUE2QyxHQUFHLGtEQUFrRCxHQUFHLGlEQUFpRCxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQyxHQUFHLDhDQUE4QyxHQUFHLDhDQUE4QyxHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQyxHQUFHLDhDQUE4QyxHQUFHLHdDQUF3QyxHQUFHLCtDQUErQyxHQUFHLHVDQUF1QyxHQUFHLDBDQUEwQztBQUNwdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUNBQXVDLG9DQUFvQztBQUMzRTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNvbGlkLWNvbm5lY3Qvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE4LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvc2VtY29udi5qcz8wN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19QUk9DRVNTX0RVUkFUSU9OID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9TRU5UX01FU1NBR0VTID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04gPSBleHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTID0gZXhwb3J0cy5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBID0gZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfU0VORCA9IGV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfT0ZGU0VUID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVkgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQkFUQ0hfTUVTU0FHRV9DT1VOVCA9IHZvaWQgMDtcbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYSBjb3B5IG9mIHVuc3RhYmxlIHNlbWFudGljIGNvbnZlbnRpb24gZGVmaW5pdGlvbnNcbiAqIHVzZWQgYnkgdGhpcyBwYWNrYWdlLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy90cmVlL21haW4vc2VtYW50aWMtY29udmVudGlvbnMjdW5zdGFibGUtc2VtY29udlxuICovXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgc2VudCwgcmVjZWl2ZWQsIG9yIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGJhdGNoaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSAwXG4gKiBAZXhhbXBsZSAxXG4gKiBAZXhhbXBsZSAyXG4gKlxuICogQG5vdGUgSW5zdHJ1bWVudGF0aW9ucyAqKlNIT1VMRCBOT1QqKiBzZXQgYG1lc3NhZ2luZy5iYXRjaC5tZXNzYWdlX2NvdW50YCBvbiBzcGFucyB0aGF0IG9wZXJhdGUgd2l0aCBhIHNpbmdsZSBtZXNzYWdlLiBXaGVuIGEgbWVzc2FnaW5nIGNsaWVudCBsaWJyYXJ5IHN1cHBvcnRzIGJvdGggYmF0Y2ggYW5kIHNpbmdsZS1tZXNzYWdlIEFQSSBmb3IgdGhlIHNhbWUgb3BlcmF0aW9uLCBpbnN0cnVtZW50YXRpb25zICoqU0hPVUxEKiogdXNlIGBtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudGAgZm9yIGJhdGNoaW5nIEFQSXMgYW5kICoqU0hPVUxEIE5PVCoqIHVzZSBpdCBmb3Igc2luZ2xlLW1lc3NhZ2UgQVBJcy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfQkFUQ0hfTUVTU0FHRV9DT1VOVCA9ICdtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudCc7XG4vKipcbiAqIFRoZSBtZXNzYWdlIGRlc3RpbmF0aW9uIG5hbWVcbiAqXG4gKiBAZXhhbXBsZSBNeVF1ZXVlXG4gKiBAZXhhbXBsZSBNeVRvcGljXG4gKlxuICogQG5vdGUgRGVzdGluYXRpb24gbmFtZSAqKlNIT1VMRCoqIHVuaXF1ZWx5IGlkZW50aWZ5IGEgc3BlY2lmaWMgcXVldWUsIHRvcGljIG9yIG90aGVyIGVudGl0eSB3aXRoaW4gdGhlIGJyb2tlci4gSWZcbiAqIHRoZSBicm9rZXIgZG9lc24ndCBoYXZlIHN1Y2ggbm90aW9uLCB0aGUgZGVzdGluYXRpb24gbmFtZSAqKlNIT1VMRCoqIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBicm9rZXIuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUUgPSAnbWVzc2FnaW5nLmRlc3RpbmF0aW9uLm5hbWUnO1xuLyoqXG4gKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcGFydGl0aW9uIG1lc3NhZ2VzIGFyZSBzZW50IHRvIG9yIHJlY2VpdmVkIGZyb20sIHVuaXF1ZSB3aXRoaW4gdGhlIGBtZXNzYWdpbmcuZGVzdGluYXRpb24ubmFtZWAuXG4gKlxuICogQGV4YW1wbGUgXCIxXCJcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbi5wYXJ0aXRpb24uaWQnO1xuLyoqXG4gKiBNZXNzYWdlIGtleXMgaW4gS2Fma2EgYXJlIHVzZWQgZm9yIGdyb3VwaW5nIGFsaWtlIG1lc3NhZ2VzIHRvIGVuc3VyZSB0aGV5J3JlIHByb2Nlc3NlZCBvbiB0aGUgc2FtZSBwYXJ0aXRpb24uIFRoZXkgZGlmZmVyIGZyb20gYG1lc3NhZ2luZy5tZXNzYWdlLmlkYCBpbiB0aGF0IHRoZXkncmUgbm90IHVuaXF1ZS4gSWYgdGhlIGtleSBpcyBgbnVsbGAsIHRoZSBhdHRyaWJ1dGUgKipNVVNUIE5PVCoqIGJlIHNldC5cbiAqXG4gKiBAZXhhbXBsZSBcIm15S2V5XCJcbiAqXG4gKiBAbm90ZSBJZiB0aGUga2V5IHR5cGUgaXMgbm90IHN0cmluZywgaXQncyBzdHJpbmcgcmVwcmVzZW50YXRpb24gaGFzIHRvIGJlIHN1cHBsaWVkIGZvciB0aGUgYXR0cmlidXRlLiBJZiB0aGUga2V5IGhhcyBubyB1bmFtYmlndW91cywgY2Fub25pY2FsIHN0cmluZyBmb3JtLCBkb24ndCBpbmNsdWRlIGl0cyB2YWx1ZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVkgPSAnbWVzc2FnaW5nLmthZmthLm1lc3NhZ2Uua2V5Jztcbi8qKlxuICogQSBib29sZWFuIHRoYXQgaXMgdHJ1ZSBpZiB0aGUgbWVzc2FnZSBpcyBhIHRvbWJzdG9uZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9UT01CU1RPTkUgPSAnbWVzc2FnaW5nLmthZmthLm1lc3NhZ2UudG9tYnN0b25lJztcbi8qKlxuICogVGhlIG9mZnNldCBvZiBhIHJlY29yZCBpbiB0aGUgY29ycmVzcG9uZGluZyBLYWZrYSBwYXJ0aXRpb24uXG4gKlxuICogQGV4YW1wbGUgNDJcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfT0ZGU0VUID0gJ21lc3NhZ2luZy5rYWZrYS5vZmZzZXQnO1xuLyoqXG4gKiBUaGUgc3lzdGVtLXNwZWNpZmljIG5hbWUgb2YgdGhlIG1lc3NhZ2luZyBvcGVyYXRpb24uXG4gKlxuICogQGV4YW1wbGUgYWNrXG4gKiBAZXhhbXBsZSBuYWNrXG4gKiBAZXhhbXBsZSBzZW5kXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FID0gJ21lc3NhZ2luZy5vcGVyYXRpb24ubmFtZSc7XG4vKipcbiAqIEEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIHRoZSBtZXNzYWdpbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBub3RlIElmIGEgY3VzdG9tIHZhbHVlIGlzIHVzZWQsIGl0ICoqTVVTVCoqIGJlIG9mIGxvdyBjYXJkaW5hbGl0eS5cbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRSA9ICdtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGUnO1xuLyoqXG4gKiBUaGUgbWVzc2FnaW5nIHN5c3RlbSBhcyBpZGVudGlmaWVkIGJ5IHRoZSBjbGllbnQgaW5zdHJ1bWVudGF0aW9uLlxuICpcbiAqIEBub3RlIFRoZSBhY3R1YWwgbWVzc2FnaW5nIHN5c3RlbSBtYXkgZGlmZmVyIGZyb20gdGhlIG9uZSBrbm93biBieSB0aGUgY2xpZW50LiBGb3IgZXhhbXBsZSwgd2hlbiB1c2luZyBLYWZrYSBjbGllbnQgbGlicmFyaWVzIHRvIGNvbW11bmljYXRlIHdpdGggQXp1cmUgRXZlbnQgSHVicywgdGhlIGBtZXNzYWdpbmcuc3lzdGVtYCBpcyBzZXQgdG8gYGthZmthYCBiYXNlZCBvbiB0aGUgaW5zdHJ1bWVudGF0aW9uJ3MgYmVzdCBrbm93bGVkZ2UuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX1NZU1RFTSA9ICdtZXNzYWdpbmcuc3lzdGVtJztcbi8qKlxuICogRW51bSB2YWx1ZSBcInByb2Nlc3NcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1BST0NFU1MgPSAncHJvY2Vzcyc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJyZWNlaXZlXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEV9LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFID0gJ3JlY2VpdmUnO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwic2VuZFwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfU0VORCA9ICdzZW5kJztcbi8qKlxuICogRW51bSB2YWx1ZSBcImthZmthXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfU1lTVEVNfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBID0gJ2thZmthJztcbi8qKlxuICogTnVtYmVyIG9mIG1lc3NhZ2VzIHRoYXQgd2VyZSBkZWxpdmVyZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBub3RlIFJlY29yZHMgdGhlIG51bWJlciBvZiBtZXNzYWdlcyBwdWxsZWQgZnJvbSB0aGUgYnJva2VyIG9yIG51bWJlciBvZiBtZXNzYWdlcyBkaXNwYXRjaGVkIHRvIHRoZSBhcHBsaWNhdGlvbiBpbiBwdXNoLWJhc2VkIHNjZW5hcmlvcy5cbiAqIFRoZSBtZXRyaWMgKipTSE9VTEQqKiBiZSByZXBvcnRlZCBvbmNlIHBlciBtZXNzYWdlIGRlbGl2ZXJ5LiBGb3IgZXhhbXBsZSwgaWYgcmVjZWl2aW5nIGFuZCBwcm9jZXNzaW5nIG9wZXJhdGlvbnMgYXJlIGJvdGggaW5zdHJ1bWVudGVkIGZvciBhIHNpbmdsZSBtZXNzYWdlIGRlbGl2ZXJ5LCB0aGlzIGNvdW50ZXIgaXMgaW5jcmVtZW50ZWQgd2hlbiB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCBhbmQgbm90IHJlcG9ydGVkIHdoZW4gaXQgaXMgcHJvY2Vzc2VkLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9DT05TVU1FRF9NRVNTQUdFUyA9ICdtZXNzYWdpbmcuY2xpZW50LmNvbnN1bWVkLm1lc3NhZ2VzJztcbi8qKlxuICogRHVyYXRpb24gb2YgbWVzc2FnaW5nIG9wZXJhdGlvbiBpbml0aWF0ZWQgYnkgYSBwcm9kdWNlciBvciBjb25zdW1lciBjbGllbnQuXG4gKlxuICogQG5vdGUgVGhpcyBtZXRyaWMgKipTSE9VTEQgTk9UKiogYmUgdXNlZCB0byByZXBvcnQgcHJvY2Vzc2luZyBkdXJhdGlvbiAtIHByb2Nlc3NpbmcgZHVyYXRpb24gaXMgcmVwb3J0ZWQgaW4gYG1lc3NhZ2luZy5wcm9jZXNzLmR1cmF0aW9uYCBtZXRyaWMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX09QRVJBVElPTl9EVVJBVElPTiA9ICdtZXNzYWdpbmcuY2xpZW50Lm9wZXJhdGlvbi5kdXJhdGlvbic7XG4vKipcbiAqIE51bWJlciBvZiBtZXNzYWdlcyBwcm9kdWNlciBhdHRlbXB0ZWQgdG8gc2VuZCB0byB0aGUgYnJva2VyLlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqTVVTVCBOT1QqKiBjb3VudCBtZXNzYWdlcyB0aGF0IHdlcmUgY3JlYXRlZCBidXQgaGF2ZW4ndCB5ZXQgYmVlbiBzZW50LlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9TRU5UX01FU1NBR0VTID0gJ21lc3NhZ2luZy5jbGllbnQuc2VudC5tZXNzYWdlcyc7XG4vKipcbiAqIER1cmF0aW9uIG9mIHByb2Nlc3Npbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqTVVTVCoqIGJlIHJlcG9ydGVkIGZvciBvcGVyYXRpb25zIHdpdGggYG1lc3NhZ2luZy5vcGVyYXRpb24udHlwZWAgdGhhdCBtYXRjaGVzIGBwcm9jZXNzYC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19QUk9DRVNTX0RVUkFUSU9OID0gJ21lc3NhZ2luZy5wcm9jZXNzLmR1cmF0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbWNvbnYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.18.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzPzExYTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC4xOC4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(";globalThis[\"_sentryRewritesTunnelPath\"] = undefined;globalThis[\"SENTRY_RELEASE\"] = undefined;globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryNextJsVersion\"] = \"14.2.35\";globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.39.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst internal_types_1 = __webpack_require__(/*! ./internal-types */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\");\nconst propagator_1 = __webpack_require__(/*! ./propagator */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\");\nfunction prepareCounter(meter, value, attributes) {\n    return (errorType) => {\n        meter.add(value, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nfunction prepareDurationHistogram(meter, value, attributes) {\n    return (errorType) => {\n        meter.record((Date.now() - value) / 1000, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nconst HISTOGRAM_BUCKET_BOUNDARIES = [\n    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,\n];\nclass KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    _updateMetricInstruments() {\n        this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n        this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);\n        this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);\n        this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n    }\n    init() {\n        const unpatch = (moduleExports) => {\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'producer');\n            }\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'consumer');\n            }\n        };\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('kafkajs', ['>=0.3.0 <3'], (moduleExports) => {\n            unpatch(moduleExports);\n            this._wrap(moduleExports?.Kafka?.prototype, 'producer', this._getProducerPatch());\n            this._wrap(moduleExports?.Kafka?.prototype, 'consumer', this._getConsumerPatch());\n            return moduleExports;\n        }, unpatch);\n        return module;\n    }\n    _getConsumerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newConsumer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {\n                    instrumentation._unwrap(newConsumer, 'run');\n                }\n                instrumentation._wrap(newConsumer, 'run', instrumentation._getConsumerRunPatch());\n                instrumentation._setKafkaEventListeners(newConsumer);\n                return newConsumer;\n            };\n        };\n    }\n    _setKafkaEventListeners(kafkaObj) {\n        if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])\n            return;\n        // The REQUEST Consumer event was added in kafkajs@1.5.0.\n        if (kafkaObj.events?.REQUEST) {\n            kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));\n        }\n        kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;\n    }\n    _recordClientDurationMetric(event) {\n        const [address, port] = event.payload.broker.split(':');\n        this._clientDuration.record(event.payload.duration / 1000, {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,\n            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,\n            [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10),\n        });\n    }\n    _getProducerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newProducer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {\n                    instrumentation._unwrap(newProducer, 'sendBatch');\n                }\n                instrumentation._wrap(newProducer, 'sendBatch', instrumentation._getSendBatchPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.send)) {\n                    instrumentation._unwrap(newProducer, 'send');\n                }\n                instrumentation._wrap(newProducer, 'send', instrumentation._getSendPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {\n                    instrumentation._unwrap(newProducer, 'transaction');\n                }\n                instrumentation._wrap(newProducer, 'transaction', instrumentation._getProducerTransactionPatch());\n                instrumentation._setKafkaEventListeners(newProducer);\n                return newProducer;\n            };\n        };\n    }\n    _getConsumerRunPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function run(...args) {\n                const config = args[0];\n                if (config?.eachMessage) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {\n                        instrumentation._unwrap(config, 'eachMessage');\n                    }\n                    instrumentation._wrap(config, 'eachMessage', instrumentation._getConsumerEachMessagePatch());\n                }\n                if (config?.eachBatch) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {\n                        instrumentation._unwrap(config, 'eachBatch');\n                    }\n                    instrumentation._wrap(config, 'eachBatch', instrumentation._getConsumerEachBatchPatch());\n                }\n                return original.call(this, config);\n            };\n        };\n    }\n    _getConsumerEachMessagePatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function eachMessage(...args) {\n                const payload = args[0];\n                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);\n                const span = instrumentation._startConsumerSpan({\n                    topic: payload.topic,\n                    message: payload.message,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                    ctx: propagatedContext,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    },\n                });\n                const pendingMetrics = [\n                    prepareDurationHistogram(instrumentation._processDuration, Date.now(), {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                    prepareCounter(instrumentation._consumedMessages, 1, {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                ];\n                const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {\n                    return original.apply(this, args);\n                });\n                return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);\n            };\n        };\n    }\n    _getConsumerEachBatchPatch() {\n        return (original) => {\n            const instrumentation = this;\n            return function eachBatch(...args) {\n                const payload = args[0];\n                // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n                const receivingSpan = instrumentation._startConsumerSpan({\n                    topic: payload.batch.topic,\n                    message: undefined,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,\n                    ctx: api_1.ROOT_CONTEXT,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                    },\n                });\n                return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {\n                    const startTime = Date.now();\n                    const spans = [];\n                    const pendingMetrics = [\n                        prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }),\n                    ];\n                    payload.batch.messages.forEach(message => {\n                        const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);\n                        const spanContext = api_1.trace\n                            .getSpan(propagatedContext)\n                            ?.spanContext();\n                        let origSpanLink;\n                        if (spanContext) {\n                            origSpanLink = {\n                                context: spanContext,\n                            };\n                        }\n                        spans.push(instrumentation._startConsumerSpan({\n                            topic: payload.batch.topic,\n                            message,\n                            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                            link: origSpanLink,\n                            attributes: {\n                                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                            },\n                        }));\n                        pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }));\n                    });\n                    const batchMessagePromise = original.apply(this, args);\n                    spans.unshift(receivingSpan);\n                    return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);\n                });\n            };\n        };\n    }\n    _getProducerTransactionPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function transaction(...args) {\n                const transactionSpan = instrumentation.tracer.startSpan('transaction');\n                const transactionPromise = original.apply(this, args);\n                transactionPromise\n                    .then((transaction) => {\n                    const originalSend = transaction.send;\n                    transaction.send = function send(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendPatch()(originalSend);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalSendBatch = transaction.sendBatch;\n                    transaction.sendBatch = function sendBatch(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendBatchPatch()(originalSendBatch);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalCommit = transaction.commit;\n                    transaction.commit = function commit(...args) {\n                        const originCommitPromise = originalCommit\n                            .apply(this, args)\n                            .then(() => {\n                            transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });\n                        });\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);\n                    };\n                    const originalAbort = transaction.abort;\n                    transaction.abort = function abort(...args) {\n                        const originAbortPromise = originalAbort.apply(this, args);\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);\n                    };\n                })\n                    .catch(err => {\n                    transactionSpan.setStatus({\n                        code: api_1.SpanStatusCode.ERROR,\n                        message: err?.message,\n                    });\n                    transactionSpan.recordException(err);\n                    transactionSpan.end();\n                });\n                return transactionPromise;\n            };\n        };\n    }\n    _getSendBatchPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function sendBatch(...args) {\n                const batch = args[0];\n                const messages = batch.topicMessages || [];\n                const spans = [];\n                const pendingMetrics = [];\n                messages.forEach(topicMessage => {\n                    topicMessage.messages.forEach(message => {\n                        spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));\n                        pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,\n                            ...(message.partition !== undefined\n                                ? {\n                                    [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition),\n                                }\n                                : {}),\n                        }));\n                    });\n                });\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _getSendPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function send(...args) {\n                const record = args[0];\n                const spans = record.messages.map(message => {\n                    return instrumentation._startProducerSpan(record.topic, message);\n                });\n                const pendingMetrics = record.messages.map(m => prepareCounter(instrumentation._sentMessages, 1, {\n                    [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                    [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                    [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,\n                    ...(m.partition !== undefined\n                        ? {\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition),\n                        }\n                        : {}),\n                }));\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {\n        return Promise.resolve(sendPromise)\n            .then(result => {\n            pendingMetrics.forEach(m => m());\n            return result;\n        })\n            .catch(reason => {\n            let errorMessage;\n            let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;\n            if (typeof reason === 'string' || reason === undefined) {\n                errorMessage = reason;\n            }\n            else if (typeof reason === 'object' &&\n                Object.prototype.hasOwnProperty.call(reason, 'message')) {\n                errorMessage = reason.message;\n                errorType = reason.constructor.name;\n            }\n            pendingMetrics.forEach(m => m(errorType));\n            spans.forEach(span => {\n                span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: errorMessage,\n                });\n            });\n            throw reason;\n        })\n            .finally(() => {\n            spans.forEach(span => span.end());\n        });\n    }\n    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes, }) {\n        const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n            ? 'poll' // for batch processing spans\n            : operationType; // for individual message processing spans\n        const span = this.tracer.startSpan(`${operationName} ${topic}`, {\n            kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n                ? api_1.SpanKind.CLIENT\n                : api_1.SpanKind.CONSUMER,\n            attributes: {\n                ...attributes,\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset,\n            },\n            links: link ? [link] : [],\n        }, ctx);\n        const { consumerHook } = this.getConfig();\n        if (consumerHook && message) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('consumerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n    _startProducerSpan(topic, message) {\n        const span = this.tracer.startSpan(`send ${topic}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined\n                    ? String(message.partition)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND,\n            },\n        });\n        message.headers = message.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);\n        const { producerHook } = this.getConfig();\n        if (producerHook) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('producerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n}\nexports.KafkaJsInstrumentation = KafkaJsInstrumentation;\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWEsQ0FBQyxvREFBb0QseUNBQXlDLDBDQUEwQywrQ0FBK0M7QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLHFNQUFnQztBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQywwTEFBcUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsK01BQWtCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLHVNQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaU1BQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELElBQUk7QUFDeEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0QsSUFBSTtBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxVQUFVLHlEQUF5RDtBQUNyTDtBQUNBO0FBQ0EsMEdBQTBHLFVBQVUseURBQXlEO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQkFBK0I7QUFDdkYseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4Q0FBOEMsZUFBZSxFQUFFLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTguMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanM/M2QzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjs7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlc1R1bm5lbFBhdGhcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIlNFTlRSWV9SRUxFQVNFXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJfc2VudHJ5QmFzZVBhdGhcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlOZXh0SnNWZXJzaW9uXCJdID0gXCIxNC4yLjM1XCI7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlRnJhbWVzRGlzdERpclwiXSA9IFwiLm5leHRcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkthZmthSnNJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgaW50ZXJuYWxfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsLXR5cGVzXCIpO1xuY29uc3QgcHJvcGFnYXRvcl8xID0gcmVxdWlyZShcIi4vcHJvcGFnYXRvclwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5mdW5jdGlvbiBwcmVwYXJlQ291bnRlcihtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5hZGQodmFsdWUsIHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi4oZXJyb3JUeXBlID8geyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0VSUk9SX1RZUEVdOiBlcnJvclR5cGUgfSA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5yZWNvcmQoKERhdGUubm93KCkgLSB2YWx1ZSkgLyAxMDAwLCB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4uKGVycm9yVHlwZSA/IHsgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXTogZXJyb3JUeXBlIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgPSBbXG4gICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSwgNy41LCAxMCxcbl07XG5jbGFzcyBLYWZrYUpzSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgY29uZmlnKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9jbGllbnREdXJhdGlvbiA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04sIHsgYWR2aWNlOiB7IGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTIH0gfSk7XG4gICAgICAgIHRoaXMuX3NlbnRNZXNzYWdlcyA9IHRoaXMubWV0ZXIuY3JlYXRlQ291bnRlcihzZW1jb252XzEuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyk7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkTWVzc2FnZXMgPSB0aGlzLm1ldGVyLmNyZWF0ZUNvdW50ZXIoc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0R1cmF0aW9uID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiwgeyBhZHZpY2U6IHsgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgfSB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgdW5wYXRjaCA9IChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZS5wcm9kdWNlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5LYWZrYS5wcm90b3R5cGUsICdwcm9kdWNlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHM/LkthZmthPy5wcm90b3R5cGUuY29uc3VtZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuS2Fma2EucHJvdG90eXBlLCAnY29uc3VtZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdrYWZrYWpzJywgWyc+PTAuMy4wIDwzJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICB1bnBhdGNoKG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAncHJvZHVjZXInLCB0aGlzLl9nZXRQcm9kdWNlclBhdGNoKCkpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAnY29uc3VtZXInLCB0aGlzLl9nZXRDb25zdW1lclBhdGNoKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIHVucGF0Y2gpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBfZ2V0Q29uc3VtZXJQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb25zdW1lciA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShuZXdDb25zdW1lci5ydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld0NvbnN1bWVyLCAncnVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdDb25zdW1lciwgJ3J1bicsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJSdW5QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3Q29uc3VtZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb25zdW1lcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKGthZmthT2JqKSB7XG4gICAgICAgIGlmIChrYWZrYU9ialtpbnRlcm5hbF90eXBlc18xLkVWRU5UX0xJU1RFTkVSU19TRVRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgUkVRVUVTVCBDb25zdW1lciBldmVudCB3YXMgYWRkZWQgaW4ga2Fma2Fqc0AxLjUuMC5cbiAgICAgICAgaWYgKGthZmthT2JqLmV2ZW50cz8uUkVRVUVTVCkge1xuICAgICAgICAgICAga2Fma2FPYmoub24oa2Fma2FPYmouZXZlbnRzLlJFUVVFU1QsIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uTWV0cmljLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGthZmthT2JqW2ludGVybmFsX3R5cGVzXzEuRVZFTlRfTElTVEVORVJTX1NFVF0gPSB0cnVlO1xuICAgIH1cbiAgICBfcmVjb3JkQ2xpZW50RHVyYXRpb25NZXRyaWMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3MsIHBvcnRdID0gZXZlbnQucGF5bG9hZC5icm9rZXIuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5fY2xpZW50RHVyYXRpb24ucmVjb3JkKGV2ZW50LnBheWxvYWQuZHVyYXRpb24gLyAxMDAwLCB7XG4gICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IGAke2V2ZW50LnBheWxvYWQuYXBpTmFtZX1gLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyLnBhcnNlSW50KHBvcnQsIDEwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZXIoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y2VyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnNlbmRCYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIuc2VuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3NlbmQnLCBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIudHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nLCBpbnN0cnVtZW50YXRpb24uX2dldFByb2R1Y2VyVHJhbnNhY3Rpb25QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3UHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9kdWNlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lclJ1blBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmVhY2hNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShjb25maWcuZWFjaE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChjb25maWcsICdlYWNoTWVzc2FnZScsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJFYWNoTWVzc2FnZVBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5lYWNoQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKGNvbmZpZy5lYWNoQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAoY29uZmlnLCAnZWFjaEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25zdW1lckVhY2hCYXRjaFBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaE1lc3NhZ2VQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVhY2hNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wYWdhdGVkQ29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBwYXlsb2FkLm1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IHByb3BhZ2F0ZWRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShpbnN0cnVtZW50YXRpb24uX3Byb2Nlc3NEdXJhdGlvbiwgRGF0ZS5ub3coKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9jb25zdW1lZE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29uc3QgZWFjaE1lc3NhZ2VQcm9taXNlID0gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4ocHJvcGFnYXRlZENvbnRleHQsIHNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbc3Bhbl0sIHBlbmRpbmdNZXRyaWNzLCBlYWNoTWVzc2FnZVByb21pc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZWFjaEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vdHJhY2Uvc2VtYW50aWNfY29udmVudGlvbnMvbWVzc2FnaW5nLm1kI3RvcGljLXdpdGgtbXVsdGlwbGUtY29uc3VtZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2aW5nU3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogYXBpXzEuUk9PVF9DT05URVhULFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlRdOiBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVjZWl2aW5nU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX2NvbnN1bWVkTWVzc2FnZXMsIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMubGVuZ3RoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQuYmF0Y2gudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5iYXRjaC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BhZ2F0ZWRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIG1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbkNvbnRleHQgPSBhcGlfMS50cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTcGFuKHByb3BhZ2F0ZWRDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8uc3BhbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnU3Bhbkxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnU3BhbkxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IG9yaWdTcGFuTGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MucHVzaChwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0oaW5zdHJ1bWVudGF0aW9uLl9wcm9jZXNzRHVyYXRpb24sIHN0YXJ0VGltZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoTWVzc2FnZVByb21pc2UgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbnMudW5zaGlmdChyZWNlaXZpbmdTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBiYXRjaE1lc3NhZ2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclRyYW5zYWN0aW9uUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2FjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25TcGFuID0gaW5zdHJ1bWVudGF0aW9uLnRyYWNlci5zdGFydFNwYW4oJ3RyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Qcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNlbmQgPSB0cmFuc2FjdGlvbi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kID0gZnVuY3Rpb24gc2VuZCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgdHJhbnNhY3Rpb25TcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWQgPSBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKG9yaWdpbmFsU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQuYXBwbHkodGhpcywgYXJncykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2VuZEJhdGNoID0gdHJhbnNhY3Rpb24uc2VuZEJhdGNoO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kQmF0Y2ggPSBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHRyYW5zYWN0aW9uU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkID0gaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKG9yaWdpbmFsU2VuZEJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZC5hcHBseSh0aGlzLCBhcmdzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyPy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDb21taXQgPSB0cmFuc2FjdGlvbi5jb21taXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNvbW1pdCA9IGZ1bmN0aW9uIGNvbW1pdCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5Db21taXRQcm9taXNlID0gb3JpZ2luYWxDb21taXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLk9LIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbdHJhbnNhY3Rpb25TcGFuXSwgW10sIG9yaWdpbkNvbW1pdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEFib3J0ID0gdHJhbnNhY3Rpb24uYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luQWJvcnRQcm9taXNlID0gb3JpZ2luYWxBYm9ydC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2VuZFNwYW5zT25Qcm9taXNlKFt0cmFuc2FjdGlvblNwYW5dLCBbXSwgb3JpZ2luQWJvcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0U2VuZEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGJhdGNoLnRvcGljTWVzc2FnZXMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2godG9waWNNZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNNZXNzYWdlLm1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4odG9waWNNZXNzYWdlLnRvcGljLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTWV0cmljcy5wdXNoKHByZXBhcmVDb3VudGVyKGluc3RydW1lbnRhdGlvbi5fc2VudE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljTWVzc2FnZS50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4obWVzc2FnZS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRTZW5kUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gcmVjb3JkLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4ocmVjb3JkLnRvcGljLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IHJlY29yZC5tZXNzYWdlcy5tYXAobSA9PiBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX3NlbnRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiByZWNvcmQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIC4uLihtLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhtLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIHNlbmRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VuZFByb21pc2UpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgbGV0IGVycm9yVHlwZSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuRVJST1JfVFlQRV9WQUxVRV9PVEhFUjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyB8fCByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYXNvbiwgJ21lc3NhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZSA9IHJlYXNvbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oZXJyb3JUeXBlKSk7XG4gICAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvclR5cGUpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHNwYW4uZW5kKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0Q29uc3VtZXJTcGFuKHsgdG9waWMsIG1lc3NhZ2UsIG9wZXJhdGlvblR5cGUsIGN0eCwgbGluaywgYXR0cmlidXRlcywgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uVHlwZSA9PT0gc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFXG4gICAgICAgICAgICA/ICdwb2xsJyAvLyBmb3IgYmF0Y2ggcHJvY2Vzc2luZyBzcGFuc1xuICAgICAgICAgICAgOiBvcGVyYXRpb25UeXBlOyAvLyBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIHByb2Nlc3Npbmcgc3BhbnNcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihgJHtvcGVyYXRpb25OYW1lfSAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IG9wZXJhdGlvblR5cGUgPT09IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRVxuICAgICAgICAgICAgICAgID8gYXBpXzEuU3BhbktpbmQuQ0xJRU5UXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuS2luZC5DT05TVU1FUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRV06IG9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IG9wZXJhdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2U/LmtleVxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLmtleSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORV06IG1lc3NhZ2U/LmtleSAmJiBtZXNzYWdlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVF06IG1lc3NhZ2U/Lm9mZnNldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rczogbGluayA/IFtsaW5rXSA6IFtdLFxuICAgICAgICB9LCBjdHgpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVySG9vayB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKGNvbnN1bWVySG9vayAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZXJIb29rKHNwYW4sIHsgdG9waWMsIG1lc3NhZ2UgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmVycm9yKCdjb25zdW1lckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfc3RhcnRQcm9kdWNlclNwYW4odG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3Bhbihgc2VuZCAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlBST0RVQ0VSLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2Uua2V5XG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2Uua2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FXTogbWVzc2FnZS5rZXkgJiYgbWVzc2FnZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBtZXNzYWdlLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVdOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzID0gbWVzc2FnZS5oZWFkZXJzID8/IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSwgbWVzc2FnZS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgeyBwcm9kdWNlckhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChwcm9kdWNlckhvb2spIHtcbiAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwcm9kdWNlckhvb2soc3BhbiwgeyB0b3BpYywgbWVzc2FnZSB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZXJyb3IoJ3Byb2R1Y2VySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gS2Fma2FKc0luc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydW1lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.18.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\n");

/***/ })

};
;