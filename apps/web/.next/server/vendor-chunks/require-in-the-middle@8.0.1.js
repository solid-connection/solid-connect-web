"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/require-in-the-middle@8.0.1";
exports.ids = ["vendor-chunks/require-in-the-middle@8.0.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst Module = __webpack_require__(/*! module */ \"module\")\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js\")('require-in-the-middle')\nconst moduleDetailsFromPath = __webpack_require__(/*! module-details-from-path */ \"(ssr)/../../node_modules/.pnpm/module-details-from-path@1.0.4/node_modules/module-details-from-path/index.js\")\n\n// Using the default export is discouraged, but kept for backward compatibility.\n// Use this instead:\n//    const { Hook } = require('require-in-the-middle')\nmodule.exports = Hook\nmodule.exports.Hook = Hook\n\nlet builtinModules // Set<string>\n\n/**\n * Is the given module a \"core\" module?\n * https://nodejs.org/api/modules.html#core-modules\n *\n * @type {(moduleName: string) => boolean}\n */\nlet isCore\nif (Module.isBuiltin) { // Added in node v18.6.0, v16.17.0\n  isCore = Module.isBuiltin\n} else if (Module.builtinModules) { // Added in node v9.3.0, v8.10.0, v6.13.0\n  isCore = moduleName => {\n    if (moduleName.startsWith('node:')) {\n      return true\n    }\n\n    if (builtinModules === undefined) {\n      builtinModules = new Set(Module.builtinModules)\n    }\n\n    return builtinModules.has(moduleName)\n  }\n} else {\n  throw new Error('\\'require-in-the-middle\\' requires Node.js >=v9.3.0 or >=v8.10.0')\n}\n\n// 'foo/bar.js' or 'foo/bar/index.js' => 'foo/bar'\nconst normalize = /([/\\\\]index)?(\\.js)?$/\n\n// Cache `onrequire`-patched exports for modules.\n//\n// Exports for built-in (a.k.a. \"core\") modules are stored in an internal Map.\n//\n// Exports for non-core modules are stored on a private field on the `Module`\n// object in `require.cache`. This allows users to delete from `require.cache`\n// to trigger a re-load (and re-run of the hook's `onrequire`) of a module the\n// next time it is required.\n// https://nodejs.org/docs/latest/api/all.html#all_modules_requirecache\n//\n// In some special cases -- e.g. some other `require()` hook swapping out\n// `Module._cache` like `@babel/register` -- a non-core module won't be in\n// `require.cache`. In that case this falls back to caching on the internal Map.\nclass ExportsCache {\n  constructor () {\n    this._localCache = new Map() // <module filename or id> -> <exports>\n    this._kRitmExports = Symbol('RitmExports')\n  }\n\n  has (filename, isBuiltin) {\n    if (this._localCache.has(filename)) {\n      return true\n    } else if (!isBuiltin) {\n      const mod = __webpack_require__.c[filename]\n      return !!(mod && this._kRitmExports in mod)\n    } else {\n      return false\n    }\n  }\n\n  get (filename, isBuiltin) {\n    const cachedExports = this._localCache.get(filename)\n    if (cachedExports !== undefined) {\n      return cachedExports\n    } else if (!isBuiltin) {\n      const mod = __webpack_require__.c[filename]\n      return (mod && mod[this._kRitmExports])\n    }\n  }\n\n  set (filename, exports, isBuiltin) {\n    if (isBuiltin) {\n      this._localCache.set(filename, exports)\n    } else if (filename in __webpack_require__.c) {\n      __webpack_require__.c[filename][this._kRitmExports] = exports\n    } else {\n      debug('non-core module is unexpectedly not in require.cache: \"%s\"', filename)\n      this._localCache.set(filename, exports)\n    }\n  }\n}\n\nfunction Hook (modules, options, onrequire) {\n  if ((this instanceof Hook) === false) return new Hook(modules, options, onrequire)\n  if (typeof modules === 'function') {\n    onrequire = modules\n    modules = null\n    options = null\n  } else if (typeof options === 'function') {\n    onrequire = options\n    options = null\n  }\n\n  if (typeof Module._resolveFilename !== 'function') {\n    console.error('Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!', typeof Module._resolveFilename)\n    console.error('Please report this error as an issue related to Node.js %s at https://github.com/nodejs/require-in-the-middle/issues', process.version)\n    return\n  }\n\n  this._cache = new ExportsCache()\n\n  this._unhooked = false\n  this._origRequire = Module.prototype.require\n\n  const self = this\n  const patching = new Set()\n  const internals = options ? options.internals === true : false\n  const hasWhitelist = Array.isArray(modules)\n\n  debug('registering require hook')\n\n  this._require = Module.prototype.require = function (id) {\n    if (self._unhooked === true) {\n      // if the patched require function could not be removed because\n      // someone else patched it after it was patched here, we just\n      // abort and pass the request onwards to the original require\n      debug('ignoring require call - module is soft-unhooked')\n      return self._origRequire.apply(this, arguments)\n    }\n\n    return patchedRequire.call(this, arguments, false)\n  }\n\n  if (typeof process.getBuiltinModule === 'function') {\n    this._origGetBuiltinModule = process.getBuiltinModule\n    this._getBuiltinModule = process.getBuiltinModule = function (id) {\n      if (self._unhooked === true) {\n        // if the patched process.getBuiltinModule function could not be removed because\n        // someone else patched it after it was patched here, we just abort and pass the\n        // request onwards to the original process.getBuiltinModule\n        debug('ignoring process.getBuiltinModule call - module is soft-unhooked')\n        return self._origGetBuiltinModule.apply(this, arguments)\n      }\n\n      return patchedRequire.call(this, arguments, true)\n    }\n  }\n\n  // Preserve the original require/process.getBuiltinModule arguments in `args`\n  function patchedRequire (args, coreOnly) {\n    const id = args[0]\n    const core = isCore(id)\n    let filename // the string used for caching\n    if (core) {\n      filename = id\n      // If this is a builtin module that can be identified both as 'foo' and\n      // 'node:foo', then prefer 'foo' as the caching key.\n      if (id.startsWith('node:')) {\n        const idWithoutPrefix = id.slice(5)\n        if (isCore(idWithoutPrefix)) {\n          filename = idWithoutPrefix\n        }\n      }\n    } else if (coreOnly) {\n      // `coreOnly` is `true` if this was a call to `process.getBuiltinModule`, in which case\n      // we don't want to return anything if the requested `id` isn't a core module. Falling\n      // back to default behaviour, which at the time of this wrting is simply returning `undefined`\n      debug('call to process.getBuiltinModule with unknown built-in id')\n      return self._origGetBuiltinModule.apply(this, args)\n    } else {\n      try {\n        filename = Module._resolveFilename(id, this)\n      } catch (resolveErr) {\n        // If someone *else* monkey-patches before this monkey-patch, then that\n        // code might expect `require(someId)` to get through so it can be\n        // handled, even if `someId` cannot be resolved to a filename. In this\n        // case, instead of throwing we defer to the underlying `require`.\n        //\n        // For example the Azure Functions Node.js worker module does this,\n        // where `@azure/functions-core` resolves to an internal object.\n        // https://github.com/Azure/azure-functions-nodejs-worker/blob/v3.5.2/src/setupCoreModule.ts#L46-L54\n        debug('Module._resolveFilename(\"%s\") threw %j, calling original Module.require', id, resolveErr.message)\n        return self._origRequire.apply(this, args)\n      }\n    }\n\n    let moduleName, basedir\n\n    debug('processing %s module require(\\'%s\\'): %s', core === true ? 'core' : 'non-core', id, filename)\n\n    // return known patched modules immediately\n    if (self._cache.has(filename, core) === true) {\n      debug('returning already patched cached module: %s', filename)\n      return self._cache.get(filename, core)\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    const isPatching = patching.has(filename)\n    if (isPatching === false) {\n      patching.add(filename)\n    }\n\n    const exports = coreOnly\n      ? self._origGetBuiltinModule.apply(this, args)\n      : self._origRequire.apply(this, args)\n\n    // If it's already patched, just return it as-is.\n    if (isPatching === true) {\n      debug('module is in the process of being patched already - ignoring: %s', filename)\n      return exports\n    }\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    patching.delete(filename)\n\n    if (core === true) {\n      if (hasWhitelist === true && modules.includes(filename) === false) {\n        debug('ignoring core module not on whitelist: %s', filename)\n        return exports // abort if module name isn't on whitelist\n      }\n      moduleName = filename\n    } else if (hasWhitelist === true && modules.includes(filename)) {\n      // whitelist includes the absolute path to the file including extension\n      const parsedPath = path.parse(filename)\n      moduleName = parsedPath.name\n      basedir = parsedPath.dir\n    } else {\n      const stat = moduleDetailsFromPath(filename)\n      if (stat === undefined) {\n        debug('could not parse filename: %s', filename)\n        return exports // abort if filename could not be parsed\n      }\n      moduleName = stat.name\n      basedir = stat.basedir\n\n      // Ex: require('foo/lib/../bar.js')\n      // moduleName = 'foo'\n      // fullModuleName = 'foo/bar'\n      const fullModuleName = resolveModuleName(stat)\n\n      debug('resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)', moduleName, id, fullModuleName, basedir)\n\n      let matchFound = false\n      if (hasWhitelist) {\n        if (!id.startsWith('.') && modules.includes(id)) {\n          // Not starting with '.' means `id` is identifying a module path,\n          // as opposed to a local file path. (Note: I'm not sure about\n          // absolute paths, but those are handled above.)\n          // If this `id` is in `modules`, then this could be a match to an\n          // package \"exports\" entry point that wouldn't otherwise match below.\n          moduleName = id\n          matchFound = true\n        }\n\n        // abort if module name isn't on whitelist\n        if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {\n          return exports\n        }\n\n        if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {\n          // if we get to this point, it means that we're requiring a whitelisted sub-module\n          moduleName = fullModuleName\n          matchFound = true\n        }\n      }\n\n      if (!matchFound) {\n        // figure out if this is the main module file, or a file inside the module\n        let res\n        try {\n          res = __webpack_require__(\"(ssr)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle sync recursive\").resolve(moduleName, { paths: [basedir] })\n        } catch (e) {\n          debug('could not resolve module: %s', moduleName)\n          self._cache.set(filename, exports, core)\n          return exports // abort if module could not be resolved (e.g. no main in package.json and no index.js file)\n        }\n\n        if (res !== filename) {\n          // this is a module-internal file\n          if (internals === true) {\n            // use the module-relative path to the file, prefixed by original module name\n            moduleName = moduleName + path.sep + path.relative(basedir, filename)\n            debug('preparing to process require of internal file: %s', moduleName)\n          } else {\n            debug('ignoring require of non-main module file: %s', res)\n            self._cache.set(filename, exports, core)\n            return exports // abort if not main module file\n          }\n        }\n      }\n    }\n\n    // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n    self._cache.set(filename, exports, core)\n    debug('calling require hook: %s', moduleName)\n    const patchedExports = onrequire(exports, moduleName, basedir)\n    self._cache.set(filename, patchedExports, core)\n\n    debug('returning module: %s', moduleName)\n    return patchedExports\n  }\n}\n\nHook.prototype.unhook = function () {\n  this._unhooked = true\n\n  if (this._require === Module.prototype.require) {\n    Module.prototype.require = this._origRequire\n    debug('require unhook successful')\n  } else {\n    debug('require unhook unsuccessful')\n  }\n\n  if (process.getBuiltinModule !== undefined) {\n    if (this._getBuiltinModule === process.getBuiltinModule) {\n      process.getBuiltinModule = this._origGetBuiltinModule\n      debug('process.getBuiltinModule unhook successful')\n    } else {\n      debug('process.getBuiltinModule unhook unsuccessful')\n    }\n  }\n}\n\nfunction resolveModuleName (stat) {\n  const normalizedPath = path.sep !== '/' ? stat.path.split(path.sep).join('/') : stat.path\n  return path.posix.join(stat.name, normalizedPath).replace(normalize, '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlcXVpcmUtaW4tdGhlLW1pZGRsZUA4LjAuMS9ub2RlX21vZHVsZXMvcmVxdWlyZS1pbi10aGUtbWlkZGxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHlGQUFPO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLDhJQUEwQjs7QUFFaEU7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEVBQUUsa0NBQWtDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixxQkFBYTtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLHFCQUFhO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQixxQkFBYTtBQUN4QyxNQUFNLHFCQUFhO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtSUFBTyx1QkFBdUIsa0JBQWtCO0FBQ2hFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlcXVpcmUtaW4tdGhlLW1pZGRsZUA4LjAuMS9ub2RlX21vZHVsZXMvcmVxdWlyZS1pbi10aGUtbWlkZGxlL2luZGV4LmpzPzZhZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IE1vZHVsZSA9IHJlcXVpcmUoJ21vZHVsZScpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3JlcXVpcmUtaW4tdGhlLW1pZGRsZScpXG5jb25zdCBtb2R1bGVEZXRhaWxzRnJvbVBhdGggPSByZXF1aXJlKCdtb2R1bGUtZGV0YWlscy1mcm9tLXBhdGgnKVxuXG4vLyBVc2luZyB0aGUgZGVmYXVsdCBleHBvcnQgaXMgZGlzY291cmFnZWQsIGJ1dCBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuLy8gVXNlIHRoaXMgaW5zdGVhZDpcbi8vICAgIGNvbnN0IHsgSG9vayB9ID0gcmVxdWlyZSgncmVxdWlyZS1pbi10aGUtbWlkZGxlJylcbm1vZHVsZS5leHBvcnRzID0gSG9va1xubW9kdWxlLmV4cG9ydHMuSG9vayA9IEhvb2tcblxubGV0IGJ1aWx0aW5Nb2R1bGVzIC8vIFNldDxzdHJpbmc+XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIG1vZHVsZSBhIFwiY29yZVwiIG1vZHVsZT9cbiAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbW9kdWxlcy5odG1sI2NvcmUtbW9kdWxlc1xuICpcbiAqIEB0eXBlIHsobW9kdWxlTmFtZTogc3RyaW5nKSA9PiBib29sZWFufVxuICovXG5sZXQgaXNDb3JlXG5pZiAoTW9kdWxlLmlzQnVpbHRpbikgeyAvLyBBZGRlZCBpbiBub2RlIHYxOC42LjAsIHYxNi4xNy4wXG4gIGlzQ29yZSA9IE1vZHVsZS5pc0J1aWx0aW5cbn0gZWxzZSBpZiAoTW9kdWxlLmJ1aWx0aW5Nb2R1bGVzKSB7IC8vIEFkZGVkIGluIG5vZGUgdjkuMy4wLCB2OC4xMC4wLCB2Ni4xMy4wXG4gIGlzQ29yZSA9IG1vZHVsZU5hbWUgPT4ge1xuICAgIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ25vZGU6JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGJ1aWx0aW5Nb2R1bGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1aWx0aW5Nb2R1bGVzID0gbmV3IFNldChNb2R1bGUuYnVpbHRpbk1vZHVsZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWx0aW5Nb2R1bGVzLmhhcyhtb2R1bGVOYW1lKVxuICB9XG59IGVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1xcJ3JlcXVpcmUtaW4tdGhlLW1pZGRsZVxcJyByZXF1aXJlcyBOb2RlLmpzID49djkuMy4wIG9yID49djguMTAuMCcpXG59XG5cbi8vICdmb28vYmFyLmpzJyBvciAnZm9vL2Jhci9pbmRleC5qcycgPT4gJ2Zvby9iYXInXG5jb25zdCBub3JtYWxpemUgPSAvKFsvXFxcXF1pbmRleCk/KFxcLmpzKT8kL1xuXG4vLyBDYWNoZSBgb25yZXF1aXJlYC1wYXRjaGVkIGV4cG9ydHMgZm9yIG1vZHVsZXMuXG4vL1xuLy8gRXhwb3J0cyBmb3IgYnVpbHQtaW4gKGEuay5hLiBcImNvcmVcIikgbW9kdWxlcyBhcmUgc3RvcmVkIGluIGFuIGludGVybmFsIE1hcC5cbi8vXG4vLyBFeHBvcnRzIGZvciBub24tY29yZSBtb2R1bGVzIGFyZSBzdG9yZWQgb24gYSBwcml2YXRlIGZpZWxkIG9uIHRoZSBgTW9kdWxlYFxuLy8gb2JqZWN0IGluIGByZXF1aXJlLmNhY2hlYC4gVGhpcyBhbGxvd3MgdXNlcnMgdG8gZGVsZXRlIGZyb20gYHJlcXVpcmUuY2FjaGVgXG4vLyB0byB0cmlnZ2VyIGEgcmUtbG9hZCAoYW5kIHJlLXJ1biBvZiB0aGUgaG9vaydzIGBvbnJlcXVpcmVgKSBvZiBhIG1vZHVsZSB0aGVcbi8vIG5leHQgdGltZSBpdCBpcyByZXF1aXJlZC5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvYWxsLmh0bWwjYWxsX21vZHVsZXNfcmVxdWlyZWNhY2hlXG4vL1xuLy8gSW4gc29tZSBzcGVjaWFsIGNhc2VzIC0tIGUuZy4gc29tZSBvdGhlciBgcmVxdWlyZSgpYCBob29rIHN3YXBwaW5nIG91dFxuLy8gYE1vZHVsZS5fY2FjaGVgIGxpa2UgYEBiYWJlbC9yZWdpc3RlcmAgLS0gYSBub24tY29yZSBtb2R1bGUgd29uJ3QgYmUgaW5cbi8vIGByZXF1aXJlLmNhY2hlYC4gSW4gdGhhdCBjYXNlIHRoaXMgZmFsbHMgYmFjayB0byBjYWNoaW5nIG9uIHRoZSBpbnRlcm5hbCBNYXAuXG5jbGFzcyBFeHBvcnRzQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fbG9jYWxDYWNoZSA9IG5ldyBNYXAoKSAvLyA8bW9kdWxlIGZpbGVuYW1lIG9yIGlkPiAtPiA8ZXhwb3J0cz5cbiAgICB0aGlzLl9rUml0bUV4cG9ydHMgPSBTeW1ib2woJ1JpdG1FeHBvcnRzJylcbiAgfVxuXG4gIGhhcyAoZmlsZW5hbWUsIGlzQnVpbHRpbikge1xuICAgIGlmICh0aGlzLl9sb2NhbENhY2hlLmhhcyhmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmICghaXNCdWlsdGluKSB7XG4gICAgICBjb25zdCBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVuYW1lXVxuICAgICAgcmV0dXJuICEhKG1vZCAmJiB0aGlzLl9rUml0bUV4cG9ydHMgaW4gbW9kKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBnZXQgKGZpbGVuYW1lLCBpc0J1aWx0aW4pIHtcbiAgICBjb25zdCBjYWNoZWRFeHBvcnRzID0gdGhpcy5fbG9jYWxDYWNoZS5nZXQoZmlsZW5hbWUpXG4gICAgaWYgKGNhY2hlZEV4cG9ydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEV4cG9ydHNcbiAgICB9IGVsc2UgaWYgKCFpc0J1aWx0aW4pIHtcbiAgICAgIGNvbnN0IG1vZCA9IHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdXG4gICAgICByZXR1cm4gKG1vZCAmJiBtb2RbdGhpcy5fa1JpdG1FeHBvcnRzXSlcbiAgICB9XG4gIH1cblxuICBzZXQgKGZpbGVuYW1lLCBleHBvcnRzLCBpc0J1aWx0aW4pIHtcbiAgICBpZiAoaXNCdWlsdGluKSB7XG4gICAgICB0aGlzLl9sb2NhbENhY2hlLnNldChmaWxlbmFtZSwgZXhwb3J0cylcbiAgICB9IGVsc2UgaWYgKGZpbGVuYW1lIGluIHJlcXVpcmUuY2FjaGUpIHtcbiAgICAgIHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdW3RoaXMuX2tSaXRtRXhwb3J0c10gPSBleHBvcnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdub24tY29yZSBtb2R1bGUgaXMgdW5leHBlY3RlZGx5IG5vdCBpbiByZXF1aXJlLmNhY2hlOiBcIiVzXCInLCBmaWxlbmFtZSlcbiAgICAgIHRoaXMuX2xvY2FsQ2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBIb29rIChtb2R1bGVzLCBvcHRpb25zLCBvbnJlcXVpcmUpIHtcbiAgaWYgKCh0aGlzIGluc3RhbmNlb2YgSG9vaykgPT09IGZhbHNlKSByZXR1cm4gbmV3IEhvb2sobW9kdWxlcywgb3B0aW9ucywgb25yZXF1aXJlKVxuICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbnJlcXVpcmUgPSBtb2R1bGVzXG4gICAgbW9kdWxlcyA9IG51bGxcbiAgICBvcHRpb25zID0gbnVsbFxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25yZXF1aXJlID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6IEV4cGVjdGVkIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lIHRvIGJlIGEgZnVuY3Rpb24gKHdhczogJXMpIC0gYWJvcnRpbmchJywgdHlwZW9mIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lKVxuICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSByZXBvcnQgdGhpcyBlcnJvciBhcyBhbiBpc3N1ZSByZWxhdGVkIHRvIE5vZGUuanMgJXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9yZXF1aXJlLWluLXRoZS1taWRkbGUvaXNzdWVzJywgcHJvY2Vzcy52ZXJzaW9uKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgRXhwb3J0c0NhY2hlKClcblxuICB0aGlzLl91bmhvb2tlZCA9IGZhbHNlXG4gIHRoaXMuX29yaWdSZXF1aXJlID0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgcGF0Y2hpbmcgPSBuZXcgU2V0KClcbiAgY29uc3QgaW50ZXJuYWxzID0gb3B0aW9ucyA/IG9wdGlvbnMuaW50ZXJuYWxzID09PSB0cnVlIDogZmFsc2VcbiAgY29uc3QgaGFzV2hpdGVsaXN0ID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKVxuXG4gIGRlYnVnKCdyZWdpc3RlcmluZyByZXF1aXJlIGhvb2snKVxuXG4gIHRoaXMuX3JlcXVpcmUgPSBNb2R1bGUucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoc2VsZi5fdW5ob29rZWQgPT09IHRydWUpIHtcbiAgICAgIC8vIGlmIHRoZSBwYXRjaGVkIHJlcXVpcmUgZnVuY3Rpb24gY291bGQgbm90IGJlIHJlbW92ZWQgYmVjYXVzZVxuICAgICAgLy8gc29tZW9uZSBlbHNlIHBhdGNoZWQgaXQgYWZ0ZXIgaXQgd2FzIHBhdGNoZWQgaGVyZSwgd2UganVzdFxuICAgICAgLy8gYWJvcnQgYW5kIHBhc3MgdGhlIHJlcXVlc3Qgb253YXJkcyB0byB0aGUgb3JpZ2luYWwgcmVxdWlyZVxuICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlcXVpcmUgY2FsbCAtIG1vZHVsZSBpcyBzb2Z0LXVuaG9va2VkJylcbiAgICAgIHJldHVybiBzZWxmLl9vcmlnUmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZWRSZXF1aXJlLmNhbGwodGhpcywgYXJndW1lbnRzLCBmYWxzZSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVcbiAgICB0aGlzLl9nZXRCdWlsdGluTW9kdWxlID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoc2VsZi5fdW5ob29rZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGNoZWQgcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIGZ1bmN0aW9uIGNvdWxkIG5vdCBiZSByZW1vdmVkIGJlY2F1c2VcbiAgICAgICAgLy8gc29tZW9uZSBlbHNlIHBhdGNoZWQgaXQgYWZ0ZXIgaXQgd2FzIHBhdGNoZWQgaGVyZSwgd2UganVzdCBhYm9ydCBhbmQgcGFzcyB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBvbndhcmRzIHRvIHRoZSBvcmlnaW5hbCBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZSBjYWxsIC0gbW9kdWxlIGlzIHNvZnQtdW5ob29rZWQnKVxuICAgICAgICByZXR1cm4gc2VsZi5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0Y2hlZFJlcXVpcmUuY2FsbCh0aGlzLCBhcmd1bWVudHMsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJlc2VydmUgdGhlIG9yaWdpbmFsIHJlcXVpcmUvcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIGFyZ3VtZW50cyBpbiBgYXJnc2BcbiAgZnVuY3Rpb24gcGF0Y2hlZFJlcXVpcmUgKGFyZ3MsIGNvcmVPbmx5KSB7XG4gICAgY29uc3QgaWQgPSBhcmdzWzBdXG4gICAgY29uc3QgY29yZSA9IGlzQ29yZShpZClcbiAgICBsZXQgZmlsZW5hbWUgLy8gdGhlIHN0cmluZyB1c2VkIGZvciBjYWNoaW5nXG4gICAgaWYgKGNvcmUpIHtcbiAgICAgIGZpbGVuYW1lID0gaWRcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBidWlsdGluIG1vZHVsZSB0aGF0IGNhbiBiZSBpZGVudGlmaWVkIGJvdGggYXMgJ2ZvbycgYW5kXG4gICAgICAvLyAnbm9kZTpmb28nLCB0aGVuIHByZWZlciAnZm9vJyBhcyB0aGUgY2FjaGluZyBrZXkuXG4gICAgICBpZiAoaWQuc3RhcnRzV2l0aCgnbm9kZTonKSkge1xuICAgICAgICBjb25zdCBpZFdpdGhvdXRQcmVmaXggPSBpZC5zbGljZSg1KVxuICAgICAgICBpZiAoaXNDb3JlKGlkV2l0aG91dFByZWZpeCkpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IGlkV2l0aG91dFByZWZpeFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb3JlT25seSkge1xuICAgICAgLy8gYGNvcmVPbmx5YCBpcyBgdHJ1ZWAgaWYgdGhpcyB3YXMgYSBjYWxsIHRvIGBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVgLCBpbiB3aGljaCBjYXNlXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHJldHVybiBhbnl0aGluZyBpZiB0aGUgcmVxdWVzdGVkIGBpZGAgaXNuJ3QgYSBjb3JlIG1vZHVsZS4gRmFsbGluZ1xuICAgICAgLy8gYmFjayB0byBkZWZhdWx0IGJlaGF2aW91ciwgd2hpY2ggYXQgdGhlIHRpbWUgb2YgdGhpcyB3cnRpbmcgaXMgc2ltcGx5IHJldHVybmluZyBgdW5kZWZpbmVkYFxuICAgICAgZGVidWcoJ2NhbGwgdG8gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIHdpdGggdW5rbm93biBidWlsdC1pbiBpZCcpXG4gICAgICByZXR1cm4gc2VsZi5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUuYXBwbHkodGhpcywgYXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZShpZCwgdGhpcylcbiAgICAgIH0gY2F0Y2ggKHJlc29sdmVFcnIpIHtcbiAgICAgICAgLy8gSWYgc29tZW9uZSAqZWxzZSogbW9ua2V5LXBhdGNoZXMgYmVmb3JlIHRoaXMgbW9ua2V5LXBhdGNoLCB0aGVuIHRoYXRcbiAgICAgICAgLy8gY29kZSBtaWdodCBleHBlY3QgYHJlcXVpcmUoc29tZUlkKWAgdG8gZ2V0IHRocm91Z2ggc28gaXQgY2FuIGJlXG4gICAgICAgIC8vIGhhbmRsZWQsIGV2ZW4gaWYgYHNvbWVJZGAgY2Fubm90IGJlIHJlc29sdmVkIHRvIGEgZmlsZW5hbWUuIEluIHRoaXNcbiAgICAgICAgLy8gY2FzZSwgaW5zdGVhZCBvZiB0aHJvd2luZyB3ZSBkZWZlciB0byB0aGUgdW5kZXJseWluZyBgcmVxdWlyZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBleGFtcGxlIHRoZSBBenVyZSBGdW5jdGlvbnMgTm9kZS5qcyB3b3JrZXIgbW9kdWxlIGRvZXMgdGhpcyxcbiAgICAgICAgLy8gd2hlcmUgYEBhenVyZS9mdW5jdGlvbnMtY29yZWAgcmVzb2x2ZXMgdG8gYW4gaW50ZXJuYWwgb2JqZWN0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXp1cmUvYXp1cmUtZnVuY3Rpb25zLW5vZGVqcy13b3JrZXIvYmxvYi92My41LjIvc3JjL3NldHVwQ29yZU1vZHVsZS50cyNMNDYtTDU0XG4gICAgICAgIGRlYnVnKCdNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZShcIiVzXCIpIHRocmV3ICVqLCBjYWxsaW5nIG9yaWdpbmFsIE1vZHVsZS5yZXF1aXJlJywgaWQsIHJlc29sdmVFcnIubWVzc2FnZSlcbiAgICAgICAgcmV0dXJuIHNlbGYuX29yaWdSZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1vZHVsZU5hbWUsIGJhc2VkaXJcblxuICAgIGRlYnVnKCdwcm9jZXNzaW5nICVzIG1vZHVsZSByZXF1aXJlKFxcJyVzXFwnKTogJXMnLCBjb3JlID09PSB0cnVlID8gJ2NvcmUnIDogJ25vbi1jb3JlJywgaWQsIGZpbGVuYW1lKVxuXG4gICAgLy8gcmV0dXJuIGtub3duIHBhdGNoZWQgbW9kdWxlcyBpbW1lZGlhdGVseVxuICAgIGlmIChzZWxmLl9jYWNoZS5oYXMoZmlsZW5hbWUsIGNvcmUpID09PSB0cnVlKSB7XG4gICAgICBkZWJ1ZygncmV0dXJuaW5nIGFscmVhZHkgcGF0Y2hlZCBjYWNoZWQgbW9kdWxlOiAlcycsIGZpbGVuYW1lKVxuICAgICAgcmV0dXJuIHNlbGYuX2NhY2hlLmdldChmaWxlbmFtZSwgY29yZSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIG1vZHVsZSBoYXMgYSBwYXRjaGVyIGluLXByb2dyZXNzIGFscmVhZHkuXG4gICAgLy8gT3RoZXJ3aXNlLCBtYXJrIHRoaXMgbW9kdWxlIGFzIHBhdGNoaW5nIGluLXByb2dyZXNzLlxuICAgIGNvbnN0IGlzUGF0Y2hpbmcgPSBwYXRjaGluZy5oYXMoZmlsZW5hbWUpXG4gICAgaWYgKGlzUGF0Y2hpbmcgPT09IGZhbHNlKSB7XG4gICAgICBwYXRjaGluZy5hZGQoZmlsZW5hbWUpXG4gICAgfVxuXG4gICAgY29uc3QgZXhwb3J0cyA9IGNvcmVPbmx5XG4gICAgICA/IHNlbGYuX29yaWdHZXRCdWlsdGluTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICA6IHNlbGYuX29yaWdSZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3MpXG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgcGF0Y2hlZCwganVzdCByZXR1cm4gaXQgYXMtaXMuXG4gICAgaWYgKGlzUGF0Y2hpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlYnVnKCdtb2R1bGUgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgcGF0Y2hlZCBhbHJlYWR5IC0gaWdub3Jpbmc6ICVzJywgZmlsZW5hbWUpXG4gICAgICByZXR1cm4gZXhwb3J0c1xuICAgIH1cblxuICAgIC8vIFRoZSBtb2R1bGUgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQsXG4gICAgLy8gc28gdGhlIHBhdGNoaW5nIG1hcmsgY2FuIGJlIGNsZWFuZWQgdXAuXG4gICAgcGF0Y2hpbmcuZGVsZXRlKGZpbGVuYW1lKVxuXG4gICAgaWYgKGNvcmUgPT09IHRydWUpIHtcbiAgICAgIGlmIChoYXNXaGl0ZWxpc3QgPT09IHRydWUgJiYgbW9kdWxlcy5pbmNsdWRlcyhmaWxlbmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBjb3JlIG1vZHVsZSBub3Qgb24gd2hpdGVsaXN0OiAlcycsIGZpbGVuYW1lKVxuICAgICAgICByZXR1cm4gZXhwb3J0cyAvLyBhYm9ydCBpZiBtb2R1bGUgbmFtZSBpc24ndCBvbiB3aGl0ZWxpc3RcbiAgICAgIH1cbiAgICAgIG1vZHVsZU5hbWUgPSBmaWxlbmFtZVxuICAgIH0gZWxzZSBpZiAoaGFzV2hpdGVsaXN0ID09PSB0cnVlICYmIG1vZHVsZXMuaW5jbHVkZXMoZmlsZW5hbWUpKSB7XG4gICAgICAvLyB3aGl0ZWxpc3QgaW5jbHVkZXMgdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUgaW5jbHVkaW5nIGV4dGVuc2lvblxuICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UoZmlsZW5hbWUpXG4gICAgICBtb2R1bGVOYW1lID0gcGFyc2VkUGF0aC5uYW1lXG4gICAgICBiYXNlZGlyID0gcGFyc2VkUGF0aC5kaXJcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdCA9IG1vZHVsZURldGFpbHNGcm9tUGF0aChmaWxlbmFtZSlcbiAgICAgIGlmIChzdGF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVidWcoJ2NvdWxkIG5vdCBwYXJzZSBmaWxlbmFtZTogJXMnLCBmaWxlbmFtZSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMgLy8gYWJvcnQgaWYgZmlsZW5hbWUgY291bGQgbm90IGJlIHBhcnNlZFxuICAgICAgfVxuICAgICAgbW9kdWxlTmFtZSA9IHN0YXQubmFtZVxuICAgICAgYmFzZWRpciA9IHN0YXQuYmFzZWRpclxuXG4gICAgICAvLyBFeDogcmVxdWlyZSgnZm9vL2xpYi8uLi9iYXIuanMnKVxuICAgICAgLy8gbW9kdWxlTmFtZSA9ICdmb28nXG4gICAgICAvLyBmdWxsTW9kdWxlTmFtZSA9ICdmb28vYmFyJ1xuICAgICAgY29uc3QgZnVsbE1vZHVsZU5hbWUgPSByZXNvbHZlTW9kdWxlTmFtZShzdGF0KVxuXG4gICAgICBkZWJ1ZygncmVzb2x2ZWQgZmlsZW5hbWUgdG8gbW9kdWxlOiAlcyAoaWQ6ICVzLCByZXNvbHZlZDogJXMsIGJhc2VkaXI6ICVzKScsIG1vZHVsZU5hbWUsIGlkLCBmdWxsTW9kdWxlTmFtZSwgYmFzZWRpcilcblxuICAgICAgbGV0IG1hdGNoRm91bmQgPSBmYWxzZVxuICAgICAgaWYgKGhhc1doaXRlbGlzdCkge1xuICAgICAgICBpZiAoIWlkLnN0YXJ0c1dpdGgoJy4nKSAmJiBtb2R1bGVzLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgIC8vIE5vdCBzdGFydGluZyB3aXRoICcuJyBtZWFucyBgaWRgIGlzIGlkZW50aWZ5aW5nIGEgbW9kdWxlIHBhdGgsXG4gICAgICAgICAgLy8gYXMgb3Bwb3NlZCB0byBhIGxvY2FsIGZpbGUgcGF0aC4gKE5vdGU6IEknbSBub3Qgc3VyZSBhYm91dFxuICAgICAgICAgIC8vIGFic29sdXRlIHBhdGhzLCBidXQgdGhvc2UgYXJlIGhhbmRsZWQgYWJvdmUuKVxuICAgICAgICAgIC8vIElmIHRoaXMgYGlkYCBpcyBpbiBgbW9kdWxlc2AsIHRoZW4gdGhpcyBjb3VsZCBiZSBhIG1hdGNoIHRvIGFuXG4gICAgICAgICAgLy8gcGFja2FnZSBcImV4cG9ydHNcIiBlbnRyeSBwb2ludCB0aGF0IHdvdWxkbid0IG90aGVyd2lzZSBtYXRjaCBiZWxvdy5cbiAgICAgICAgICBtb2R1bGVOYW1lID0gaWRcbiAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWJvcnQgaWYgbW9kdWxlIG5hbWUgaXNuJ3Qgb24gd2hpdGVsaXN0XG4gICAgICAgIGlmICghbW9kdWxlcy5pbmNsdWRlcyhtb2R1bGVOYW1lKSAmJiAhbW9kdWxlcy5pbmNsdWRlcyhmdWxsTW9kdWxlTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0c1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZHVsZXMuaW5jbHVkZXMoZnVsbE1vZHVsZU5hbWUpICYmIGZ1bGxNb2R1bGVOYW1lICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIGl0IG1lYW5zIHRoYXQgd2UncmUgcmVxdWlyaW5nIGEgd2hpdGVsaXN0ZWQgc3ViLW1vZHVsZVxuICAgICAgICAgIG1vZHVsZU5hbWUgPSBmdWxsTW9kdWxlTmFtZVxuICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaEZvdW5kKSB7XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyB0aGUgbWFpbiBtb2R1bGUgZmlsZSwgb3IgYSBmaWxlIGluc2lkZSB0aGUgbW9kdWxlXG4gICAgICAgIGxldCByZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSByZXF1aXJlLnJlc29sdmUobW9kdWxlTmFtZSwgeyBwYXRoczogW2Jhc2VkaXJdIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnY291bGQgbm90IHJlc29sdmUgbW9kdWxlOiAlcycsIG1vZHVsZU5hbWUpXG4gICAgICAgICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgICAgICAgIHJldHVybiBleHBvcnRzIC8vIGFib3J0IGlmIG1vZHVsZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQgKGUuZy4gbm8gbWFpbiBpbiBwYWNrYWdlLmpzb24gYW5kIG5vIGluZGV4LmpzIGZpbGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzICE9PSBmaWxlbmFtZSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBtb2R1bGUtaW50ZXJuYWwgZmlsZVxuICAgICAgICAgIGlmIChpbnRlcm5hbHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgbW9kdWxlLXJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUsIHByZWZpeGVkIGJ5IG9yaWdpbmFsIG1vZHVsZSBuYW1lXG4gICAgICAgICAgICBtb2R1bGVOYW1lID0gbW9kdWxlTmFtZSArIHBhdGguc2VwICsgcGF0aC5yZWxhdGl2ZShiYXNlZGlyLCBmaWxlbmFtZSlcbiAgICAgICAgICAgIGRlYnVnKCdwcmVwYXJpbmcgdG8gcHJvY2VzcyByZXF1aXJlIG9mIGludGVybmFsIGZpbGU6ICVzJywgbW9kdWxlTmFtZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlcXVpcmUgb2Ygbm9uLW1haW4gbW9kdWxlIGZpbGU6ICVzJywgcmVzKVxuICAgICAgICAgICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMgLy8gYWJvcnQgaWYgbm90IG1haW4gbW9kdWxlIGZpbGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgY2FjaGUgZW50cnkgaXMgYXNzaWduZWQgYSB2YWx1ZSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIG9ucmVxdWlyZSwgaW4gY2FzZSBjYWxsaW5nIG9ucmVxdWlyZSByZXF1aXJlcyB0aGUgc2FtZSBtb2R1bGUuXG4gICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgIGRlYnVnKCdjYWxsaW5nIHJlcXVpcmUgaG9vazogJXMnLCBtb2R1bGVOYW1lKVxuICAgIGNvbnN0IHBhdGNoZWRFeHBvcnRzID0gb25yZXF1aXJlKGV4cG9ydHMsIG1vZHVsZU5hbWUsIGJhc2VkaXIpXG4gICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBwYXRjaGVkRXhwb3J0cywgY29yZSlcblxuICAgIGRlYnVnKCdyZXR1cm5pbmcgbW9kdWxlOiAlcycsIG1vZHVsZU5hbWUpXG4gICAgcmV0dXJuIHBhdGNoZWRFeHBvcnRzXG4gIH1cbn1cblxuSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl91bmhvb2tlZCA9IHRydWVcblxuICBpZiAodGhpcy5fcmVxdWlyZSA9PT0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlKSB7XG4gICAgTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gdGhpcy5fb3JpZ1JlcXVpcmVcbiAgICBkZWJ1ZygncmVxdWlyZSB1bmhvb2sgc3VjY2Vzc2Z1bCcpXG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3JlcXVpcmUgdW5ob29rIHVuc3VjY2Vzc2Z1bCcpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5fZ2V0QnVpbHRpbk1vZHVsZSA9PT0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKSB7XG4gICAgICBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUgPSB0aGlzLl9vcmlnR2V0QnVpbHRpbk1vZHVsZVxuICAgICAgZGVidWcoJ3Byb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZSB1bmhvb2sgc3VjY2Vzc2Z1bCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUgdW5ob29rIHVuc3VjY2Vzc2Z1bCcpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2R1bGVOYW1lIChzdGF0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5zZXAgIT09ICcvJyA/IHN0YXQucGF0aC5zcGxpdChwYXRoLnNlcCkuam9pbignLycpIDogc3RhdC5wYXRoXG4gIHJldHVybiBwYXRoLnBvc2l4LmpvaW4oc3RhdC5uYW1lLCBub3JtYWxpemVkUGF0aCkucmVwbGFjZShub3JtYWxpemUsICcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst Module = __webpack_require__(/*! module */ \"module\")\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js\")('require-in-the-middle')\nconst moduleDetailsFromPath = __webpack_require__(/*! module-details-from-path */ \"(rsc)/../../node_modules/.pnpm/module-details-from-path@1.0.4/node_modules/module-details-from-path/index.js\")\n\n// Using the default export is discouraged, but kept for backward compatibility.\n// Use this instead:\n//    const { Hook } = require('require-in-the-middle')\nmodule.exports = Hook\nmodule.exports.Hook = Hook\n\nlet builtinModules // Set<string>\n\n/**\n * Is the given module a \"core\" module?\n * https://nodejs.org/api/modules.html#core-modules\n *\n * @type {(moduleName: string) => boolean}\n */\nlet isCore\nif (Module.isBuiltin) { // Added in node v18.6.0, v16.17.0\n  isCore = Module.isBuiltin\n} else if (Module.builtinModules) { // Added in node v9.3.0, v8.10.0, v6.13.0\n  isCore = moduleName => {\n    if (moduleName.startsWith('node:')) {\n      return true\n    }\n\n    if (builtinModules === undefined) {\n      builtinModules = new Set(Module.builtinModules)\n    }\n\n    return builtinModules.has(moduleName)\n  }\n} else {\n  throw new Error('\\'require-in-the-middle\\' requires Node.js >=v9.3.0 or >=v8.10.0')\n}\n\n// 'foo/bar.js' or 'foo/bar/index.js' => 'foo/bar'\nconst normalize = /([/\\\\]index)?(\\.js)?$/\n\n// Cache `onrequire`-patched exports for modules.\n//\n// Exports for built-in (a.k.a. \"core\") modules are stored in an internal Map.\n//\n// Exports for non-core modules are stored on a private field on the `Module`\n// object in `require.cache`. This allows users to delete from `require.cache`\n// to trigger a re-load (and re-run of the hook's `onrequire`) of a module the\n// next time it is required.\n// https://nodejs.org/docs/latest/api/all.html#all_modules_requirecache\n//\n// In some special cases -- e.g. some other `require()` hook swapping out\n// `Module._cache` like `@babel/register` -- a non-core module won't be in\n// `require.cache`. In that case this falls back to caching on the internal Map.\nclass ExportsCache {\n  constructor () {\n    this._localCache = new Map() // <module filename or id> -> <exports>\n    this._kRitmExports = Symbol('RitmExports')\n  }\n\n  has (filename, isBuiltin) {\n    if (this._localCache.has(filename)) {\n      return true\n    } else if (!isBuiltin) {\n      const mod = __webpack_require__.c[filename]\n      return !!(mod && this._kRitmExports in mod)\n    } else {\n      return false\n    }\n  }\n\n  get (filename, isBuiltin) {\n    const cachedExports = this._localCache.get(filename)\n    if (cachedExports !== undefined) {\n      return cachedExports\n    } else if (!isBuiltin) {\n      const mod = __webpack_require__.c[filename]\n      return (mod && mod[this._kRitmExports])\n    }\n  }\n\n  set (filename, exports, isBuiltin) {\n    if (isBuiltin) {\n      this._localCache.set(filename, exports)\n    } else if (filename in __webpack_require__.c) {\n      __webpack_require__.c[filename][this._kRitmExports] = exports\n    } else {\n      debug('non-core module is unexpectedly not in require.cache: \"%s\"', filename)\n      this._localCache.set(filename, exports)\n    }\n  }\n}\n\nfunction Hook (modules, options, onrequire) {\n  if ((this instanceof Hook) === false) return new Hook(modules, options, onrequire)\n  if (typeof modules === 'function') {\n    onrequire = modules\n    modules = null\n    options = null\n  } else if (typeof options === 'function') {\n    onrequire = options\n    options = null\n  }\n\n  if (typeof Module._resolveFilename !== 'function') {\n    console.error('Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!', typeof Module._resolveFilename)\n    console.error('Please report this error as an issue related to Node.js %s at https://github.com/nodejs/require-in-the-middle/issues', process.version)\n    return\n  }\n\n  this._cache = new ExportsCache()\n\n  this._unhooked = false\n  this._origRequire = Module.prototype.require\n\n  const self = this\n  const patching = new Set()\n  const internals = options ? options.internals === true : false\n  const hasWhitelist = Array.isArray(modules)\n\n  debug('registering require hook')\n\n  this._require = Module.prototype.require = function (id) {\n    if (self._unhooked === true) {\n      // if the patched require function could not be removed because\n      // someone else patched it after it was patched here, we just\n      // abort and pass the request onwards to the original require\n      debug('ignoring require call - module is soft-unhooked')\n      return self._origRequire.apply(this, arguments)\n    }\n\n    return patchedRequire.call(this, arguments, false)\n  }\n\n  if (typeof process.getBuiltinModule === 'function') {\n    this._origGetBuiltinModule = process.getBuiltinModule\n    this._getBuiltinModule = process.getBuiltinModule = function (id) {\n      if (self._unhooked === true) {\n        // if the patched process.getBuiltinModule function could not be removed because\n        // someone else patched it after it was patched here, we just abort and pass the\n        // request onwards to the original process.getBuiltinModule\n        debug('ignoring process.getBuiltinModule call - module is soft-unhooked')\n        return self._origGetBuiltinModule.apply(this, arguments)\n      }\n\n      return patchedRequire.call(this, arguments, true)\n    }\n  }\n\n  // Preserve the original require/process.getBuiltinModule arguments in `args`\n  function patchedRequire (args, coreOnly) {\n    const id = args[0]\n    const core = isCore(id)\n    let filename // the string used for caching\n    if (core) {\n      filename = id\n      // If this is a builtin module that can be identified both as 'foo' and\n      // 'node:foo', then prefer 'foo' as the caching key.\n      if (id.startsWith('node:')) {\n        const idWithoutPrefix = id.slice(5)\n        if (isCore(idWithoutPrefix)) {\n          filename = idWithoutPrefix\n        }\n      }\n    } else if (coreOnly) {\n      // `coreOnly` is `true` if this was a call to `process.getBuiltinModule`, in which case\n      // we don't want to return anything if the requested `id` isn't a core module. Falling\n      // back to default behaviour, which at the time of this wrting is simply returning `undefined`\n      debug('call to process.getBuiltinModule with unknown built-in id')\n      return self._origGetBuiltinModule.apply(this, args)\n    } else {\n      try {\n        filename = Module._resolveFilename(id, this)\n      } catch (resolveErr) {\n        // If someone *else* monkey-patches before this monkey-patch, then that\n        // code might expect `require(someId)` to get through so it can be\n        // handled, even if `someId` cannot be resolved to a filename. In this\n        // case, instead of throwing we defer to the underlying `require`.\n        //\n        // For example the Azure Functions Node.js worker module does this,\n        // where `@azure/functions-core` resolves to an internal object.\n        // https://github.com/Azure/azure-functions-nodejs-worker/blob/v3.5.2/src/setupCoreModule.ts#L46-L54\n        debug('Module._resolveFilename(\"%s\") threw %j, calling original Module.require', id, resolveErr.message)\n        return self._origRequire.apply(this, args)\n      }\n    }\n\n    let moduleName, basedir\n\n    debug('processing %s module require(\\'%s\\'): %s', core === true ? 'core' : 'non-core', id, filename)\n\n    // return known patched modules immediately\n    if (self._cache.has(filename, core) === true) {\n      debug('returning already patched cached module: %s', filename)\n      return self._cache.get(filename, core)\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    const isPatching = patching.has(filename)\n    if (isPatching === false) {\n      patching.add(filename)\n    }\n\n    const exports = coreOnly\n      ? self._origGetBuiltinModule.apply(this, args)\n      : self._origRequire.apply(this, args)\n\n    // If it's already patched, just return it as-is.\n    if (isPatching === true) {\n      debug('module is in the process of being patched already - ignoring: %s', filename)\n      return exports\n    }\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    patching.delete(filename)\n\n    if (core === true) {\n      if (hasWhitelist === true && modules.includes(filename) === false) {\n        debug('ignoring core module not on whitelist: %s', filename)\n        return exports // abort if module name isn't on whitelist\n      }\n      moduleName = filename\n    } else if (hasWhitelist === true && modules.includes(filename)) {\n      // whitelist includes the absolute path to the file including extension\n      const parsedPath = path.parse(filename)\n      moduleName = parsedPath.name\n      basedir = parsedPath.dir\n    } else {\n      const stat = moduleDetailsFromPath(filename)\n      if (stat === undefined) {\n        debug('could not parse filename: %s', filename)\n        return exports // abort if filename could not be parsed\n      }\n      moduleName = stat.name\n      basedir = stat.basedir\n\n      // Ex: require('foo/lib/../bar.js')\n      // moduleName = 'foo'\n      // fullModuleName = 'foo/bar'\n      const fullModuleName = resolveModuleName(stat)\n\n      debug('resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)', moduleName, id, fullModuleName, basedir)\n\n      let matchFound = false\n      if (hasWhitelist) {\n        if (!id.startsWith('.') && modules.includes(id)) {\n          // Not starting with '.' means `id` is identifying a module path,\n          // as opposed to a local file path. (Note: I'm not sure about\n          // absolute paths, but those are handled above.)\n          // If this `id` is in `modules`, then this could be a match to an\n          // package \"exports\" entry point that wouldn't otherwise match below.\n          moduleName = id\n          matchFound = true\n        }\n\n        // abort if module name isn't on whitelist\n        if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {\n          return exports\n        }\n\n        if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {\n          // if we get to this point, it means that we're requiring a whitelisted sub-module\n          moduleName = fullModuleName\n          matchFound = true\n        }\n      }\n\n      if (!matchFound) {\n        // figure out if this is the main module file, or a file inside the module\n        let res\n        try {\n          res = __webpack_require__(\"(rsc)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle sync recursive\").resolve(moduleName, { paths: [basedir] })\n        } catch (e) {\n          debug('could not resolve module: %s', moduleName)\n          self._cache.set(filename, exports, core)\n          return exports // abort if module could not be resolved (e.g. no main in package.json and no index.js file)\n        }\n\n        if (res !== filename) {\n          // this is a module-internal file\n          if (internals === true) {\n            // use the module-relative path to the file, prefixed by original module name\n            moduleName = moduleName + path.sep + path.relative(basedir, filename)\n            debug('preparing to process require of internal file: %s', moduleName)\n          } else {\n            debug('ignoring require of non-main module file: %s', res)\n            self._cache.set(filename, exports, core)\n            return exports // abort if not main module file\n          }\n        }\n      }\n    }\n\n    // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n    self._cache.set(filename, exports, core)\n    debug('calling require hook: %s', moduleName)\n    const patchedExports = onrequire(exports, moduleName, basedir)\n    self._cache.set(filename, patchedExports, core)\n\n    debug('returning module: %s', moduleName)\n    return patchedExports\n  }\n}\n\nHook.prototype.unhook = function () {\n  this._unhooked = true\n\n  if (this._require === Module.prototype.require) {\n    Module.prototype.require = this._origRequire\n    debug('require unhook successful')\n  } else {\n    debug('require unhook unsuccessful')\n  }\n\n  if (process.getBuiltinModule !== undefined) {\n    if (this._getBuiltinModule === process.getBuiltinModule) {\n      process.getBuiltinModule = this._origGetBuiltinModule\n      debug('process.getBuiltinModule unhook successful')\n    } else {\n      debug('process.getBuiltinModule unhook unsuccessful')\n    }\n  }\n}\n\nfunction resolveModuleName (stat) {\n  const normalizedPath = path.sep !== '/' ? stat.path.split(path.sep).join('/') : stat.path\n  return path.posix.join(stat.name, normalizedPath).replace(normalize, '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlcXVpcmUtaW4tdGhlLW1pZGRsZUA4LjAuMS9ub2RlX21vZHVsZXMvcmVxdWlyZS1pbi10aGUtbWlkZGxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHlGQUFPO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLDhJQUEwQjs7QUFFaEU7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEVBQUUsa0NBQWtDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixxQkFBYTtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLHFCQUFhO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQixxQkFBYTtBQUN4QyxNQUFNLHFCQUFhO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtSUFBTyx1QkFBdUIsa0JBQWtCO0FBQ2hFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29saWQtY29ubmVjdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlcXVpcmUtaW4tdGhlLW1pZGRsZUA4LjAuMS9ub2RlX21vZHVsZXMvcmVxdWlyZS1pbi10aGUtbWlkZGxlL2luZGV4LmpzPzEyMzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IE1vZHVsZSA9IHJlcXVpcmUoJ21vZHVsZScpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3JlcXVpcmUtaW4tdGhlLW1pZGRsZScpXG5jb25zdCBtb2R1bGVEZXRhaWxzRnJvbVBhdGggPSByZXF1aXJlKCdtb2R1bGUtZGV0YWlscy1mcm9tLXBhdGgnKVxuXG4vLyBVc2luZyB0aGUgZGVmYXVsdCBleHBvcnQgaXMgZGlzY291cmFnZWQsIGJ1dCBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuLy8gVXNlIHRoaXMgaW5zdGVhZDpcbi8vICAgIGNvbnN0IHsgSG9vayB9ID0gcmVxdWlyZSgncmVxdWlyZS1pbi10aGUtbWlkZGxlJylcbm1vZHVsZS5leHBvcnRzID0gSG9va1xubW9kdWxlLmV4cG9ydHMuSG9vayA9IEhvb2tcblxubGV0IGJ1aWx0aW5Nb2R1bGVzIC8vIFNldDxzdHJpbmc+XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIG1vZHVsZSBhIFwiY29yZVwiIG1vZHVsZT9cbiAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbW9kdWxlcy5odG1sI2NvcmUtbW9kdWxlc1xuICpcbiAqIEB0eXBlIHsobW9kdWxlTmFtZTogc3RyaW5nKSA9PiBib29sZWFufVxuICovXG5sZXQgaXNDb3JlXG5pZiAoTW9kdWxlLmlzQnVpbHRpbikgeyAvLyBBZGRlZCBpbiBub2RlIHYxOC42LjAsIHYxNi4xNy4wXG4gIGlzQ29yZSA9IE1vZHVsZS5pc0J1aWx0aW5cbn0gZWxzZSBpZiAoTW9kdWxlLmJ1aWx0aW5Nb2R1bGVzKSB7IC8vIEFkZGVkIGluIG5vZGUgdjkuMy4wLCB2OC4xMC4wLCB2Ni4xMy4wXG4gIGlzQ29yZSA9IG1vZHVsZU5hbWUgPT4ge1xuICAgIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ25vZGU6JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGJ1aWx0aW5Nb2R1bGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1aWx0aW5Nb2R1bGVzID0gbmV3IFNldChNb2R1bGUuYnVpbHRpbk1vZHVsZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWx0aW5Nb2R1bGVzLmhhcyhtb2R1bGVOYW1lKVxuICB9XG59IGVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1xcJ3JlcXVpcmUtaW4tdGhlLW1pZGRsZVxcJyByZXF1aXJlcyBOb2RlLmpzID49djkuMy4wIG9yID49djguMTAuMCcpXG59XG5cbi8vICdmb28vYmFyLmpzJyBvciAnZm9vL2Jhci9pbmRleC5qcycgPT4gJ2Zvby9iYXInXG5jb25zdCBub3JtYWxpemUgPSAvKFsvXFxcXF1pbmRleCk/KFxcLmpzKT8kL1xuXG4vLyBDYWNoZSBgb25yZXF1aXJlYC1wYXRjaGVkIGV4cG9ydHMgZm9yIG1vZHVsZXMuXG4vL1xuLy8gRXhwb3J0cyBmb3IgYnVpbHQtaW4gKGEuay5hLiBcImNvcmVcIikgbW9kdWxlcyBhcmUgc3RvcmVkIGluIGFuIGludGVybmFsIE1hcC5cbi8vXG4vLyBFeHBvcnRzIGZvciBub24tY29yZSBtb2R1bGVzIGFyZSBzdG9yZWQgb24gYSBwcml2YXRlIGZpZWxkIG9uIHRoZSBgTW9kdWxlYFxuLy8gb2JqZWN0IGluIGByZXF1aXJlLmNhY2hlYC4gVGhpcyBhbGxvd3MgdXNlcnMgdG8gZGVsZXRlIGZyb20gYHJlcXVpcmUuY2FjaGVgXG4vLyB0byB0cmlnZ2VyIGEgcmUtbG9hZCAoYW5kIHJlLXJ1biBvZiB0aGUgaG9vaydzIGBvbnJlcXVpcmVgKSBvZiBhIG1vZHVsZSB0aGVcbi8vIG5leHQgdGltZSBpdCBpcyByZXF1aXJlZC5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvYWxsLmh0bWwjYWxsX21vZHVsZXNfcmVxdWlyZWNhY2hlXG4vL1xuLy8gSW4gc29tZSBzcGVjaWFsIGNhc2VzIC0tIGUuZy4gc29tZSBvdGhlciBgcmVxdWlyZSgpYCBob29rIHN3YXBwaW5nIG91dFxuLy8gYE1vZHVsZS5fY2FjaGVgIGxpa2UgYEBiYWJlbC9yZWdpc3RlcmAgLS0gYSBub24tY29yZSBtb2R1bGUgd29uJ3QgYmUgaW5cbi8vIGByZXF1aXJlLmNhY2hlYC4gSW4gdGhhdCBjYXNlIHRoaXMgZmFsbHMgYmFjayB0byBjYWNoaW5nIG9uIHRoZSBpbnRlcm5hbCBNYXAuXG5jbGFzcyBFeHBvcnRzQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fbG9jYWxDYWNoZSA9IG5ldyBNYXAoKSAvLyA8bW9kdWxlIGZpbGVuYW1lIG9yIGlkPiAtPiA8ZXhwb3J0cz5cbiAgICB0aGlzLl9rUml0bUV4cG9ydHMgPSBTeW1ib2woJ1JpdG1FeHBvcnRzJylcbiAgfVxuXG4gIGhhcyAoZmlsZW5hbWUsIGlzQnVpbHRpbikge1xuICAgIGlmICh0aGlzLl9sb2NhbENhY2hlLmhhcyhmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmICghaXNCdWlsdGluKSB7XG4gICAgICBjb25zdCBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVuYW1lXVxuICAgICAgcmV0dXJuICEhKG1vZCAmJiB0aGlzLl9rUml0bUV4cG9ydHMgaW4gbW9kKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBnZXQgKGZpbGVuYW1lLCBpc0J1aWx0aW4pIHtcbiAgICBjb25zdCBjYWNoZWRFeHBvcnRzID0gdGhpcy5fbG9jYWxDYWNoZS5nZXQoZmlsZW5hbWUpXG4gICAgaWYgKGNhY2hlZEV4cG9ydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEV4cG9ydHNcbiAgICB9IGVsc2UgaWYgKCFpc0J1aWx0aW4pIHtcbiAgICAgIGNvbnN0IG1vZCA9IHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdXG4gICAgICByZXR1cm4gKG1vZCAmJiBtb2RbdGhpcy5fa1JpdG1FeHBvcnRzXSlcbiAgICB9XG4gIH1cblxuICBzZXQgKGZpbGVuYW1lLCBleHBvcnRzLCBpc0J1aWx0aW4pIHtcbiAgICBpZiAoaXNCdWlsdGluKSB7XG4gICAgICB0aGlzLl9sb2NhbENhY2hlLnNldChmaWxlbmFtZSwgZXhwb3J0cylcbiAgICB9IGVsc2UgaWYgKGZpbGVuYW1lIGluIHJlcXVpcmUuY2FjaGUpIHtcbiAgICAgIHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdW3RoaXMuX2tSaXRtRXhwb3J0c10gPSBleHBvcnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdub24tY29yZSBtb2R1bGUgaXMgdW5leHBlY3RlZGx5IG5vdCBpbiByZXF1aXJlLmNhY2hlOiBcIiVzXCInLCBmaWxlbmFtZSlcbiAgICAgIHRoaXMuX2xvY2FsQ2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBIb29rIChtb2R1bGVzLCBvcHRpb25zLCBvbnJlcXVpcmUpIHtcbiAgaWYgKCh0aGlzIGluc3RhbmNlb2YgSG9vaykgPT09IGZhbHNlKSByZXR1cm4gbmV3IEhvb2sobW9kdWxlcywgb3B0aW9ucywgb25yZXF1aXJlKVxuICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbnJlcXVpcmUgPSBtb2R1bGVzXG4gICAgbW9kdWxlcyA9IG51bGxcbiAgICBvcHRpb25zID0gbnVsbFxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25yZXF1aXJlID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6IEV4cGVjdGVkIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lIHRvIGJlIGEgZnVuY3Rpb24gKHdhczogJXMpIC0gYWJvcnRpbmchJywgdHlwZW9mIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lKVxuICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSByZXBvcnQgdGhpcyBlcnJvciBhcyBhbiBpc3N1ZSByZWxhdGVkIHRvIE5vZGUuanMgJXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9yZXF1aXJlLWluLXRoZS1taWRkbGUvaXNzdWVzJywgcHJvY2Vzcy52ZXJzaW9uKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgRXhwb3J0c0NhY2hlKClcblxuICB0aGlzLl91bmhvb2tlZCA9IGZhbHNlXG4gIHRoaXMuX29yaWdSZXF1aXJlID0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgcGF0Y2hpbmcgPSBuZXcgU2V0KClcbiAgY29uc3QgaW50ZXJuYWxzID0gb3B0aW9ucyA/IG9wdGlvbnMuaW50ZXJuYWxzID09PSB0cnVlIDogZmFsc2VcbiAgY29uc3QgaGFzV2hpdGVsaXN0ID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKVxuXG4gIGRlYnVnKCdyZWdpc3RlcmluZyByZXF1aXJlIGhvb2snKVxuXG4gIHRoaXMuX3JlcXVpcmUgPSBNb2R1bGUucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoc2VsZi5fdW5ob29rZWQgPT09IHRydWUpIHtcbiAgICAgIC8vIGlmIHRoZSBwYXRjaGVkIHJlcXVpcmUgZnVuY3Rpb24gY291bGQgbm90IGJlIHJlbW92ZWQgYmVjYXVzZVxuICAgICAgLy8gc29tZW9uZSBlbHNlIHBhdGNoZWQgaXQgYWZ0ZXIgaXQgd2FzIHBhdGNoZWQgaGVyZSwgd2UganVzdFxuICAgICAgLy8gYWJvcnQgYW5kIHBhc3MgdGhlIHJlcXVlc3Qgb253YXJkcyB0byB0aGUgb3JpZ2luYWwgcmVxdWlyZVxuICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlcXVpcmUgY2FsbCAtIG1vZHVsZSBpcyBzb2Z0LXVuaG9va2VkJylcbiAgICAgIHJldHVybiBzZWxmLl9vcmlnUmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZWRSZXF1aXJlLmNhbGwodGhpcywgYXJndW1lbnRzLCBmYWxzZSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVcbiAgICB0aGlzLl9nZXRCdWlsdGluTW9kdWxlID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoc2VsZi5fdW5ob29rZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGNoZWQgcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIGZ1bmN0aW9uIGNvdWxkIG5vdCBiZSByZW1vdmVkIGJlY2F1c2VcbiAgICAgICAgLy8gc29tZW9uZSBlbHNlIHBhdGNoZWQgaXQgYWZ0ZXIgaXQgd2FzIHBhdGNoZWQgaGVyZSwgd2UganVzdCBhYm9ydCBhbmQgcGFzcyB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBvbndhcmRzIHRvIHRoZSBvcmlnaW5hbCBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZSBjYWxsIC0gbW9kdWxlIGlzIHNvZnQtdW5ob29rZWQnKVxuICAgICAgICByZXR1cm4gc2VsZi5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0Y2hlZFJlcXVpcmUuY2FsbCh0aGlzLCBhcmd1bWVudHMsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJlc2VydmUgdGhlIG9yaWdpbmFsIHJlcXVpcmUvcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIGFyZ3VtZW50cyBpbiBgYXJnc2BcbiAgZnVuY3Rpb24gcGF0Y2hlZFJlcXVpcmUgKGFyZ3MsIGNvcmVPbmx5KSB7XG4gICAgY29uc3QgaWQgPSBhcmdzWzBdXG4gICAgY29uc3QgY29yZSA9IGlzQ29yZShpZClcbiAgICBsZXQgZmlsZW5hbWUgLy8gdGhlIHN0cmluZyB1c2VkIGZvciBjYWNoaW5nXG4gICAgaWYgKGNvcmUpIHtcbiAgICAgIGZpbGVuYW1lID0gaWRcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBidWlsdGluIG1vZHVsZSB0aGF0IGNhbiBiZSBpZGVudGlmaWVkIGJvdGggYXMgJ2ZvbycgYW5kXG4gICAgICAvLyAnbm9kZTpmb28nLCB0aGVuIHByZWZlciAnZm9vJyBhcyB0aGUgY2FjaGluZyBrZXkuXG4gICAgICBpZiAoaWQuc3RhcnRzV2l0aCgnbm9kZTonKSkge1xuICAgICAgICBjb25zdCBpZFdpdGhvdXRQcmVmaXggPSBpZC5zbGljZSg1KVxuICAgICAgICBpZiAoaXNDb3JlKGlkV2l0aG91dFByZWZpeCkpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IGlkV2l0aG91dFByZWZpeFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb3JlT25seSkge1xuICAgICAgLy8gYGNvcmVPbmx5YCBpcyBgdHJ1ZWAgaWYgdGhpcyB3YXMgYSBjYWxsIHRvIGBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGVgLCBpbiB3aGljaCBjYXNlXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHJldHVybiBhbnl0aGluZyBpZiB0aGUgcmVxdWVzdGVkIGBpZGAgaXNuJ3QgYSBjb3JlIG1vZHVsZS4gRmFsbGluZ1xuICAgICAgLy8gYmFjayB0byBkZWZhdWx0IGJlaGF2aW91ciwgd2hpY2ggYXQgdGhlIHRpbWUgb2YgdGhpcyB3cnRpbmcgaXMgc2ltcGx5IHJldHVybmluZyBgdW5kZWZpbmVkYFxuICAgICAgZGVidWcoJ2NhbGwgdG8gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlIHdpdGggdW5rbm93biBidWlsdC1pbiBpZCcpXG4gICAgICByZXR1cm4gc2VsZi5fb3JpZ0dldEJ1aWx0aW5Nb2R1bGUuYXBwbHkodGhpcywgYXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZShpZCwgdGhpcylcbiAgICAgIH0gY2F0Y2ggKHJlc29sdmVFcnIpIHtcbiAgICAgICAgLy8gSWYgc29tZW9uZSAqZWxzZSogbW9ua2V5LXBhdGNoZXMgYmVmb3JlIHRoaXMgbW9ua2V5LXBhdGNoLCB0aGVuIHRoYXRcbiAgICAgICAgLy8gY29kZSBtaWdodCBleHBlY3QgYHJlcXVpcmUoc29tZUlkKWAgdG8gZ2V0IHRocm91Z2ggc28gaXQgY2FuIGJlXG4gICAgICAgIC8vIGhhbmRsZWQsIGV2ZW4gaWYgYHNvbWVJZGAgY2Fubm90IGJlIHJlc29sdmVkIHRvIGEgZmlsZW5hbWUuIEluIHRoaXNcbiAgICAgICAgLy8gY2FzZSwgaW5zdGVhZCBvZiB0aHJvd2luZyB3ZSBkZWZlciB0byB0aGUgdW5kZXJseWluZyBgcmVxdWlyZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBleGFtcGxlIHRoZSBBenVyZSBGdW5jdGlvbnMgTm9kZS5qcyB3b3JrZXIgbW9kdWxlIGRvZXMgdGhpcyxcbiAgICAgICAgLy8gd2hlcmUgYEBhenVyZS9mdW5jdGlvbnMtY29yZWAgcmVzb2x2ZXMgdG8gYW4gaW50ZXJuYWwgb2JqZWN0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXp1cmUvYXp1cmUtZnVuY3Rpb25zLW5vZGVqcy13b3JrZXIvYmxvYi92My41LjIvc3JjL3NldHVwQ29yZU1vZHVsZS50cyNMNDYtTDU0XG4gICAgICAgIGRlYnVnKCdNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZShcIiVzXCIpIHRocmV3ICVqLCBjYWxsaW5nIG9yaWdpbmFsIE1vZHVsZS5yZXF1aXJlJywgaWQsIHJlc29sdmVFcnIubWVzc2FnZSlcbiAgICAgICAgcmV0dXJuIHNlbGYuX29yaWdSZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1vZHVsZU5hbWUsIGJhc2VkaXJcblxuICAgIGRlYnVnKCdwcm9jZXNzaW5nICVzIG1vZHVsZSByZXF1aXJlKFxcJyVzXFwnKTogJXMnLCBjb3JlID09PSB0cnVlID8gJ2NvcmUnIDogJ25vbi1jb3JlJywgaWQsIGZpbGVuYW1lKVxuXG4gICAgLy8gcmV0dXJuIGtub3duIHBhdGNoZWQgbW9kdWxlcyBpbW1lZGlhdGVseVxuICAgIGlmIChzZWxmLl9jYWNoZS5oYXMoZmlsZW5hbWUsIGNvcmUpID09PSB0cnVlKSB7XG4gICAgICBkZWJ1ZygncmV0dXJuaW5nIGFscmVhZHkgcGF0Y2hlZCBjYWNoZWQgbW9kdWxlOiAlcycsIGZpbGVuYW1lKVxuICAgICAgcmV0dXJuIHNlbGYuX2NhY2hlLmdldChmaWxlbmFtZSwgY29yZSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIG1vZHVsZSBoYXMgYSBwYXRjaGVyIGluLXByb2dyZXNzIGFscmVhZHkuXG4gICAgLy8gT3RoZXJ3aXNlLCBtYXJrIHRoaXMgbW9kdWxlIGFzIHBhdGNoaW5nIGluLXByb2dyZXNzLlxuICAgIGNvbnN0IGlzUGF0Y2hpbmcgPSBwYXRjaGluZy5oYXMoZmlsZW5hbWUpXG4gICAgaWYgKGlzUGF0Y2hpbmcgPT09IGZhbHNlKSB7XG4gICAgICBwYXRjaGluZy5hZGQoZmlsZW5hbWUpXG4gICAgfVxuXG4gICAgY29uc3QgZXhwb3J0cyA9IGNvcmVPbmx5XG4gICAgICA/IHNlbGYuX29yaWdHZXRCdWlsdGluTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICA6IHNlbGYuX29yaWdSZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3MpXG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgcGF0Y2hlZCwganVzdCByZXR1cm4gaXQgYXMtaXMuXG4gICAgaWYgKGlzUGF0Y2hpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlYnVnKCdtb2R1bGUgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgcGF0Y2hlZCBhbHJlYWR5IC0gaWdub3Jpbmc6ICVzJywgZmlsZW5hbWUpXG4gICAgICByZXR1cm4gZXhwb3J0c1xuICAgIH1cblxuICAgIC8vIFRoZSBtb2R1bGUgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQsXG4gICAgLy8gc28gdGhlIHBhdGNoaW5nIG1hcmsgY2FuIGJlIGNsZWFuZWQgdXAuXG4gICAgcGF0Y2hpbmcuZGVsZXRlKGZpbGVuYW1lKVxuXG4gICAgaWYgKGNvcmUgPT09IHRydWUpIHtcbiAgICAgIGlmIChoYXNXaGl0ZWxpc3QgPT09IHRydWUgJiYgbW9kdWxlcy5pbmNsdWRlcyhmaWxlbmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBjb3JlIG1vZHVsZSBub3Qgb24gd2hpdGVsaXN0OiAlcycsIGZpbGVuYW1lKVxuICAgICAgICByZXR1cm4gZXhwb3J0cyAvLyBhYm9ydCBpZiBtb2R1bGUgbmFtZSBpc24ndCBvbiB3aGl0ZWxpc3RcbiAgICAgIH1cbiAgICAgIG1vZHVsZU5hbWUgPSBmaWxlbmFtZVxuICAgIH0gZWxzZSBpZiAoaGFzV2hpdGVsaXN0ID09PSB0cnVlICYmIG1vZHVsZXMuaW5jbHVkZXMoZmlsZW5hbWUpKSB7XG4gICAgICAvLyB3aGl0ZWxpc3QgaW5jbHVkZXMgdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUgaW5jbHVkaW5nIGV4dGVuc2lvblxuICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UoZmlsZW5hbWUpXG4gICAgICBtb2R1bGVOYW1lID0gcGFyc2VkUGF0aC5uYW1lXG4gICAgICBiYXNlZGlyID0gcGFyc2VkUGF0aC5kaXJcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdCA9IG1vZHVsZURldGFpbHNGcm9tUGF0aChmaWxlbmFtZSlcbiAgICAgIGlmIChzdGF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVidWcoJ2NvdWxkIG5vdCBwYXJzZSBmaWxlbmFtZTogJXMnLCBmaWxlbmFtZSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMgLy8gYWJvcnQgaWYgZmlsZW5hbWUgY291bGQgbm90IGJlIHBhcnNlZFxuICAgICAgfVxuICAgICAgbW9kdWxlTmFtZSA9IHN0YXQubmFtZVxuICAgICAgYmFzZWRpciA9IHN0YXQuYmFzZWRpclxuXG4gICAgICAvLyBFeDogcmVxdWlyZSgnZm9vL2xpYi8uLi9iYXIuanMnKVxuICAgICAgLy8gbW9kdWxlTmFtZSA9ICdmb28nXG4gICAgICAvLyBmdWxsTW9kdWxlTmFtZSA9ICdmb28vYmFyJ1xuICAgICAgY29uc3QgZnVsbE1vZHVsZU5hbWUgPSByZXNvbHZlTW9kdWxlTmFtZShzdGF0KVxuXG4gICAgICBkZWJ1ZygncmVzb2x2ZWQgZmlsZW5hbWUgdG8gbW9kdWxlOiAlcyAoaWQ6ICVzLCByZXNvbHZlZDogJXMsIGJhc2VkaXI6ICVzKScsIG1vZHVsZU5hbWUsIGlkLCBmdWxsTW9kdWxlTmFtZSwgYmFzZWRpcilcblxuICAgICAgbGV0IG1hdGNoRm91bmQgPSBmYWxzZVxuICAgICAgaWYgKGhhc1doaXRlbGlzdCkge1xuICAgICAgICBpZiAoIWlkLnN0YXJ0c1dpdGgoJy4nKSAmJiBtb2R1bGVzLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgIC8vIE5vdCBzdGFydGluZyB3aXRoICcuJyBtZWFucyBgaWRgIGlzIGlkZW50aWZ5aW5nIGEgbW9kdWxlIHBhdGgsXG4gICAgICAgICAgLy8gYXMgb3Bwb3NlZCB0byBhIGxvY2FsIGZpbGUgcGF0aC4gKE5vdGU6IEknbSBub3Qgc3VyZSBhYm91dFxuICAgICAgICAgIC8vIGFic29sdXRlIHBhdGhzLCBidXQgdGhvc2UgYXJlIGhhbmRsZWQgYWJvdmUuKVxuICAgICAgICAgIC8vIElmIHRoaXMgYGlkYCBpcyBpbiBgbW9kdWxlc2AsIHRoZW4gdGhpcyBjb3VsZCBiZSBhIG1hdGNoIHRvIGFuXG4gICAgICAgICAgLy8gcGFja2FnZSBcImV4cG9ydHNcIiBlbnRyeSBwb2ludCB0aGF0IHdvdWxkbid0IG90aGVyd2lzZSBtYXRjaCBiZWxvdy5cbiAgICAgICAgICBtb2R1bGVOYW1lID0gaWRcbiAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWJvcnQgaWYgbW9kdWxlIG5hbWUgaXNuJ3Qgb24gd2hpdGVsaXN0XG4gICAgICAgIGlmICghbW9kdWxlcy5pbmNsdWRlcyhtb2R1bGVOYW1lKSAmJiAhbW9kdWxlcy5pbmNsdWRlcyhmdWxsTW9kdWxlTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0c1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZHVsZXMuaW5jbHVkZXMoZnVsbE1vZHVsZU5hbWUpICYmIGZ1bGxNb2R1bGVOYW1lICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIGl0IG1lYW5zIHRoYXQgd2UncmUgcmVxdWlyaW5nIGEgd2hpdGVsaXN0ZWQgc3ViLW1vZHVsZVxuICAgICAgICAgIG1vZHVsZU5hbWUgPSBmdWxsTW9kdWxlTmFtZVxuICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaEZvdW5kKSB7XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyB0aGUgbWFpbiBtb2R1bGUgZmlsZSwgb3IgYSBmaWxlIGluc2lkZSB0aGUgbW9kdWxlXG4gICAgICAgIGxldCByZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSByZXF1aXJlLnJlc29sdmUobW9kdWxlTmFtZSwgeyBwYXRoczogW2Jhc2VkaXJdIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnY291bGQgbm90IHJlc29sdmUgbW9kdWxlOiAlcycsIG1vZHVsZU5hbWUpXG4gICAgICAgICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgICAgICAgIHJldHVybiBleHBvcnRzIC8vIGFib3J0IGlmIG1vZHVsZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQgKGUuZy4gbm8gbWFpbiBpbiBwYWNrYWdlLmpzb24gYW5kIG5vIGluZGV4LmpzIGZpbGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzICE9PSBmaWxlbmFtZSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBtb2R1bGUtaW50ZXJuYWwgZmlsZVxuICAgICAgICAgIGlmIChpbnRlcm5hbHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgbW9kdWxlLXJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUsIHByZWZpeGVkIGJ5IG9yaWdpbmFsIG1vZHVsZSBuYW1lXG4gICAgICAgICAgICBtb2R1bGVOYW1lID0gbW9kdWxlTmFtZSArIHBhdGguc2VwICsgcGF0aC5yZWxhdGl2ZShiYXNlZGlyLCBmaWxlbmFtZSlcbiAgICAgICAgICAgIGRlYnVnKCdwcmVwYXJpbmcgdG8gcHJvY2VzcyByZXF1aXJlIG9mIGludGVybmFsIGZpbGU6ICVzJywgbW9kdWxlTmFtZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlcXVpcmUgb2Ygbm9uLW1haW4gbW9kdWxlIGZpbGU6ICVzJywgcmVzKVxuICAgICAgICAgICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMgLy8gYWJvcnQgaWYgbm90IG1haW4gbW9kdWxlIGZpbGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgY2FjaGUgZW50cnkgaXMgYXNzaWduZWQgYSB2YWx1ZSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIG9ucmVxdWlyZSwgaW4gY2FzZSBjYWxsaW5nIG9ucmVxdWlyZSByZXF1aXJlcyB0aGUgc2FtZSBtb2R1bGUuXG4gICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzLCBjb3JlKVxuICAgIGRlYnVnKCdjYWxsaW5nIHJlcXVpcmUgaG9vazogJXMnLCBtb2R1bGVOYW1lKVxuICAgIGNvbnN0IHBhdGNoZWRFeHBvcnRzID0gb25yZXF1aXJlKGV4cG9ydHMsIG1vZHVsZU5hbWUsIGJhc2VkaXIpXG4gICAgc2VsZi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBwYXRjaGVkRXhwb3J0cywgY29yZSlcblxuICAgIGRlYnVnKCdyZXR1cm5pbmcgbW9kdWxlOiAlcycsIG1vZHVsZU5hbWUpXG4gICAgcmV0dXJuIHBhdGNoZWRFeHBvcnRzXG4gIH1cbn1cblxuSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl91bmhvb2tlZCA9IHRydWVcblxuICBpZiAodGhpcy5fcmVxdWlyZSA9PT0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlKSB7XG4gICAgTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gdGhpcy5fb3JpZ1JlcXVpcmVcbiAgICBkZWJ1ZygncmVxdWlyZSB1bmhvb2sgc3VjY2Vzc2Z1bCcpXG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3JlcXVpcmUgdW5ob29rIHVuc3VjY2Vzc2Z1bCcpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5fZ2V0QnVpbHRpbk1vZHVsZSA9PT0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKSB7XG4gICAgICBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUgPSB0aGlzLl9vcmlnR2V0QnVpbHRpbk1vZHVsZVxuICAgICAgZGVidWcoJ3Byb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZSB1bmhvb2sgc3VjY2Vzc2Z1bCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUgdW5ob29rIHVuc3VjY2Vzc2Z1bCcpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2R1bGVOYW1lIChzdGF0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5zZXAgIT09ICcvJyA/IHN0YXQucGF0aC5zcGxpdChwYXRoLnNlcCkuam9pbignLycpIDogc3RhdC5wYXRoXG4gIHJldHVybiBwYXRoLnBvc2l4LmpvaW4oc3RhdC5uYW1lLCBub3JtYWxpemVkUGF0aCkucmVwbGFjZShub3JtYWxpemUsICcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/require-in-the-middle@8.0.1/node_modules/require-in-the-middle/index.js\n");

/***/ })

};
;